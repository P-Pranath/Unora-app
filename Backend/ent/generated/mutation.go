// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/UnoraApp/be/ent/generated/auditlog"
	"github.com/UnoraApp/be/ent/generated/checkin"
	"github.com/UnoraApp/be/ent/generated/connection"
	"github.com/UnoraApp/be/ent/generated/creditpackage"
	"github.com/UnoraApp/be/ent/generated/credittransaction"
	"github.com/UnoraApp/be/ent/generated/discoverybatch"
	"github.com/UnoraApp/be/ent/generated/discoverycard"
	"github.com/UnoraApp/be/ent/generated/filter"
	"github.com/UnoraApp/be/ent/generated/hobby"
	"github.com/UnoraApp/be/ent/generated/hobbyoption"
	"github.com/UnoraApp/be/ent/generated/interest"
	"github.com/UnoraApp/be/ent/generated/nudge"
	"github.com/UnoraApp/be/ent/generated/paymentorder"
	"github.com/UnoraApp/be/ent/generated/photo"
	"github.com/UnoraApp/be/ent/generated/predicate"
	"github.com/UnoraApp/be/ent/generated/profile"
	"github.com/UnoraApp/be/ent/generated/reveal"
	"github.com/UnoraApp/be/ent/generated/revealcontent"
	"github.com/UnoraApp/be/ent/generated/revealmilestone"
	"github.com/UnoraApp/be/ent/generated/server"
	"github.com/UnoraApp/be/ent/generated/streak"
	"github.com/UnoraApp/be/ent/generated/user"
	"github.com/UnoraApp/be/ent/generated/userblock"
	"github.com/UnoraApp/be/ent/generated/userreport"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditLog          = "AuditLog"
	TypeCheckIn           = "CheckIn"
	TypeConnection        = "Connection"
	TypeCreditPackage     = "CreditPackage"
	TypeCreditTransaction = "CreditTransaction"
	TypeDiscoveryBatch    = "DiscoveryBatch"
	TypeDiscoveryCard     = "DiscoveryCard"
	TypeFilter            = "Filter"
	TypeHobby             = "Hobby"
	TypeHobbyOption       = "HobbyOption"
	TypeInterest          = "Interest"
	TypeNudge             = "Nudge"
	TypePaymentOrder      = "PaymentOrder"
	TypePhoto             = "Photo"
	TypeProfile           = "Profile"
	TypeReveal            = "Reveal"
	TypeRevealContent     = "RevealContent"
	TypeRevealMilestone   = "RevealMilestone"
	TypeServer            = "Server"
	TypeStreak            = "Streak"
	TypeUser              = "User"
	TypeUserBlock         = "UserBlock"
	TypeUserReport        = "UserReport"
)

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op               Op
	typ              string
	id               *string
	admin_identifier *string
	action           *string
	resource_type    *string
	resource_id      *string
	request_body     *string
	response_summary *string
	ip_address       *string
	user_agent       *string
	success          *bool
	error_message    *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AuditLog, error)
	predicates       []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id string) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAdminIdentifier sets the "admin_identifier" field.
func (m *AuditLogMutation) SetAdminIdentifier(s string) {
	m.admin_identifier = &s
}

// AdminIdentifier returns the value of the "admin_identifier" field in the mutation.
func (m *AuditLogMutation) AdminIdentifier() (r string, exists bool) {
	v := m.admin_identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminIdentifier returns the old "admin_identifier" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAdminIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminIdentifier: %w", err)
	}
	return oldValue.AdminIdentifier, nil
}

// ResetAdminIdentifier resets all changes to the "admin_identifier" field.
func (m *AuditLogMutation) ResetAdminIdentifier() {
	m.admin_identifier = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetResourceType sets the "resource_type" field.
func (m *AuditLogMutation) SetResourceType(s string) {
	m.resource_type = &s
}

// ResourceType returns the value of the "resource_type" field in the mutation.
func (m *AuditLogMutation) ResourceType() (r string, exists bool) {
	v := m.resource_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceType returns the old "resource_type" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceType: %w", err)
	}
	return oldValue.ResourceType, nil
}

// ResetResourceType resets all changes to the "resource_type" field.
func (m *AuditLogMutation) ResetResourceType() {
	m.resource_type = nil
}

// SetResourceID sets the "resource_id" field.
func (m *AuditLogMutation) SetResourceID(s string) {
	m.resource_id = &s
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *AuditLogMutation) ResourceID() (r string, exists bool) {
	v := m.resource_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResourceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ClearResourceID clears the value of the "resource_id" field.
func (m *AuditLogMutation) ClearResourceID() {
	m.resource_id = nil
	m.clearedFields[auditlog.FieldResourceID] = struct{}{}
}

// ResourceIDCleared returns if the "resource_id" field was cleared in this mutation.
func (m *AuditLogMutation) ResourceIDCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResourceID]
	return ok
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *AuditLogMutation) ResetResourceID() {
	m.resource_id = nil
	delete(m.clearedFields, auditlog.FieldResourceID)
}

// SetRequestBody sets the "request_body" field.
func (m *AuditLogMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *AuditLogMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldRequestBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ClearRequestBody clears the value of the "request_body" field.
func (m *AuditLogMutation) ClearRequestBody() {
	m.request_body = nil
	m.clearedFields[auditlog.FieldRequestBody] = struct{}{}
}

// RequestBodyCleared returns if the "request_body" field was cleared in this mutation.
func (m *AuditLogMutation) RequestBodyCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldRequestBody]
	return ok
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *AuditLogMutation) ResetRequestBody() {
	m.request_body = nil
	delete(m.clearedFields, auditlog.FieldRequestBody)
}

// SetResponseSummary sets the "response_summary" field.
func (m *AuditLogMutation) SetResponseSummary(s string) {
	m.response_summary = &s
}

// ResponseSummary returns the value of the "response_summary" field in the mutation.
func (m *AuditLogMutation) ResponseSummary() (r string, exists bool) {
	v := m.response_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseSummary returns the old "response_summary" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldResponseSummary(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseSummary: %w", err)
	}
	return oldValue.ResponseSummary, nil
}

// ClearResponseSummary clears the value of the "response_summary" field.
func (m *AuditLogMutation) ClearResponseSummary() {
	m.response_summary = nil
	m.clearedFields[auditlog.FieldResponseSummary] = struct{}{}
}

// ResponseSummaryCleared returns if the "response_summary" field was cleared in this mutation.
func (m *AuditLogMutation) ResponseSummaryCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldResponseSummary]
	return ok
}

// ResetResponseSummary resets all changes to the "response_summary" field.
func (m *AuditLogMutation) ResetResponseSummary() {
	m.response_summary = nil
	delete(m.clearedFields, auditlog.FieldResponseSummary)
}

// SetIPAddress sets the "ip_address" field.
func (m *AuditLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *AuditLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *AuditLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[auditlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *AuditLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *AuditLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, auditlog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *AuditLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *AuditLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *AuditLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[auditlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *AuditLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *AuditLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, auditlog.FieldUserAgent)
}

// SetSuccess sets the "success" field.
func (m *AuditLogMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *AuditLogMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *AuditLogMutation) ResetSuccess() {
	m.success = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditlog.FieldErrorMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.admin_identifier != nil {
		fields = append(fields, auditlog.FieldAdminIdentifier)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.resource_type != nil {
		fields = append(fields, auditlog.FieldResourceType)
	}
	if m.resource_id != nil {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.request_body != nil {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	if m.response_summary != nil {
		fields = append(fields, auditlog.FieldResponseSummary)
	}
	if m.ip_address != nil {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.success != nil {
		fields = append(fields, auditlog.FieldSuccess)
	}
	if m.error_message != nil {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldAdminIdentifier:
		return m.AdminIdentifier()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldResourceType:
		return m.ResourceType()
	case auditlog.FieldResourceID:
		return m.ResourceID()
	case auditlog.FieldRequestBody:
		return m.RequestBody()
	case auditlog.FieldResponseSummary:
		return m.ResponseSummary()
	case auditlog.FieldIPAddress:
		return m.IPAddress()
	case auditlog.FieldUserAgent:
		return m.UserAgent()
	case auditlog.FieldSuccess:
		return m.Success()
	case auditlog.FieldErrorMessage:
		return m.ErrorMessage()
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldAdminIdentifier:
		return m.OldAdminIdentifier(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldResourceType:
		return m.OldResourceType(ctx)
	case auditlog.FieldResourceID:
		return m.OldResourceID(ctx)
	case auditlog.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case auditlog.FieldResponseSummary:
		return m.OldResponseSummary(ctx)
	case auditlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case auditlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case auditlog.FieldSuccess:
		return m.OldSuccess(ctx)
	case auditlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldAdminIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminIdentifier(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldResourceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceType(v)
		return nil
	case auditlog.FieldResourceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	case auditlog.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case auditlog.FieldResponseSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseSummary(v)
		return nil
	case auditlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case auditlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case auditlog.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case auditlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldResourceID) {
		fields = append(fields, auditlog.FieldResourceID)
	}
	if m.FieldCleared(auditlog.FieldRequestBody) {
		fields = append(fields, auditlog.FieldRequestBody)
	}
	if m.FieldCleared(auditlog.FieldResponseSummary) {
		fields = append(fields, auditlog.FieldResponseSummary)
	}
	if m.FieldCleared(auditlog.FieldIPAddress) {
		fields = append(fields, auditlog.FieldIPAddress)
	}
	if m.FieldCleared(auditlog.FieldUserAgent) {
		fields = append(fields, auditlog.FieldUserAgent)
	}
	if m.FieldCleared(auditlog.FieldErrorMessage) {
		fields = append(fields, auditlog.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldResourceID:
		m.ClearResourceID()
		return nil
	case auditlog.FieldRequestBody:
		m.ClearRequestBody()
		return nil
	case auditlog.FieldResponseSummary:
		m.ClearResponseSummary()
		return nil
	case auditlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case auditlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldAdminIdentifier:
		m.ResetAdminIdentifier()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldResourceType:
		m.ResetResourceType()
		return nil
	case auditlog.FieldResourceID:
		m.ResetResourceID()
		return nil
	case auditlog.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case auditlog.FieldResponseSummary:
		m.ResetResponseSummary()
		return nil
	case auditlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case auditlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case auditlog.FieldSuccess:
		m.ResetSuccess()
		return nil
	case auditlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// CheckInMutation represents an operation that mutates the CheckIn nodes in the graph.
type CheckInMutation struct {
	config
	op            Op
	typ           string
	id            *string
	day_number    *int
	addday_number *int
	check_in_type *checkin.CheckInType
	event_data    *map[string]interface{}
	created_at    *time.Time
	clearedFields map[string]struct{}
	streak        *string
	clearedstreak bool
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*CheckIn, error)
	predicates    []predicate.CheckIn
}

var _ ent.Mutation = (*CheckInMutation)(nil)

// checkinOption allows management of the mutation configuration using functional options.
type checkinOption func(*CheckInMutation)

// newCheckInMutation creates new mutation for the CheckIn entity.
func newCheckInMutation(c config, op Op, opts ...checkinOption) *CheckInMutation {
	m := &CheckInMutation{
		config:        c,
		op:            op,
		typ:           TypeCheckIn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCheckInID sets the ID field of the mutation.
func withCheckInID(id string) checkinOption {
	return func(m *CheckInMutation) {
		var (
			err   error
			once  sync.Once
			value *CheckIn
		)
		m.oldValue = func(ctx context.Context) (*CheckIn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CheckIn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCheckIn sets the old CheckIn of the mutation.
func withCheckIn(node *CheckIn) checkinOption {
	return func(m *CheckInMutation) {
		m.oldValue = func(context.Context) (*CheckIn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CheckInMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CheckInMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CheckIn entities.
func (m *CheckInMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CheckInMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CheckInMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CheckIn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStreakID sets the "streak_id" field.
func (m *CheckInMutation) SetStreakID(s string) {
	m.streak = &s
}

// StreakID returns the value of the "streak_id" field in the mutation.
func (m *CheckInMutation) StreakID() (r string, exists bool) {
	v := m.streak
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakID returns the old "streak_id" field's value of the CheckIn entity.
// If the CheckIn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckInMutation) OldStreakID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakID: %w", err)
	}
	return oldValue.StreakID, nil
}

// ResetStreakID resets all changes to the "streak_id" field.
func (m *CheckInMutation) ResetStreakID() {
	m.streak = nil
}

// SetUserID sets the "user_id" field.
func (m *CheckInMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CheckInMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CheckIn entity.
// If the CheckIn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckInMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CheckInMutation) ResetUserID() {
	m.user = nil
}

// SetDayNumber sets the "day_number" field.
func (m *CheckInMutation) SetDayNumber(i int) {
	m.day_number = &i
	m.addday_number = nil
}

// DayNumber returns the value of the "day_number" field in the mutation.
func (m *CheckInMutation) DayNumber() (r int, exists bool) {
	v := m.day_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDayNumber returns the old "day_number" field's value of the CheckIn entity.
// If the CheckIn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckInMutation) OldDayNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayNumber: %w", err)
	}
	return oldValue.DayNumber, nil
}

// AddDayNumber adds i to the "day_number" field.
func (m *CheckInMutation) AddDayNumber(i int) {
	if m.addday_number != nil {
		*m.addday_number += i
	} else {
		m.addday_number = &i
	}
}

// AddedDayNumber returns the value that was added to the "day_number" field in this mutation.
func (m *CheckInMutation) AddedDayNumber() (r int, exists bool) {
	v := m.addday_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetDayNumber resets all changes to the "day_number" field.
func (m *CheckInMutation) ResetDayNumber() {
	m.day_number = nil
	m.addday_number = nil
}

// SetCheckInType sets the "check_in_type" field.
func (m *CheckInMutation) SetCheckInType(cit checkin.CheckInType) {
	m.check_in_type = &cit
}

// CheckInType returns the value of the "check_in_type" field in the mutation.
func (m *CheckInMutation) CheckInType() (r checkin.CheckInType, exists bool) {
	v := m.check_in_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInType returns the old "check_in_type" field's value of the CheckIn entity.
// If the CheckIn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckInMutation) OldCheckInType(ctx context.Context) (v checkin.CheckInType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInType: %w", err)
	}
	return oldValue.CheckInType, nil
}

// ResetCheckInType resets all changes to the "check_in_type" field.
func (m *CheckInMutation) ResetCheckInType() {
	m.check_in_type = nil
}

// SetEventData sets the "event_data" field.
func (m *CheckInMutation) SetEventData(value map[string]interface{}) {
	m.event_data = &value
}

// EventData returns the value of the "event_data" field in the mutation.
func (m *CheckInMutation) EventData() (r map[string]interface{}, exists bool) {
	v := m.event_data
	if v == nil {
		return
	}
	return *v, true
}

// OldEventData returns the old "event_data" field's value of the CheckIn entity.
// If the CheckIn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckInMutation) OldEventData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventData: %w", err)
	}
	return oldValue.EventData, nil
}

// ClearEventData clears the value of the "event_data" field.
func (m *CheckInMutation) ClearEventData() {
	m.event_data = nil
	m.clearedFields[checkin.FieldEventData] = struct{}{}
}

// EventDataCleared returns if the "event_data" field was cleared in this mutation.
func (m *CheckInMutation) EventDataCleared() bool {
	_, ok := m.clearedFields[checkin.FieldEventData]
	return ok
}

// ResetEventData resets all changes to the "event_data" field.
func (m *CheckInMutation) ResetEventData() {
	m.event_data = nil
	delete(m.clearedFields, checkin.FieldEventData)
}

// SetCreatedAt sets the "created_at" field.
func (m *CheckInMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CheckInMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CheckIn entity.
// If the CheckIn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CheckInMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CheckInMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearStreak clears the "streak" edge to the Streak entity.
func (m *CheckInMutation) ClearStreak() {
	m.clearedstreak = true
	m.clearedFields[checkin.FieldStreakID] = struct{}{}
}

// StreakCleared reports if the "streak" edge to the Streak entity was cleared.
func (m *CheckInMutation) StreakCleared() bool {
	return m.clearedstreak
}

// StreakIDs returns the "streak" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StreakID instead. It exists only for internal usage by the builders.
func (m *CheckInMutation) StreakIDs() (ids []string) {
	if id := m.streak; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStreak resets all changes to the "streak" edge.
func (m *CheckInMutation) ResetStreak() {
	m.streak = nil
	m.clearedstreak = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *CheckInMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[checkin.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CheckInMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CheckInMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CheckInMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CheckInMutation builder.
func (m *CheckInMutation) Where(ps ...predicate.CheckIn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CheckInMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CheckInMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CheckIn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CheckInMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CheckInMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CheckIn).
func (m *CheckInMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CheckInMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.streak != nil {
		fields = append(fields, checkin.FieldStreakID)
	}
	if m.user != nil {
		fields = append(fields, checkin.FieldUserID)
	}
	if m.day_number != nil {
		fields = append(fields, checkin.FieldDayNumber)
	}
	if m.check_in_type != nil {
		fields = append(fields, checkin.FieldCheckInType)
	}
	if m.event_data != nil {
		fields = append(fields, checkin.FieldEventData)
	}
	if m.created_at != nil {
		fields = append(fields, checkin.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CheckInMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checkin.FieldStreakID:
		return m.StreakID()
	case checkin.FieldUserID:
		return m.UserID()
	case checkin.FieldDayNumber:
		return m.DayNumber()
	case checkin.FieldCheckInType:
		return m.CheckInType()
	case checkin.FieldEventData:
		return m.EventData()
	case checkin.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CheckInMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checkin.FieldStreakID:
		return m.OldStreakID(ctx)
	case checkin.FieldUserID:
		return m.OldUserID(ctx)
	case checkin.FieldDayNumber:
		return m.OldDayNumber(ctx)
	case checkin.FieldCheckInType:
		return m.OldCheckInType(ctx)
	case checkin.FieldEventData:
		return m.OldEventData(ctx)
	case checkin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CheckIn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckInMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checkin.FieldStreakID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakID(v)
		return nil
	case checkin.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case checkin.FieldDayNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayNumber(v)
		return nil
	case checkin.FieldCheckInType:
		v, ok := value.(checkin.CheckInType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInType(v)
		return nil
	case checkin.FieldEventData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventData(v)
		return nil
	case checkin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CheckIn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CheckInMutation) AddedFields() []string {
	var fields []string
	if m.addday_number != nil {
		fields = append(fields, checkin.FieldDayNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CheckInMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case checkin.FieldDayNumber:
		return m.AddedDayNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CheckInMutation) AddField(name string, value ent.Value) error {
	switch name {
	case checkin.FieldDayNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayNumber(v)
		return nil
	}
	return fmt.Errorf("unknown CheckIn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CheckInMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checkin.FieldEventData) {
		fields = append(fields, checkin.FieldEventData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CheckInMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CheckInMutation) ClearField(name string) error {
	switch name {
	case checkin.FieldEventData:
		m.ClearEventData()
		return nil
	}
	return fmt.Errorf("unknown CheckIn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CheckInMutation) ResetField(name string) error {
	switch name {
	case checkin.FieldStreakID:
		m.ResetStreakID()
		return nil
	case checkin.FieldUserID:
		m.ResetUserID()
		return nil
	case checkin.FieldDayNumber:
		m.ResetDayNumber()
		return nil
	case checkin.FieldCheckInType:
		m.ResetCheckInType()
		return nil
	case checkin.FieldEventData:
		m.ResetEventData()
		return nil
	case checkin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CheckIn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CheckInMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.streak != nil {
		edges = append(edges, checkin.EdgeStreak)
	}
	if m.user != nil {
		edges = append(edges, checkin.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CheckInMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checkin.EdgeStreak:
		if id := m.streak; id != nil {
			return []ent.Value{*id}
		}
	case checkin.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CheckInMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CheckInMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CheckInMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstreak {
		edges = append(edges, checkin.EdgeStreak)
	}
	if m.cleareduser {
		edges = append(edges, checkin.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CheckInMutation) EdgeCleared(name string) bool {
	switch name {
	case checkin.EdgeStreak:
		return m.clearedstreak
	case checkin.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CheckInMutation) ClearEdge(name string) error {
	switch name {
	case checkin.EdgeStreak:
		m.ClearStreak()
		return nil
	case checkin.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CheckIn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CheckInMutation) ResetEdge(name string) error {
	switch name {
	case checkin.EdgeStreak:
		m.ResetStreak()
		return nil
	case checkin.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CheckIn edge %s", name)
}

// ConnectionMutation represents an operation that mutates the Connection nodes in the graph.
type ConnectionMutation struct {
	config
	op                Op
	typ               string
	id                *string
	server_type       *connection.ServerType
	connection_status *connection.ConnectionStatus
	created_at        *time.Time
	terminated_at     *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	user_a            *string
	cleareduser_a     bool
	user_b            *string
	cleareduser_b     bool
	streak            *string
	clearedstreak     bool
	reveals           map[string]struct{}
	removedreveals    map[string]struct{}
	clearedreveals    bool
	done              bool
	oldValue          func(context.Context) (*Connection, error)
	predicates        []predicate.Connection
}

var _ ent.Mutation = (*ConnectionMutation)(nil)

// connectionOption allows management of the mutation configuration using functional options.
type connectionOption func(*ConnectionMutation)

// newConnectionMutation creates new mutation for the Connection entity.
func newConnectionMutation(c config, op Op, opts ...connectionOption) *ConnectionMutation {
	m := &ConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionID sets the ID field of the mutation.
func withConnectionID(id string) connectionOption {
	return func(m *ConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Connection
		)
		m.oldValue = func(ctx context.Context) (*Connection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnection sets the old Connection of the mutation.
func withConnection(node *Connection) connectionOption {
	return func(m *ConnectionMutation) {
		m.oldValue = func(context.Context) (*Connection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connection entities.
func (m *ConnectionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserAID sets the "user_a_id" field.
func (m *ConnectionMutation) SetUserAID(s string) {
	m.user_a = &s
}

// UserAID returns the value of the "user_a_id" field in the mutation.
func (m *ConnectionMutation) UserAID() (r string, exists bool) {
	v := m.user_a
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAID returns the old "user_a_id" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldUserAID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAID: %w", err)
	}
	return oldValue.UserAID, nil
}

// ResetUserAID resets all changes to the "user_a_id" field.
func (m *ConnectionMutation) ResetUserAID() {
	m.user_a = nil
}

// SetUserBID sets the "user_b_id" field.
func (m *ConnectionMutation) SetUserBID(s string) {
	m.user_b = &s
}

// UserBID returns the value of the "user_b_id" field in the mutation.
func (m *ConnectionMutation) UserBID() (r string, exists bool) {
	v := m.user_b
	if v == nil {
		return
	}
	return *v, true
}

// OldUserBID returns the old "user_b_id" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldUserBID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserBID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserBID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserBID: %w", err)
	}
	return oldValue.UserBID, nil
}

// ResetUserBID resets all changes to the "user_b_id" field.
func (m *ConnectionMutation) ResetUserBID() {
	m.user_b = nil
}

// SetServerType sets the "server_type" field.
func (m *ConnectionMutation) SetServerType(ct connection.ServerType) {
	m.server_type = &ct
}

// ServerType returns the value of the "server_type" field in the mutation.
func (m *ConnectionMutation) ServerType() (r connection.ServerType, exists bool) {
	v := m.server_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerType returns the old "server_type" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldServerType(ctx context.Context) (v connection.ServerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerType: %w", err)
	}
	return oldValue.ServerType, nil
}

// ResetServerType resets all changes to the "server_type" field.
func (m *ConnectionMutation) ResetServerType() {
	m.server_type = nil
}

// SetConnectionStatus sets the "connection_status" field.
func (m *ConnectionMutation) SetConnectionStatus(cs connection.ConnectionStatus) {
	m.connection_status = &cs
}

// ConnectionStatus returns the value of the "connection_status" field in the mutation.
func (m *ConnectionMutation) ConnectionStatus() (r connection.ConnectionStatus, exists bool) {
	v := m.connection_status
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionStatus returns the old "connection_status" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldConnectionStatus(ctx context.Context) (v connection.ConnectionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionStatus: %w", err)
	}
	return oldValue.ConnectionStatus, nil
}

// ResetConnectionStatus resets all changes to the "connection_status" field.
func (m *ConnectionMutation) ResetConnectionStatus() {
	m.connection_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTerminatedAt sets the "terminated_at" field.
func (m *ConnectionMutation) SetTerminatedAt(t time.Time) {
	m.terminated_at = &t
}

// TerminatedAt returns the value of the "terminated_at" field in the mutation.
func (m *ConnectionMutation) TerminatedAt() (r time.Time, exists bool) {
	v := m.terminated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminatedAt returns the old "terminated_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldTerminatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerminatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerminatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminatedAt: %w", err)
	}
	return oldValue.TerminatedAt, nil
}

// ClearTerminatedAt clears the value of the "terminated_at" field.
func (m *ConnectionMutation) ClearTerminatedAt() {
	m.terminated_at = nil
	m.clearedFields[connection.FieldTerminatedAt] = struct{}{}
}

// TerminatedAtCleared returns if the "terminated_at" field was cleared in this mutation.
func (m *ConnectionMutation) TerminatedAtCleared() bool {
	_, ok := m.clearedFields[connection.FieldTerminatedAt]
	return ok
}

// ResetTerminatedAt resets all changes to the "terminated_at" field.
func (m *ConnectionMutation) ResetTerminatedAt() {
	m.terminated_at = nil
	delete(m.clearedFields, connection.FieldTerminatedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ConnectionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ConnectionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ConnectionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[connection.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ConnectionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[connection.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ConnectionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, connection.FieldDeletedAt)
}

// ClearUserA clears the "user_a" edge to the User entity.
func (m *ConnectionMutation) ClearUserA() {
	m.cleareduser_a = true
	m.clearedFields[connection.FieldUserAID] = struct{}{}
}

// UserACleared reports if the "user_a" edge to the User entity was cleared.
func (m *ConnectionMutation) UserACleared() bool {
	return m.cleareduser_a
}

// UserAIDs returns the "user_a" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserAID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) UserAIDs() (ids []string) {
	if id := m.user_a; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserA resets all changes to the "user_a" edge.
func (m *ConnectionMutation) ResetUserA() {
	m.user_a = nil
	m.cleareduser_a = false
}

// ClearUserB clears the "user_b" edge to the User entity.
func (m *ConnectionMutation) ClearUserB() {
	m.cleareduser_b = true
	m.clearedFields[connection.FieldUserBID] = struct{}{}
}

// UserBCleared reports if the "user_b" edge to the User entity was cleared.
func (m *ConnectionMutation) UserBCleared() bool {
	return m.cleareduser_b
}

// UserBIDs returns the "user_b" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserBID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) UserBIDs() (ids []string) {
	if id := m.user_b; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserB resets all changes to the "user_b" edge.
func (m *ConnectionMutation) ResetUserB() {
	m.user_b = nil
	m.cleareduser_b = false
}

// SetStreakID sets the "streak" edge to the Streak entity by id.
func (m *ConnectionMutation) SetStreakID(id string) {
	m.streak = &id
}

// ClearStreak clears the "streak" edge to the Streak entity.
func (m *ConnectionMutation) ClearStreak() {
	m.clearedstreak = true
}

// StreakCleared reports if the "streak" edge to the Streak entity was cleared.
func (m *ConnectionMutation) StreakCleared() bool {
	return m.clearedstreak
}

// StreakID returns the "streak" edge ID in the mutation.
func (m *ConnectionMutation) StreakID() (id string, exists bool) {
	if m.streak != nil {
		return *m.streak, true
	}
	return
}

// StreakIDs returns the "streak" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StreakID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) StreakIDs() (ids []string) {
	if id := m.streak; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStreak resets all changes to the "streak" edge.
func (m *ConnectionMutation) ResetStreak() {
	m.streak = nil
	m.clearedstreak = false
}

// AddRevealIDs adds the "reveals" edge to the Reveal entity by ids.
func (m *ConnectionMutation) AddRevealIDs(ids ...string) {
	if m.reveals == nil {
		m.reveals = make(map[string]struct{})
	}
	for i := range ids {
		m.reveals[ids[i]] = struct{}{}
	}
}

// ClearReveals clears the "reveals" edge to the Reveal entity.
func (m *ConnectionMutation) ClearReveals() {
	m.clearedreveals = true
}

// RevealsCleared reports if the "reveals" edge to the Reveal entity was cleared.
func (m *ConnectionMutation) RevealsCleared() bool {
	return m.clearedreveals
}

// RemoveRevealIDs removes the "reveals" edge to the Reveal entity by IDs.
func (m *ConnectionMutation) RemoveRevealIDs(ids ...string) {
	if m.removedreveals == nil {
		m.removedreveals = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reveals, ids[i])
		m.removedreveals[ids[i]] = struct{}{}
	}
}

// RemovedReveals returns the removed IDs of the "reveals" edge to the Reveal entity.
func (m *ConnectionMutation) RemovedRevealsIDs() (ids []string) {
	for id := range m.removedreveals {
		ids = append(ids, id)
	}
	return
}

// RevealsIDs returns the "reveals" edge IDs in the mutation.
func (m *ConnectionMutation) RevealsIDs() (ids []string) {
	for id := range m.reveals {
		ids = append(ids, id)
	}
	return
}

// ResetReveals resets all changes to the "reveals" edge.
func (m *ConnectionMutation) ResetReveals() {
	m.reveals = nil
	m.clearedreveals = false
	m.removedreveals = nil
}

// Where appends a list predicates to the ConnectionMutation builder.
func (m *ConnectionMutation) Where(ps ...predicate.Connection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Connection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Connection).
func (m *ConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_a != nil {
		fields = append(fields, connection.FieldUserAID)
	}
	if m.user_b != nil {
		fields = append(fields, connection.FieldUserBID)
	}
	if m.server_type != nil {
		fields = append(fields, connection.FieldServerType)
	}
	if m.connection_status != nil {
		fields = append(fields, connection.FieldConnectionStatus)
	}
	if m.created_at != nil {
		fields = append(fields, connection.FieldCreatedAt)
	}
	if m.terminated_at != nil {
		fields = append(fields, connection.FieldTerminatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, connection.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connection.FieldUserAID:
		return m.UserAID()
	case connection.FieldUserBID:
		return m.UserBID()
	case connection.FieldServerType:
		return m.ServerType()
	case connection.FieldConnectionStatus:
		return m.ConnectionStatus()
	case connection.FieldCreatedAt:
		return m.CreatedAt()
	case connection.FieldTerminatedAt:
		return m.TerminatedAt()
	case connection.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connection.FieldUserAID:
		return m.OldUserAID(ctx)
	case connection.FieldUserBID:
		return m.OldUserBID(ctx)
	case connection.FieldServerType:
		return m.OldServerType(ctx)
	case connection.FieldConnectionStatus:
		return m.OldConnectionStatus(ctx)
	case connection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case connection.FieldTerminatedAt:
		return m.OldTerminatedAt(ctx)
	case connection.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Connection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connection.FieldUserAID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAID(v)
		return nil
	case connection.FieldUserBID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserBID(v)
		return nil
	case connection.FieldServerType:
		v, ok := value.(connection.ServerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerType(v)
		return nil
	case connection.FieldConnectionStatus:
		v, ok := value.(connection.ConnectionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionStatus(v)
		return nil
	case connection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case connection.FieldTerminatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminatedAt(v)
		return nil
	case connection.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connection.FieldTerminatedAt) {
		fields = append(fields, connection.FieldTerminatedAt)
	}
	if m.FieldCleared(connection.FieldDeletedAt) {
		fields = append(fields, connection.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionMutation) ClearField(name string) error {
	switch name {
	case connection.FieldTerminatedAt:
		m.ClearTerminatedAt()
		return nil
	case connection.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Connection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionMutation) ResetField(name string) error {
	switch name {
	case connection.FieldUserAID:
		m.ResetUserAID()
		return nil
	case connection.FieldUserBID:
		m.ResetUserBID()
		return nil
	case connection.FieldServerType:
		m.ResetServerType()
		return nil
	case connection.FieldConnectionStatus:
		m.ResetConnectionStatus()
		return nil
	case connection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case connection.FieldTerminatedAt:
		m.ResetTerminatedAt()
		return nil
	case connection.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user_a != nil {
		edges = append(edges, connection.EdgeUserA)
	}
	if m.user_b != nil {
		edges = append(edges, connection.EdgeUserB)
	}
	if m.streak != nil {
		edges = append(edges, connection.EdgeStreak)
	}
	if m.reveals != nil {
		edges = append(edges, connection.EdgeReveals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgeUserA:
		if id := m.user_a; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeUserB:
		if id := m.user_b; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeStreak:
		if id := m.streak; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeReveals:
		ids := make([]ent.Value, 0, len(m.reveals))
		for id := range m.reveals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedreveals != nil {
		edges = append(edges, connection.EdgeReveals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgeReveals:
		ids := make([]ent.Value, 0, len(m.removedreveals))
		for id := range m.removedreveals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser_a {
		edges = append(edges, connection.EdgeUserA)
	}
	if m.cleareduser_b {
		edges = append(edges, connection.EdgeUserB)
	}
	if m.clearedstreak {
		edges = append(edges, connection.EdgeStreak)
	}
	if m.clearedreveals {
		edges = append(edges, connection.EdgeReveals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case connection.EdgeUserA:
		return m.cleareduser_a
	case connection.EdgeUserB:
		return m.cleareduser_b
	case connection.EdgeStreak:
		return m.clearedstreak
	case connection.EdgeReveals:
		return m.clearedreveals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionMutation) ClearEdge(name string) error {
	switch name {
	case connection.EdgeUserA:
		m.ClearUserA()
		return nil
	case connection.EdgeUserB:
		m.ClearUserB()
		return nil
	case connection.EdgeStreak:
		m.ClearStreak()
		return nil
	}
	return fmt.Errorf("unknown Connection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionMutation) ResetEdge(name string) error {
	switch name {
	case connection.EdgeUserA:
		m.ResetUserA()
		return nil
	case connection.EdgeUserB:
		m.ResetUserB()
		return nil
	case connection.EdgeStreak:
		m.ResetStreak()
		return nil
	case connection.EdgeReveals:
		m.ResetReveals()
		return nil
	}
	return fmt.Errorf("unknown Connection edge %s", name)
}

// CreditPackageMutation represents an operation that mutates the CreditPackage nodes in the graph.
type CreditPackageMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	name                *string
	description         *string
	credit_amount       *int
	addcredit_amount    *int
	bonus_credits       *int
	addbonus_credits    *int
	price_amount        *int
	addprice_amount     *int
	currency            *string
	discount_percent    *float64
	adddiscount_percent *float64
	badge_text          *string
	is_popular          *bool
	is_active           *bool
	sort_order          *int
	addsort_order       *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*CreditPackage, error)
	predicates          []predicate.CreditPackage
}

var _ ent.Mutation = (*CreditPackageMutation)(nil)

// creditpackageOption allows management of the mutation configuration using functional options.
type creditpackageOption func(*CreditPackageMutation)

// newCreditPackageMutation creates new mutation for the CreditPackage entity.
func newCreditPackageMutation(c config, op Op, opts ...creditpackageOption) *CreditPackageMutation {
	m := &CreditPackageMutation{
		config:        c,
		op:            op,
		typ:           TypeCreditPackage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditPackageID sets the ID field of the mutation.
func withCreditPackageID(id string) creditpackageOption {
	return func(m *CreditPackageMutation) {
		var (
			err   error
			once  sync.Once
			value *CreditPackage
		)
		m.oldValue = func(ctx context.Context) (*CreditPackage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CreditPackage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreditPackage sets the old CreditPackage of the mutation.
func withCreditPackage(node *CreditPackage) creditpackageOption {
	return func(m *CreditPackageMutation) {
		m.oldValue = func(context.Context) (*CreditPackage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditPackageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditPackageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CreditPackage entities.
func (m *CreditPackageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditPackageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditPackageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CreditPackage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CreditPackageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CreditPackageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CreditPackageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CreditPackageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CreditPackageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CreditPackageMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[creditpackage.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CreditPackageMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[creditpackage.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CreditPackageMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, creditpackage.FieldDescription)
}

// SetCreditAmount sets the "credit_amount" field.
func (m *CreditPackageMutation) SetCreditAmount(i int) {
	m.credit_amount = &i
	m.addcredit_amount = nil
}

// CreditAmount returns the value of the "credit_amount" field in the mutation.
func (m *CreditPackageMutation) CreditAmount() (r int, exists bool) {
	v := m.credit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAmount returns the old "credit_amount" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldCreditAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAmount: %w", err)
	}
	return oldValue.CreditAmount, nil
}

// AddCreditAmount adds i to the "credit_amount" field.
func (m *CreditPackageMutation) AddCreditAmount(i int) {
	if m.addcredit_amount != nil {
		*m.addcredit_amount += i
	} else {
		m.addcredit_amount = &i
	}
}

// AddedCreditAmount returns the value that was added to the "credit_amount" field in this mutation.
func (m *CreditPackageMutation) AddedCreditAmount() (r int, exists bool) {
	v := m.addcredit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditAmount resets all changes to the "credit_amount" field.
func (m *CreditPackageMutation) ResetCreditAmount() {
	m.credit_amount = nil
	m.addcredit_amount = nil
}

// SetBonusCredits sets the "bonus_credits" field.
func (m *CreditPackageMutation) SetBonusCredits(i int) {
	m.bonus_credits = &i
	m.addbonus_credits = nil
}

// BonusCredits returns the value of the "bonus_credits" field in the mutation.
func (m *CreditPackageMutation) BonusCredits() (r int, exists bool) {
	v := m.bonus_credits
	if v == nil {
		return
	}
	return *v, true
}

// OldBonusCredits returns the old "bonus_credits" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldBonusCredits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBonusCredits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBonusCredits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBonusCredits: %w", err)
	}
	return oldValue.BonusCredits, nil
}

// AddBonusCredits adds i to the "bonus_credits" field.
func (m *CreditPackageMutation) AddBonusCredits(i int) {
	if m.addbonus_credits != nil {
		*m.addbonus_credits += i
	} else {
		m.addbonus_credits = &i
	}
}

// AddedBonusCredits returns the value that was added to the "bonus_credits" field in this mutation.
func (m *CreditPackageMutation) AddedBonusCredits() (r int, exists bool) {
	v := m.addbonus_credits
	if v == nil {
		return
	}
	return *v, true
}

// ResetBonusCredits resets all changes to the "bonus_credits" field.
func (m *CreditPackageMutation) ResetBonusCredits() {
	m.bonus_credits = nil
	m.addbonus_credits = nil
}

// SetPriceAmount sets the "price_amount" field.
func (m *CreditPackageMutation) SetPriceAmount(i int) {
	m.price_amount = &i
	m.addprice_amount = nil
}

// PriceAmount returns the value of the "price_amount" field in the mutation.
func (m *CreditPackageMutation) PriceAmount() (r int, exists bool) {
	v := m.price_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceAmount returns the old "price_amount" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldPriceAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceAmount: %w", err)
	}
	return oldValue.PriceAmount, nil
}

// AddPriceAmount adds i to the "price_amount" field.
func (m *CreditPackageMutation) AddPriceAmount(i int) {
	if m.addprice_amount != nil {
		*m.addprice_amount += i
	} else {
		m.addprice_amount = &i
	}
}

// AddedPriceAmount returns the value that was added to the "price_amount" field in this mutation.
func (m *CreditPackageMutation) AddedPriceAmount() (r int, exists bool) {
	v := m.addprice_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceAmount resets all changes to the "price_amount" field.
func (m *CreditPackageMutation) ResetPriceAmount() {
	m.price_amount = nil
	m.addprice_amount = nil
}

// SetCurrency sets the "currency" field.
func (m *CreditPackageMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *CreditPackageMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *CreditPackageMutation) ResetCurrency() {
	m.currency = nil
}

// SetDiscountPercent sets the "discount_percent" field.
func (m *CreditPackageMutation) SetDiscountPercent(f float64) {
	m.discount_percent = &f
	m.adddiscount_percent = nil
}

// DiscountPercent returns the value of the "discount_percent" field in the mutation.
func (m *CreditPackageMutation) DiscountPercent() (r float64, exists bool) {
	v := m.discount_percent
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPercent returns the old "discount_percent" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldDiscountPercent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPercent: %w", err)
	}
	return oldValue.DiscountPercent, nil
}

// AddDiscountPercent adds f to the "discount_percent" field.
func (m *CreditPackageMutation) AddDiscountPercent(f float64) {
	if m.adddiscount_percent != nil {
		*m.adddiscount_percent += f
	} else {
		m.adddiscount_percent = &f
	}
}

// AddedDiscountPercent returns the value that was added to the "discount_percent" field in this mutation.
func (m *CreditPackageMutation) AddedDiscountPercent() (r float64, exists bool) {
	v := m.adddiscount_percent
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountPercent resets all changes to the "discount_percent" field.
func (m *CreditPackageMutation) ResetDiscountPercent() {
	m.discount_percent = nil
	m.adddiscount_percent = nil
}

// SetBadgeText sets the "badge_text" field.
func (m *CreditPackageMutation) SetBadgeText(s string) {
	m.badge_text = &s
}

// BadgeText returns the value of the "badge_text" field in the mutation.
func (m *CreditPackageMutation) BadgeText() (r string, exists bool) {
	v := m.badge_text
	if v == nil {
		return
	}
	return *v, true
}

// OldBadgeText returns the old "badge_text" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldBadgeText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBadgeText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBadgeText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBadgeText: %w", err)
	}
	return oldValue.BadgeText, nil
}

// ClearBadgeText clears the value of the "badge_text" field.
func (m *CreditPackageMutation) ClearBadgeText() {
	m.badge_text = nil
	m.clearedFields[creditpackage.FieldBadgeText] = struct{}{}
}

// BadgeTextCleared returns if the "badge_text" field was cleared in this mutation.
func (m *CreditPackageMutation) BadgeTextCleared() bool {
	_, ok := m.clearedFields[creditpackage.FieldBadgeText]
	return ok
}

// ResetBadgeText resets all changes to the "badge_text" field.
func (m *CreditPackageMutation) ResetBadgeText() {
	m.badge_text = nil
	delete(m.clearedFields, creditpackage.FieldBadgeText)
}

// SetIsPopular sets the "is_popular" field.
func (m *CreditPackageMutation) SetIsPopular(b bool) {
	m.is_popular = &b
}

// IsPopular returns the value of the "is_popular" field in the mutation.
func (m *CreditPackageMutation) IsPopular() (r bool, exists bool) {
	v := m.is_popular
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPopular returns the old "is_popular" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldIsPopular(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPopular is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPopular requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPopular: %w", err)
	}
	return oldValue.IsPopular, nil
}

// ResetIsPopular resets all changes to the "is_popular" field.
func (m *CreditPackageMutation) ResetIsPopular() {
	m.is_popular = nil
}

// SetIsActive sets the "is_active" field.
func (m *CreditPackageMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *CreditPackageMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *CreditPackageMutation) ResetIsActive() {
	m.is_active = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *CreditPackageMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *CreditPackageMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the CreditPackage entity.
// If the CreditPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditPackageMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *CreditPackageMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *CreditPackageMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *CreditPackageMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// Where appends a list predicates to the CreditPackageMutation builder.
func (m *CreditPackageMutation) Where(ps ...predicate.CreditPackage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditPackageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditPackageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CreditPackage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditPackageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditPackageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CreditPackage).
func (m *CreditPackageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditPackageMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, creditpackage.FieldName)
	}
	if m.description != nil {
		fields = append(fields, creditpackage.FieldDescription)
	}
	if m.credit_amount != nil {
		fields = append(fields, creditpackage.FieldCreditAmount)
	}
	if m.bonus_credits != nil {
		fields = append(fields, creditpackage.FieldBonusCredits)
	}
	if m.price_amount != nil {
		fields = append(fields, creditpackage.FieldPriceAmount)
	}
	if m.currency != nil {
		fields = append(fields, creditpackage.FieldCurrency)
	}
	if m.discount_percent != nil {
		fields = append(fields, creditpackage.FieldDiscountPercent)
	}
	if m.badge_text != nil {
		fields = append(fields, creditpackage.FieldBadgeText)
	}
	if m.is_popular != nil {
		fields = append(fields, creditpackage.FieldIsPopular)
	}
	if m.is_active != nil {
		fields = append(fields, creditpackage.FieldIsActive)
	}
	if m.sort_order != nil {
		fields = append(fields, creditpackage.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditPackageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case creditpackage.FieldName:
		return m.Name()
	case creditpackage.FieldDescription:
		return m.Description()
	case creditpackage.FieldCreditAmount:
		return m.CreditAmount()
	case creditpackage.FieldBonusCredits:
		return m.BonusCredits()
	case creditpackage.FieldPriceAmount:
		return m.PriceAmount()
	case creditpackage.FieldCurrency:
		return m.Currency()
	case creditpackage.FieldDiscountPercent:
		return m.DiscountPercent()
	case creditpackage.FieldBadgeText:
		return m.BadgeText()
	case creditpackage.FieldIsPopular:
		return m.IsPopular()
	case creditpackage.FieldIsActive:
		return m.IsActive()
	case creditpackage.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditPackageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case creditpackage.FieldName:
		return m.OldName(ctx)
	case creditpackage.FieldDescription:
		return m.OldDescription(ctx)
	case creditpackage.FieldCreditAmount:
		return m.OldCreditAmount(ctx)
	case creditpackage.FieldBonusCredits:
		return m.OldBonusCredits(ctx)
	case creditpackage.FieldPriceAmount:
		return m.OldPriceAmount(ctx)
	case creditpackage.FieldCurrency:
		return m.OldCurrency(ctx)
	case creditpackage.FieldDiscountPercent:
		return m.OldDiscountPercent(ctx)
	case creditpackage.FieldBadgeText:
		return m.OldBadgeText(ctx)
	case creditpackage.FieldIsPopular:
		return m.OldIsPopular(ctx)
	case creditpackage.FieldIsActive:
		return m.OldIsActive(ctx)
	case creditpackage.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown CreditPackage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditPackageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case creditpackage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case creditpackage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case creditpackage.FieldCreditAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAmount(v)
		return nil
	case creditpackage.FieldBonusCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBonusCredits(v)
		return nil
	case creditpackage.FieldPriceAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceAmount(v)
		return nil
	case creditpackage.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case creditpackage.FieldDiscountPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPercent(v)
		return nil
	case creditpackage.FieldBadgeText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBadgeText(v)
		return nil
	case creditpackage.FieldIsPopular:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPopular(v)
		return nil
	case creditpackage.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case creditpackage.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CreditPackage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditPackageMutation) AddedFields() []string {
	var fields []string
	if m.addcredit_amount != nil {
		fields = append(fields, creditpackage.FieldCreditAmount)
	}
	if m.addbonus_credits != nil {
		fields = append(fields, creditpackage.FieldBonusCredits)
	}
	if m.addprice_amount != nil {
		fields = append(fields, creditpackage.FieldPriceAmount)
	}
	if m.adddiscount_percent != nil {
		fields = append(fields, creditpackage.FieldDiscountPercent)
	}
	if m.addsort_order != nil {
		fields = append(fields, creditpackage.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditPackageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case creditpackage.FieldCreditAmount:
		return m.AddedCreditAmount()
	case creditpackage.FieldBonusCredits:
		return m.AddedBonusCredits()
	case creditpackage.FieldPriceAmount:
		return m.AddedPriceAmount()
	case creditpackage.FieldDiscountPercent:
		return m.AddedDiscountPercent()
	case creditpackage.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditPackageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case creditpackage.FieldCreditAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAmount(v)
		return nil
	case creditpackage.FieldBonusCredits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBonusCredits(v)
		return nil
	case creditpackage.FieldPriceAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceAmount(v)
		return nil
	case creditpackage.FieldDiscountPercent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountPercent(v)
		return nil
	case creditpackage.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown CreditPackage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditPackageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(creditpackage.FieldDescription) {
		fields = append(fields, creditpackage.FieldDescription)
	}
	if m.FieldCleared(creditpackage.FieldBadgeText) {
		fields = append(fields, creditpackage.FieldBadgeText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditPackageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditPackageMutation) ClearField(name string) error {
	switch name {
	case creditpackage.FieldDescription:
		m.ClearDescription()
		return nil
	case creditpackage.FieldBadgeText:
		m.ClearBadgeText()
		return nil
	}
	return fmt.Errorf("unknown CreditPackage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditPackageMutation) ResetField(name string) error {
	switch name {
	case creditpackage.FieldName:
		m.ResetName()
		return nil
	case creditpackage.FieldDescription:
		m.ResetDescription()
		return nil
	case creditpackage.FieldCreditAmount:
		m.ResetCreditAmount()
		return nil
	case creditpackage.FieldBonusCredits:
		m.ResetBonusCredits()
		return nil
	case creditpackage.FieldPriceAmount:
		m.ResetPriceAmount()
		return nil
	case creditpackage.FieldCurrency:
		m.ResetCurrency()
		return nil
	case creditpackage.FieldDiscountPercent:
		m.ResetDiscountPercent()
		return nil
	case creditpackage.FieldBadgeText:
		m.ResetBadgeText()
		return nil
	case creditpackage.FieldIsPopular:
		m.ResetIsPopular()
		return nil
	case creditpackage.FieldIsActive:
		m.ResetIsActive()
		return nil
	case creditpackage.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown CreditPackage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditPackageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditPackageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditPackageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditPackageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditPackageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditPackageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditPackageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CreditPackage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditPackageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CreditPackage edge %s", name)
}

// CreditTransactionMutation represents an operation that mutates the CreditTransaction nodes in the graph.
type CreditTransactionMutation struct {
	config
	op               Op
	typ              string
	id               *string
	transaction_type *credittransaction.TransactionType
	credit_amount    *int
	addcredit_amount *int
	balance_after    *int
	addbalance_after *int
	reference_type   *string
	reference_id     *string
	description      *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	user             *string
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*CreditTransaction, error)
	predicates       []predicate.CreditTransaction
}

var _ ent.Mutation = (*CreditTransactionMutation)(nil)

// credittransactionOption allows management of the mutation configuration using functional options.
type credittransactionOption func(*CreditTransactionMutation)

// newCreditTransactionMutation creates new mutation for the CreditTransaction entity.
func newCreditTransactionMutation(c config, op Op, opts ...credittransactionOption) *CreditTransactionMutation {
	m := &CreditTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeCreditTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreditTransactionID sets the ID field of the mutation.
func withCreditTransactionID(id string) credittransactionOption {
	return func(m *CreditTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *CreditTransaction
		)
		m.oldValue = func(ctx context.Context) (*CreditTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CreditTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreditTransaction sets the old CreditTransaction of the mutation.
func withCreditTransaction(node *CreditTransaction) credittransactionOption {
	return func(m *CreditTransactionMutation) {
		m.oldValue = func(context.Context) (*CreditTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreditTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreditTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CreditTransaction entities.
func (m *CreditTransactionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreditTransactionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreditTransactionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CreditTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CreditTransactionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CreditTransactionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CreditTransactionMutation) ResetUserID() {
	m.user = nil
}

// SetTransactionType sets the "transaction_type" field.
func (m *CreditTransactionMutation) SetTransactionType(ct credittransaction.TransactionType) {
	m.transaction_type = &ct
}

// TransactionType returns the value of the "transaction_type" field in the mutation.
func (m *CreditTransactionMutation) TransactionType() (r credittransaction.TransactionType, exists bool) {
	v := m.transaction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "transaction_type" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldTransactionType(ctx context.Context) (v credittransaction.TransactionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ResetTransactionType resets all changes to the "transaction_type" field.
func (m *CreditTransactionMutation) ResetTransactionType() {
	m.transaction_type = nil
}

// SetCreditAmount sets the "credit_amount" field.
func (m *CreditTransactionMutation) SetCreditAmount(i int) {
	m.credit_amount = &i
	m.addcredit_amount = nil
}

// CreditAmount returns the value of the "credit_amount" field in the mutation.
func (m *CreditTransactionMutation) CreditAmount() (r int, exists bool) {
	v := m.credit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAmount returns the old "credit_amount" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldCreditAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAmount: %w", err)
	}
	return oldValue.CreditAmount, nil
}

// AddCreditAmount adds i to the "credit_amount" field.
func (m *CreditTransactionMutation) AddCreditAmount(i int) {
	if m.addcredit_amount != nil {
		*m.addcredit_amount += i
	} else {
		m.addcredit_amount = &i
	}
}

// AddedCreditAmount returns the value that was added to the "credit_amount" field in this mutation.
func (m *CreditTransactionMutation) AddedCreditAmount() (r int, exists bool) {
	v := m.addcredit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditAmount resets all changes to the "credit_amount" field.
func (m *CreditTransactionMutation) ResetCreditAmount() {
	m.credit_amount = nil
	m.addcredit_amount = nil
}

// SetBalanceAfter sets the "balance_after" field.
func (m *CreditTransactionMutation) SetBalanceAfter(i int) {
	m.balance_after = &i
	m.addbalance_after = nil
}

// BalanceAfter returns the value of the "balance_after" field in the mutation.
func (m *CreditTransactionMutation) BalanceAfter() (r int, exists bool) {
	v := m.balance_after
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceAfter returns the old "balance_after" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldBalanceAfter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceAfter: %w", err)
	}
	return oldValue.BalanceAfter, nil
}

// AddBalanceAfter adds i to the "balance_after" field.
func (m *CreditTransactionMutation) AddBalanceAfter(i int) {
	if m.addbalance_after != nil {
		*m.addbalance_after += i
	} else {
		m.addbalance_after = &i
	}
}

// AddedBalanceAfter returns the value that was added to the "balance_after" field in this mutation.
func (m *CreditTransactionMutation) AddedBalanceAfter() (r int, exists bool) {
	v := m.addbalance_after
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalanceAfter resets all changes to the "balance_after" field.
func (m *CreditTransactionMutation) ResetBalanceAfter() {
	m.balance_after = nil
	m.addbalance_after = nil
}

// SetReferenceType sets the "reference_type" field.
func (m *CreditTransactionMutation) SetReferenceType(s string) {
	m.reference_type = &s
}

// ReferenceType returns the value of the "reference_type" field in the mutation.
func (m *CreditTransactionMutation) ReferenceType() (r string, exists bool) {
	v := m.reference_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceType returns the old "reference_type" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldReferenceType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceType: %w", err)
	}
	return oldValue.ReferenceType, nil
}

// ClearReferenceType clears the value of the "reference_type" field.
func (m *CreditTransactionMutation) ClearReferenceType() {
	m.reference_type = nil
	m.clearedFields[credittransaction.FieldReferenceType] = struct{}{}
}

// ReferenceTypeCleared returns if the "reference_type" field was cleared in this mutation.
func (m *CreditTransactionMutation) ReferenceTypeCleared() bool {
	_, ok := m.clearedFields[credittransaction.FieldReferenceType]
	return ok
}

// ResetReferenceType resets all changes to the "reference_type" field.
func (m *CreditTransactionMutation) ResetReferenceType() {
	m.reference_type = nil
	delete(m.clearedFields, credittransaction.FieldReferenceType)
}

// SetReferenceID sets the "reference_id" field.
func (m *CreditTransactionMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *CreditTransactionMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldReferenceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *CreditTransactionMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[credittransaction.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *CreditTransactionMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[credittransaction.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *CreditTransactionMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, credittransaction.FieldReferenceID)
}

// SetDescription sets the "description" field.
func (m *CreditTransactionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CreditTransactionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CreditTransactionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[credittransaction.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CreditTransactionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[credittransaction.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CreditTransactionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, credittransaction.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *CreditTransactionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CreditTransactionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CreditTransaction entity.
// If the CreditTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreditTransactionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CreditTransactionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CreditTransactionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[credittransaction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CreditTransactionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CreditTransactionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CreditTransactionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CreditTransactionMutation builder.
func (m *CreditTransactionMutation) Where(ps ...predicate.CreditTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CreditTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CreditTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CreditTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CreditTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CreditTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CreditTransaction).
func (m *CreditTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreditTransactionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user != nil {
		fields = append(fields, credittransaction.FieldUserID)
	}
	if m.transaction_type != nil {
		fields = append(fields, credittransaction.FieldTransactionType)
	}
	if m.credit_amount != nil {
		fields = append(fields, credittransaction.FieldCreditAmount)
	}
	if m.balance_after != nil {
		fields = append(fields, credittransaction.FieldBalanceAfter)
	}
	if m.reference_type != nil {
		fields = append(fields, credittransaction.FieldReferenceType)
	}
	if m.reference_id != nil {
		fields = append(fields, credittransaction.FieldReferenceID)
	}
	if m.description != nil {
		fields = append(fields, credittransaction.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, credittransaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreditTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case credittransaction.FieldUserID:
		return m.UserID()
	case credittransaction.FieldTransactionType:
		return m.TransactionType()
	case credittransaction.FieldCreditAmount:
		return m.CreditAmount()
	case credittransaction.FieldBalanceAfter:
		return m.BalanceAfter()
	case credittransaction.FieldReferenceType:
		return m.ReferenceType()
	case credittransaction.FieldReferenceID:
		return m.ReferenceID()
	case credittransaction.FieldDescription:
		return m.Description()
	case credittransaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreditTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case credittransaction.FieldUserID:
		return m.OldUserID(ctx)
	case credittransaction.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case credittransaction.FieldCreditAmount:
		return m.OldCreditAmount(ctx)
	case credittransaction.FieldBalanceAfter:
		return m.OldBalanceAfter(ctx)
	case credittransaction.FieldReferenceType:
		return m.OldReferenceType(ctx)
	case credittransaction.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case credittransaction.FieldDescription:
		return m.OldDescription(ctx)
	case credittransaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CreditTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case credittransaction.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case credittransaction.FieldTransactionType:
		v, ok := value.(credittransaction.TransactionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case credittransaction.FieldCreditAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAmount(v)
		return nil
	case credittransaction.FieldBalanceAfter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceAfter(v)
		return nil
	case credittransaction.FieldReferenceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceType(v)
		return nil
	case credittransaction.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case credittransaction.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case credittransaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CreditTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreditTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addcredit_amount != nil {
		fields = append(fields, credittransaction.FieldCreditAmount)
	}
	if m.addbalance_after != nil {
		fields = append(fields, credittransaction.FieldBalanceAfter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreditTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case credittransaction.FieldCreditAmount:
		return m.AddedCreditAmount()
	case credittransaction.FieldBalanceAfter:
		return m.AddedBalanceAfter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreditTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case credittransaction.FieldCreditAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAmount(v)
		return nil
	case credittransaction.FieldBalanceAfter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalanceAfter(v)
		return nil
	}
	return fmt.Errorf("unknown CreditTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreditTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(credittransaction.FieldReferenceType) {
		fields = append(fields, credittransaction.FieldReferenceType)
	}
	if m.FieldCleared(credittransaction.FieldReferenceID) {
		fields = append(fields, credittransaction.FieldReferenceID)
	}
	if m.FieldCleared(credittransaction.FieldDescription) {
		fields = append(fields, credittransaction.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreditTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreditTransactionMutation) ClearField(name string) error {
	switch name {
	case credittransaction.FieldReferenceType:
		m.ClearReferenceType()
		return nil
	case credittransaction.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case credittransaction.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CreditTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreditTransactionMutation) ResetField(name string) error {
	switch name {
	case credittransaction.FieldUserID:
		m.ResetUserID()
		return nil
	case credittransaction.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case credittransaction.FieldCreditAmount:
		m.ResetCreditAmount()
		return nil
	case credittransaction.FieldBalanceAfter:
		m.ResetBalanceAfter()
		return nil
	case credittransaction.FieldReferenceType:
		m.ResetReferenceType()
		return nil
	case credittransaction.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case credittransaction.FieldDescription:
		m.ResetDescription()
		return nil
	case credittransaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown CreditTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreditTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, credittransaction.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreditTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case credittransaction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreditTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreditTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreditTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, credittransaction.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreditTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case credittransaction.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreditTransactionMutation) ClearEdge(name string) error {
	switch name {
	case credittransaction.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CreditTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreditTransactionMutation) ResetEdge(name string) error {
	switch name {
	case credittransaction.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CreditTransaction edge %s", name)
}

// DiscoveryBatchMutation represents an operation that mutates the DiscoveryBatch nodes in the graph.
type DiscoveryBatchMutation struct {
	config
	op              Op
	typ             string
	id              *string
	server_type     *discoverybatch.ServerType
	batch_status    *discoverybatch.BatchStatus
	filter_snapshot *map[string]interface{}
	created_at      *time.Time
	expires_at      *time.Time
	deleted_at      *time.Time
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	cards           map[string]struct{}
	removedcards    map[string]struct{}
	clearedcards    bool
	done            bool
	oldValue        func(context.Context) (*DiscoveryBatch, error)
	predicates      []predicate.DiscoveryBatch
}

var _ ent.Mutation = (*DiscoveryBatchMutation)(nil)

// discoverybatchOption allows management of the mutation configuration using functional options.
type discoverybatchOption func(*DiscoveryBatchMutation)

// newDiscoveryBatchMutation creates new mutation for the DiscoveryBatch entity.
func newDiscoveryBatchMutation(c config, op Op, opts ...discoverybatchOption) *DiscoveryBatchMutation {
	m := &DiscoveryBatchMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscoveryBatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscoveryBatchID sets the ID field of the mutation.
func withDiscoveryBatchID(id string) discoverybatchOption {
	return func(m *DiscoveryBatchMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscoveryBatch
		)
		m.oldValue = func(ctx context.Context) (*DiscoveryBatch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscoveryBatch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscoveryBatch sets the old DiscoveryBatch of the mutation.
func withDiscoveryBatch(node *DiscoveryBatch) discoverybatchOption {
	return func(m *DiscoveryBatchMutation) {
		m.oldValue = func(context.Context) (*DiscoveryBatch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscoveryBatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscoveryBatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DiscoveryBatch entities.
func (m *DiscoveryBatchMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscoveryBatchMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscoveryBatchMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscoveryBatch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *DiscoveryBatchMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DiscoveryBatchMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DiscoveryBatch entity.
// If the DiscoveryBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryBatchMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DiscoveryBatchMutation) ResetUserID() {
	m.user = nil
}

// SetServerType sets the "server_type" field.
func (m *DiscoveryBatchMutation) SetServerType(dt discoverybatch.ServerType) {
	m.server_type = &dt
}

// ServerType returns the value of the "server_type" field in the mutation.
func (m *DiscoveryBatchMutation) ServerType() (r discoverybatch.ServerType, exists bool) {
	v := m.server_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerType returns the old "server_type" field's value of the DiscoveryBatch entity.
// If the DiscoveryBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryBatchMutation) OldServerType(ctx context.Context) (v discoverybatch.ServerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerType: %w", err)
	}
	return oldValue.ServerType, nil
}

// ResetServerType resets all changes to the "server_type" field.
func (m *DiscoveryBatchMutation) ResetServerType() {
	m.server_type = nil
}

// SetBatchStatus sets the "batch_status" field.
func (m *DiscoveryBatchMutation) SetBatchStatus(ds discoverybatch.BatchStatus) {
	m.batch_status = &ds
}

// BatchStatus returns the value of the "batch_status" field in the mutation.
func (m *DiscoveryBatchMutation) BatchStatus() (r discoverybatch.BatchStatus, exists bool) {
	v := m.batch_status
	if v == nil {
		return
	}
	return *v, true
}

// OldBatchStatus returns the old "batch_status" field's value of the DiscoveryBatch entity.
// If the DiscoveryBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryBatchMutation) OldBatchStatus(ctx context.Context) (v discoverybatch.BatchStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatchStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatchStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatchStatus: %w", err)
	}
	return oldValue.BatchStatus, nil
}

// ResetBatchStatus resets all changes to the "batch_status" field.
func (m *DiscoveryBatchMutation) ResetBatchStatus() {
	m.batch_status = nil
}

// SetFilterSnapshot sets the "filter_snapshot" field.
func (m *DiscoveryBatchMutation) SetFilterSnapshot(value map[string]interface{}) {
	m.filter_snapshot = &value
}

// FilterSnapshot returns the value of the "filter_snapshot" field in the mutation.
func (m *DiscoveryBatchMutation) FilterSnapshot() (r map[string]interface{}, exists bool) {
	v := m.filter_snapshot
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterSnapshot returns the old "filter_snapshot" field's value of the DiscoveryBatch entity.
// If the DiscoveryBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryBatchMutation) OldFilterSnapshot(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterSnapshot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterSnapshot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterSnapshot: %w", err)
	}
	return oldValue.FilterSnapshot, nil
}

// ClearFilterSnapshot clears the value of the "filter_snapshot" field.
func (m *DiscoveryBatchMutation) ClearFilterSnapshot() {
	m.filter_snapshot = nil
	m.clearedFields[discoverybatch.FieldFilterSnapshot] = struct{}{}
}

// FilterSnapshotCleared returns if the "filter_snapshot" field was cleared in this mutation.
func (m *DiscoveryBatchMutation) FilterSnapshotCleared() bool {
	_, ok := m.clearedFields[discoverybatch.FieldFilterSnapshot]
	return ok
}

// ResetFilterSnapshot resets all changes to the "filter_snapshot" field.
func (m *DiscoveryBatchMutation) ResetFilterSnapshot() {
	m.filter_snapshot = nil
	delete(m.clearedFields, discoverybatch.FieldFilterSnapshot)
}

// SetCreatedAt sets the "created_at" field.
func (m *DiscoveryBatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiscoveryBatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DiscoveryBatch entity.
// If the DiscoveryBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryBatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiscoveryBatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *DiscoveryBatchMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *DiscoveryBatchMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the DiscoveryBatch entity.
// If the DiscoveryBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryBatchMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *DiscoveryBatchMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[discoverybatch.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *DiscoveryBatchMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[discoverybatch.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *DiscoveryBatchMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, discoverybatch.FieldExpiresAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DiscoveryBatchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DiscoveryBatchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DiscoveryBatch entity.
// If the DiscoveryBatch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryBatchMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DiscoveryBatchMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[discoverybatch.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DiscoveryBatchMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[discoverybatch.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DiscoveryBatchMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, discoverybatch.FieldDeletedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *DiscoveryBatchMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[discoverybatch.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DiscoveryBatchMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DiscoveryBatchMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DiscoveryBatchMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddCardIDs adds the "cards" edge to the DiscoveryCard entity by ids.
func (m *DiscoveryBatchMutation) AddCardIDs(ids ...string) {
	if m.cards == nil {
		m.cards = make(map[string]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the DiscoveryCard entity.
func (m *DiscoveryBatchMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the DiscoveryCard entity was cleared.
func (m *DiscoveryBatchMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the DiscoveryCard entity by IDs.
func (m *DiscoveryBatchMutation) RemoveCardIDs(ids ...string) {
	if m.removedcards == nil {
		m.removedcards = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the DiscoveryCard entity.
func (m *DiscoveryBatchMutation) RemovedCardsIDs() (ids []string) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *DiscoveryBatchMutation) CardsIDs() (ids []string) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *DiscoveryBatchMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// Where appends a list predicates to the DiscoveryBatchMutation builder.
func (m *DiscoveryBatchMutation) Where(ps ...predicate.DiscoveryBatch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscoveryBatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscoveryBatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscoveryBatch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscoveryBatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscoveryBatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscoveryBatch).
func (m *DiscoveryBatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscoveryBatchMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, discoverybatch.FieldUserID)
	}
	if m.server_type != nil {
		fields = append(fields, discoverybatch.FieldServerType)
	}
	if m.batch_status != nil {
		fields = append(fields, discoverybatch.FieldBatchStatus)
	}
	if m.filter_snapshot != nil {
		fields = append(fields, discoverybatch.FieldFilterSnapshot)
	}
	if m.created_at != nil {
		fields = append(fields, discoverybatch.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, discoverybatch.FieldExpiresAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, discoverybatch.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscoveryBatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discoverybatch.FieldUserID:
		return m.UserID()
	case discoverybatch.FieldServerType:
		return m.ServerType()
	case discoverybatch.FieldBatchStatus:
		return m.BatchStatus()
	case discoverybatch.FieldFilterSnapshot:
		return m.FilterSnapshot()
	case discoverybatch.FieldCreatedAt:
		return m.CreatedAt()
	case discoverybatch.FieldExpiresAt:
		return m.ExpiresAt()
	case discoverybatch.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscoveryBatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discoverybatch.FieldUserID:
		return m.OldUserID(ctx)
	case discoverybatch.FieldServerType:
		return m.OldServerType(ctx)
	case discoverybatch.FieldBatchStatus:
		return m.OldBatchStatus(ctx)
	case discoverybatch.FieldFilterSnapshot:
		return m.OldFilterSnapshot(ctx)
	case discoverybatch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case discoverybatch.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case discoverybatch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DiscoveryBatch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryBatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discoverybatch.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case discoverybatch.FieldServerType:
		v, ok := value.(discoverybatch.ServerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerType(v)
		return nil
	case discoverybatch.FieldBatchStatus:
		v, ok := value.(discoverybatch.BatchStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatchStatus(v)
		return nil
	case discoverybatch.FieldFilterSnapshot:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterSnapshot(v)
		return nil
	case discoverybatch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case discoverybatch.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case discoverybatch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DiscoveryBatch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscoveryBatchMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscoveryBatchMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryBatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscoveryBatch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscoveryBatchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(discoverybatch.FieldFilterSnapshot) {
		fields = append(fields, discoverybatch.FieldFilterSnapshot)
	}
	if m.FieldCleared(discoverybatch.FieldExpiresAt) {
		fields = append(fields, discoverybatch.FieldExpiresAt)
	}
	if m.FieldCleared(discoverybatch.FieldDeletedAt) {
		fields = append(fields, discoverybatch.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscoveryBatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscoveryBatchMutation) ClearField(name string) error {
	switch name {
	case discoverybatch.FieldFilterSnapshot:
		m.ClearFilterSnapshot()
		return nil
	case discoverybatch.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case discoverybatch.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryBatch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscoveryBatchMutation) ResetField(name string) error {
	switch name {
	case discoverybatch.FieldUserID:
		m.ResetUserID()
		return nil
	case discoverybatch.FieldServerType:
		m.ResetServerType()
		return nil
	case discoverybatch.FieldBatchStatus:
		m.ResetBatchStatus()
		return nil
	case discoverybatch.FieldFilterSnapshot:
		m.ResetFilterSnapshot()
		return nil
	case discoverybatch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case discoverybatch.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case discoverybatch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryBatch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscoveryBatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, discoverybatch.EdgeUser)
	}
	if m.cards != nil {
		edges = append(edges, discoverybatch.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscoveryBatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discoverybatch.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case discoverybatch.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscoveryBatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcards != nil {
		edges = append(edges, discoverybatch.EdgeCards)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscoveryBatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case discoverybatch.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscoveryBatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, discoverybatch.EdgeUser)
	}
	if m.clearedcards {
		edges = append(edges, discoverybatch.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscoveryBatchMutation) EdgeCleared(name string) bool {
	switch name {
	case discoverybatch.EdgeUser:
		return m.cleareduser
	case discoverybatch.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscoveryBatchMutation) ClearEdge(name string) error {
	switch name {
	case discoverybatch.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryBatch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscoveryBatchMutation) ResetEdge(name string) error {
	switch name {
	case discoverybatch.EdgeUser:
		m.ResetUser()
		return nil
	case discoverybatch.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryBatch edge %s", name)
}

// DiscoveryCardMutation represents an operation that mutates the DiscoveryCard nodes in the graph.
type DiscoveryCardMutation struct {
	config
	op               Op
	typ              string
	id               *string
	display_order    *int
	adddisplay_order *int
	created_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	batch            *string
	clearedbatch     bool
	candidate        *string
	clearedcandidate bool
	interests        map[string]struct{}
	removedinterests map[string]struct{}
	clearedinterests bool
	done             bool
	oldValue         func(context.Context) (*DiscoveryCard, error)
	predicates       []predicate.DiscoveryCard
}

var _ ent.Mutation = (*DiscoveryCardMutation)(nil)

// discoverycardOption allows management of the mutation configuration using functional options.
type discoverycardOption func(*DiscoveryCardMutation)

// newDiscoveryCardMutation creates new mutation for the DiscoveryCard entity.
func newDiscoveryCardMutation(c config, op Op, opts ...discoverycardOption) *DiscoveryCardMutation {
	m := &DiscoveryCardMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscoveryCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscoveryCardID sets the ID field of the mutation.
func withDiscoveryCardID(id string) discoverycardOption {
	return func(m *DiscoveryCardMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscoveryCard
		)
		m.oldValue = func(ctx context.Context) (*DiscoveryCard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscoveryCard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscoveryCard sets the old DiscoveryCard of the mutation.
func withDiscoveryCard(node *DiscoveryCard) discoverycardOption {
	return func(m *DiscoveryCardMutation) {
		m.oldValue = func(context.Context) (*DiscoveryCard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscoveryCardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscoveryCardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DiscoveryCard entities.
func (m *DiscoveryCardMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscoveryCardMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscoveryCardMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscoveryCard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBatchID sets the "batch_id" field.
func (m *DiscoveryCardMutation) SetBatchID(s string) {
	m.batch = &s
}

// BatchID returns the value of the "batch_id" field in the mutation.
func (m *DiscoveryCardMutation) BatchID() (r string, exists bool) {
	v := m.batch
	if v == nil {
		return
	}
	return *v, true
}

// OldBatchID returns the old "batch_id" field's value of the DiscoveryCard entity.
// If the DiscoveryCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryCardMutation) OldBatchID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatchID: %w", err)
	}
	return oldValue.BatchID, nil
}

// ResetBatchID resets all changes to the "batch_id" field.
func (m *DiscoveryCardMutation) ResetBatchID() {
	m.batch = nil
}

// SetCandidateUserID sets the "candidate_user_id" field.
func (m *DiscoveryCardMutation) SetCandidateUserID(s string) {
	m.candidate = &s
}

// CandidateUserID returns the value of the "candidate_user_id" field in the mutation.
func (m *DiscoveryCardMutation) CandidateUserID() (r string, exists bool) {
	v := m.candidate
	if v == nil {
		return
	}
	return *v, true
}

// OldCandidateUserID returns the old "candidate_user_id" field's value of the DiscoveryCard entity.
// If the DiscoveryCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryCardMutation) OldCandidateUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCandidateUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCandidateUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCandidateUserID: %w", err)
	}
	return oldValue.CandidateUserID, nil
}

// ResetCandidateUserID resets all changes to the "candidate_user_id" field.
func (m *DiscoveryCardMutation) ResetCandidateUserID() {
	m.candidate = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *DiscoveryCardMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *DiscoveryCardMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the DiscoveryCard entity.
// If the DiscoveryCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryCardMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *DiscoveryCardMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *DiscoveryCardMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *DiscoveryCardMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DiscoveryCardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiscoveryCardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DiscoveryCard entity.
// If the DiscoveryCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryCardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiscoveryCardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DiscoveryCardMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DiscoveryCardMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DiscoveryCard entity.
// If the DiscoveryCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscoveryCardMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DiscoveryCardMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[discoverycard.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DiscoveryCardMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[discoverycard.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DiscoveryCardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, discoverycard.FieldDeletedAt)
}

// ClearBatch clears the "batch" edge to the DiscoveryBatch entity.
func (m *DiscoveryCardMutation) ClearBatch() {
	m.clearedbatch = true
	m.clearedFields[discoverycard.FieldBatchID] = struct{}{}
}

// BatchCleared reports if the "batch" edge to the DiscoveryBatch entity was cleared.
func (m *DiscoveryCardMutation) BatchCleared() bool {
	return m.clearedbatch
}

// BatchIDs returns the "batch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatchID instead. It exists only for internal usage by the builders.
func (m *DiscoveryCardMutation) BatchIDs() (ids []string) {
	if id := m.batch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBatch resets all changes to the "batch" edge.
func (m *DiscoveryCardMutation) ResetBatch() {
	m.batch = nil
	m.clearedbatch = false
}

// SetCandidateID sets the "candidate" edge to the User entity by id.
func (m *DiscoveryCardMutation) SetCandidateID(id string) {
	m.candidate = &id
}

// ClearCandidate clears the "candidate" edge to the User entity.
func (m *DiscoveryCardMutation) ClearCandidate() {
	m.clearedcandidate = true
	m.clearedFields[discoverycard.FieldCandidateUserID] = struct{}{}
}

// CandidateCleared reports if the "candidate" edge to the User entity was cleared.
func (m *DiscoveryCardMutation) CandidateCleared() bool {
	return m.clearedcandidate
}

// CandidateID returns the "candidate" edge ID in the mutation.
func (m *DiscoveryCardMutation) CandidateID() (id string, exists bool) {
	if m.candidate != nil {
		return *m.candidate, true
	}
	return
}

// CandidateIDs returns the "candidate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateID instead. It exists only for internal usage by the builders.
func (m *DiscoveryCardMutation) CandidateIDs() (ids []string) {
	if id := m.candidate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidate resets all changes to the "candidate" edge.
func (m *DiscoveryCardMutation) ResetCandidate() {
	m.candidate = nil
	m.clearedcandidate = false
}

// AddInterestIDs adds the "interests" edge to the Interest entity by ids.
func (m *DiscoveryCardMutation) AddInterestIDs(ids ...string) {
	if m.interests == nil {
		m.interests = make(map[string]struct{})
	}
	for i := range ids {
		m.interests[ids[i]] = struct{}{}
	}
}

// ClearInterests clears the "interests" edge to the Interest entity.
func (m *DiscoveryCardMutation) ClearInterests() {
	m.clearedinterests = true
}

// InterestsCleared reports if the "interests" edge to the Interest entity was cleared.
func (m *DiscoveryCardMutation) InterestsCleared() bool {
	return m.clearedinterests
}

// RemoveInterestIDs removes the "interests" edge to the Interest entity by IDs.
func (m *DiscoveryCardMutation) RemoveInterestIDs(ids ...string) {
	if m.removedinterests == nil {
		m.removedinterests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.interests, ids[i])
		m.removedinterests[ids[i]] = struct{}{}
	}
}

// RemovedInterests returns the removed IDs of the "interests" edge to the Interest entity.
func (m *DiscoveryCardMutation) RemovedInterestsIDs() (ids []string) {
	for id := range m.removedinterests {
		ids = append(ids, id)
	}
	return
}

// InterestsIDs returns the "interests" edge IDs in the mutation.
func (m *DiscoveryCardMutation) InterestsIDs() (ids []string) {
	for id := range m.interests {
		ids = append(ids, id)
	}
	return
}

// ResetInterests resets all changes to the "interests" edge.
func (m *DiscoveryCardMutation) ResetInterests() {
	m.interests = nil
	m.clearedinterests = false
	m.removedinterests = nil
}

// Where appends a list predicates to the DiscoveryCardMutation builder.
func (m *DiscoveryCardMutation) Where(ps ...predicate.DiscoveryCard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscoveryCardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscoveryCardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscoveryCard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscoveryCardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscoveryCardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscoveryCard).
func (m *DiscoveryCardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscoveryCardMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.batch != nil {
		fields = append(fields, discoverycard.FieldBatchID)
	}
	if m.candidate != nil {
		fields = append(fields, discoverycard.FieldCandidateUserID)
	}
	if m.display_order != nil {
		fields = append(fields, discoverycard.FieldDisplayOrder)
	}
	if m.created_at != nil {
		fields = append(fields, discoverycard.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, discoverycard.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscoveryCardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discoverycard.FieldBatchID:
		return m.BatchID()
	case discoverycard.FieldCandidateUserID:
		return m.CandidateUserID()
	case discoverycard.FieldDisplayOrder:
		return m.DisplayOrder()
	case discoverycard.FieldCreatedAt:
		return m.CreatedAt()
	case discoverycard.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscoveryCardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discoverycard.FieldBatchID:
		return m.OldBatchID(ctx)
	case discoverycard.FieldCandidateUserID:
		return m.OldCandidateUserID(ctx)
	case discoverycard.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case discoverycard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case discoverycard.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DiscoveryCard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryCardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discoverycard.FieldBatchID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatchID(v)
		return nil
	case discoverycard.FieldCandidateUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCandidateUserID(v)
		return nil
	case discoverycard.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case discoverycard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case discoverycard.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DiscoveryCard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscoveryCardMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, discoverycard.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscoveryCardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case discoverycard.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscoveryCardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case discoverycard.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown DiscoveryCard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscoveryCardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(discoverycard.FieldDeletedAt) {
		fields = append(fields, discoverycard.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscoveryCardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscoveryCardMutation) ClearField(name string) error {
	switch name {
	case discoverycard.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryCard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscoveryCardMutation) ResetField(name string) error {
	switch name {
	case discoverycard.FieldBatchID:
		m.ResetBatchID()
		return nil
	case discoverycard.FieldCandidateUserID:
		m.ResetCandidateUserID()
		return nil
	case discoverycard.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case discoverycard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case discoverycard.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryCard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscoveryCardMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.batch != nil {
		edges = append(edges, discoverycard.EdgeBatch)
	}
	if m.candidate != nil {
		edges = append(edges, discoverycard.EdgeCandidate)
	}
	if m.interests != nil {
		edges = append(edges, discoverycard.EdgeInterests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscoveryCardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discoverycard.EdgeBatch:
		if id := m.batch; id != nil {
			return []ent.Value{*id}
		}
	case discoverycard.EdgeCandidate:
		if id := m.candidate; id != nil {
			return []ent.Value{*id}
		}
	case discoverycard.EdgeInterests:
		ids := make([]ent.Value, 0, len(m.interests))
		for id := range m.interests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscoveryCardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinterests != nil {
		edges = append(edges, discoverycard.EdgeInterests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscoveryCardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case discoverycard.EdgeInterests:
		ids := make([]ent.Value, 0, len(m.removedinterests))
		for id := range m.removedinterests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscoveryCardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbatch {
		edges = append(edges, discoverycard.EdgeBatch)
	}
	if m.clearedcandidate {
		edges = append(edges, discoverycard.EdgeCandidate)
	}
	if m.clearedinterests {
		edges = append(edges, discoverycard.EdgeInterests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscoveryCardMutation) EdgeCleared(name string) bool {
	switch name {
	case discoverycard.EdgeBatch:
		return m.clearedbatch
	case discoverycard.EdgeCandidate:
		return m.clearedcandidate
	case discoverycard.EdgeInterests:
		return m.clearedinterests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscoveryCardMutation) ClearEdge(name string) error {
	switch name {
	case discoverycard.EdgeBatch:
		m.ClearBatch()
		return nil
	case discoverycard.EdgeCandidate:
		m.ClearCandidate()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryCard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscoveryCardMutation) ResetEdge(name string) error {
	switch name {
	case discoverycard.EdgeBatch:
		m.ResetBatch()
		return nil
	case discoverycard.EdgeCandidate:
		m.ResetCandidate()
		return nil
	case discoverycard.EdgeInterests:
		m.ResetInterests()
		return nil
	}
	return fmt.Errorf("unknown DiscoveryCard edge %s", name)
}

// FilterMutation represents an operation that mutates the Filter nodes in the graph.
type FilterMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	server_type          *filter.ServerType
	min_age              *int
	addmin_age           *int
	max_age              *int
	addmax_age           *int
	gender_preference    *filter.GenderPreference
	relationship_intent  *filter.RelationshipIntent
	family_planning      *filter.FamilyPlanning
	living_situation     *filter.LivingSituation
	dietary_preference   *filter.DietaryPreference
	friendship_style     *filter.FriendshipStyle
	social_energy        *filter.SocialEnergy
	hangout_preference   *filter.HangoutPreference
	conversation_depth   *filter.ConversationDepth
	goal_category        *filter.GoalCategory
	accountability_style *filter.AccountabilityStyle
	check_in_frequency   *filter.CheckInFrequency
	commitment_level     *filter.CommitmentLevel
	filter_config        *map[string]interface{}
	is_pending           *bool
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Filter, error)
	predicates           []predicate.Filter
}

var _ ent.Mutation = (*FilterMutation)(nil)

// filterOption allows management of the mutation configuration using functional options.
type filterOption func(*FilterMutation)

// newFilterMutation creates new mutation for the Filter entity.
func newFilterMutation(c config, op Op, opts ...filterOption) *FilterMutation {
	m := &FilterMutation{
		config:        c,
		op:            op,
		typ:           TypeFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilterID sets the ID field of the mutation.
func withFilterID(id string) filterOption {
	return func(m *FilterMutation) {
		var (
			err   error
			once  sync.Once
			value *Filter
		)
		m.oldValue = func(ctx context.Context) (*Filter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Filter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilter sets the old Filter of the mutation.
func withFilter(node *Filter) filterOption {
	return func(m *FilterMutation) {
		m.oldValue = func(context.Context) (*Filter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Filter entities.
func (m *FilterMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilterMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilterMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Filter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *FilterMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FilterMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FilterMutation) ResetUserID() {
	m.user = nil
}

// SetServerType sets the "server_type" field.
func (m *FilterMutation) SetServerType(ft filter.ServerType) {
	m.server_type = &ft
}

// ServerType returns the value of the "server_type" field in the mutation.
func (m *FilterMutation) ServerType() (r filter.ServerType, exists bool) {
	v := m.server_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerType returns the old "server_type" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldServerType(ctx context.Context) (v filter.ServerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerType: %w", err)
	}
	return oldValue.ServerType, nil
}

// ResetServerType resets all changes to the "server_type" field.
func (m *FilterMutation) ResetServerType() {
	m.server_type = nil
}

// SetMinAge sets the "min_age" field.
func (m *FilterMutation) SetMinAge(i int) {
	m.min_age = &i
	m.addmin_age = nil
}

// MinAge returns the value of the "min_age" field in the mutation.
func (m *FilterMutation) MinAge() (r int, exists bool) {
	v := m.min_age
	if v == nil {
		return
	}
	return *v, true
}

// OldMinAge returns the old "min_age" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldMinAge(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinAge: %w", err)
	}
	return oldValue.MinAge, nil
}

// AddMinAge adds i to the "min_age" field.
func (m *FilterMutation) AddMinAge(i int) {
	if m.addmin_age != nil {
		*m.addmin_age += i
	} else {
		m.addmin_age = &i
	}
}

// AddedMinAge returns the value that was added to the "min_age" field in this mutation.
func (m *FilterMutation) AddedMinAge() (r int, exists bool) {
	v := m.addmin_age
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinAge clears the value of the "min_age" field.
func (m *FilterMutation) ClearMinAge() {
	m.min_age = nil
	m.addmin_age = nil
	m.clearedFields[filter.FieldMinAge] = struct{}{}
}

// MinAgeCleared returns if the "min_age" field was cleared in this mutation.
func (m *FilterMutation) MinAgeCleared() bool {
	_, ok := m.clearedFields[filter.FieldMinAge]
	return ok
}

// ResetMinAge resets all changes to the "min_age" field.
func (m *FilterMutation) ResetMinAge() {
	m.min_age = nil
	m.addmin_age = nil
	delete(m.clearedFields, filter.FieldMinAge)
}

// SetMaxAge sets the "max_age" field.
func (m *FilterMutation) SetMaxAge(i int) {
	m.max_age = &i
	m.addmax_age = nil
}

// MaxAge returns the value of the "max_age" field in the mutation.
func (m *FilterMutation) MaxAge() (r int, exists bool) {
	v := m.max_age
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAge returns the old "max_age" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldMaxAge(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAge: %w", err)
	}
	return oldValue.MaxAge, nil
}

// AddMaxAge adds i to the "max_age" field.
func (m *FilterMutation) AddMaxAge(i int) {
	if m.addmax_age != nil {
		*m.addmax_age += i
	} else {
		m.addmax_age = &i
	}
}

// AddedMaxAge returns the value that was added to the "max_age" field in this mutation.
func (m *FilterMutation) AddedMaxAge() (r int, exists bool) {
	v := m.addmax_age
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxAge clears the value of the "max_age" field.
func (m *FilterMutation) ClearMaxAge() {
	m.max_age = nil
	m.addmax_age = nil
	m.clearedFields[filter.FieldMaxAge] = struct{}{}
}

// MaxAgeCleared returns if the "max_age" field was cleared in this mutation.
func (m *FilterMutation) MaxAgeCleared() bool {
	_, ok := m.clearedFields[filter.FieldMaxAge]
	return ok
}

// ResetMaxAge resets all changes to the "max_age" field.
func (m *FilterMutation) ResetMaxAge() {
	m.max_age = nil
	m.addmax_age = nil
	delete(m.clearedFields, filter.FieldMaxAge)
}

// SetGenderPreference sets the "gender_preference" field.
func (m *FilterMutation) SetGenderPreference(fp filter.GenderPreference) {
	m.gender_preference = &fp
}

// GenderPreference returns the value of the "gender_preference" field in the mutation.
func (m *FilterMutation) GenderPreference() (r filter.GenderPreference, exists bool) {
	v := m.gender_preference
	if v == nil {
		return
	}
	return *v, true
}

// OldGenderPreference returns the old "gender_preference" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldGenderPreference(ctx context.Context) (v *filter.GenderPreference, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenderPreference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenderPreference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenderPreference: %w", err)
	}
	return oldValue.GenderPreference, nil
}

// ClearGenderPreference clears the value of the "gender_preference" field.
func (m *FilterMutation) ClearGenderPreference() {
	m.gender_preference = nil
	m.clearedFields[filter.FieldGenderPreference] = struct{}{}
}

// GenderPreferenceCleared returns if the "gender_preference" field was cleared in this mutation.
func (m *FilterMutation) GenderPreferenceCleared() bool {
	_, ok := m.clearedFields[filter.FieldGenderPreference]
	return ok
}

// ResetGenderPreference resets all changes to the "gender_preference" field.
func (m *FilterMutation) ResetGenderPreference() {
	m.gender_preference = nil
	delete(m.clearedFields, filter.FieldGenderPreference)
}

// SetRelationshipIntent sets the "relationship_intent" field.
func (m *FilterMutation) SetRelationshipIntent(fi filter.RelationshipIntent) {
	m.relationship_intent = &fi
}

// RelationshipIntent returns the value of the "relationship_intent" field in the mutation.
func (m *FilterMutation) RelationshipIntent() (r filter.RelationshipIntent, exists bool) {
	v := m.relationship_intent
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationshipIntent returns the old "relationship_intent" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldRelationshipIntent(ctx context.Context) (v *filter.RelationshipIntent, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationshipIntent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationshipIntent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationshipIntent: %w", err)
	}
	return oldValue.RelationshipIntent, nil
}

// ClearRelationshipIntent clears the value of the "relationship_intent" field.
func (m *FilterMutation) ClearRelationshipIntent() {
	m.relationship_intent = nil
	m.clearedFields[filter.FieldRelationshipIntent] = struct{}{}
}

// RelationshipIntentCleared returns if the "relationship_intent" field was cleared in this mutation.
func (m *FilterMutation) RelationshipIntentCleared() bool {
	_, ok := m.clearedFields[filter.FieldRelationshipIntent]
	return ok
}

// ResetRelationshipIntent resets all changes to the "relationship_intent" field.
func (m *FilterMutation) ResetRelationshipIntent() {
	m.relationship_intent = nil
	delete(m.clearedFields, filter.FieldRelationshipIntent)
}

// SetFamilyPlanning sets the "family_planning" field.
func (m *FilterMutation) SetFamilyPlanning(fp filter.FamilyPlanning) {
	m.family_planning = &fp
}

// FamilyPlanning returns the value of the "family_planning" field in the mutation.
func (m *FilterMutation) FamilyPlanning() (r filter.FamilyPlanning, exists bool) {
	v := m.family_planning
	if v == nil {
		return
	}
	return *v, true
}

// OldFamilyPlanning returns the old "family_planning" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldFamilyPlanning(ctx context.Context) (v *filter.FamilyPlanning, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFamilyPlanning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFamilyPlanning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFamilyPlanning: %w", err)
	}
	return oldValue.FamilyPlanning, nil
}

// ClearFamilyPlanning clears the value of the "family_planning" field.
func (m *FilterMutation) ClearFamilyPlanning() {
	m.family_planning = nil
	m.clearedFields[filter.FieldFamilyPlanning] = struct{}{}
}

// FamilyPlanningCleared returns if the "family_planning" field was cleared in this mutation.
func (m *FilterMutation) FamilyPlanningCleared() bool {
	_, ok := m.clearedFields[filter.FieldFamilyPlanning]
	return ok
}

// ResetFamilyPlanning resets all changes to the "family_planning" field.
func (m *FilterMutation) ResetFamilyPlanning() {
	m.family_planning = nil
	delete(m.clearedFields, filter.FieldFamilyPlanning)
}

// SetLivingSituation sets the "living_situation" field.
func (m *FilterMutation) SetLivingSituation(fs filter.LivingSituation) {
	m.living_situation = &fs
}

// LivingSituation returns the value of the "living_situation" field in the mutation.
func (m *FilterMutation) LivingSituation() (r filter.LivingSituation, exists bool) {
	v := m.living_situation
	if v == nil {
		return
	}
	return *v, true
}

// OldLivingSituation returns the old "living_situation" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldLivingSituation(ctx context.Context) (v *filter.LivingSituation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLivingSituation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLivingSituation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLivingSituation: %w", err)
	}
	return oldValue.LivingSituation, nil
}

// ClearLivingSituation clears the value of the "living_situation" field.
func (m *FilterMutation) ClearLivingSituation() {
	m.living_situation = nil
	m.clearedFields[filter.FieldLivingSituation] = struct{}{}
}

// LivingSituationCleared returns if the "living_situation" field was cleared in this mutation.
func (m *FilterMutation) LivingSituationCleared() bool {
	_, ok := m.clearedFields[filter.FieldLivingSituation]
	return ok
}

// ResetLivingSituation resets all changes to the "living_situation" field.
func (m *FilterMutation) ResetLivingSituation() {
	m.living_situation = nil
	delete(m.clearedFields, filter.FieldLivingSituation)
}

// SetDietaryPreference sets the "dietary_preference" field.
func (m *FilterMutation) SetDietaryPreference(fp filter.DietaryPreference) {
	m.dietary_preference = &fp
}

// DietaryPreference returns the value of the "dietary_preference" field in the mutation.
func (m *FilterMutation) DietaryPreference() (r filter.DietaryPreference, exists bool) {
	v := m.dietary_preference
	if v == nil {
		return
	}
	return *v, true
}

// OldDietaryPreference returns the old "dietary_preference" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldDietaryPreference(ctx context.Context) (v *filter.DietaryPreference, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDietaryPreference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDietaryPreference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDietaryPreference: %w", err)
	}
	return oldValue.DietaryPreference, nil
}

// ClearDietaryPreference clears the value of the "dietary_preference" field.
func (m *FilterMutation) ClearDietaryPreference() {
	m.dietary_preference = nil
	m.clearedFields[filter.FieldDietaryPreference] = struct{}{}
}

// DietaryPreferenceCleared returns if the "dietary_preference" field was cleared in this mutation.
func (m *FilterMutation) DietaryPreferenceCleared() bool {
	_, ok := m.clearedFields[filter.FieldDietaryPreference]
	return ok
}

// ResetDietaryPreference resets all changes to the "dietary_preference" field.
func (m *FilterMutation) ResetDietaryPreference() {
	m.dietary_preference = nil
	delete(m.clearedFields, filter.FieldDietaryPreference)
}

// SetFriendshipStyle sets the "friendship_style" field.
func (m *FilterMutation) SetFriendshipStyle(fs filter.FriendshipStyle) {
	m.friendship_style = &fs
}

// FriendshipStyle returns the value of the "friendship_style" field in the mutation.
func (m *FilterMutation) FriendshipStyle() (r filter.FriendshipStyle, exists bool) {
	v := m.friendship_style
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendshipStyle returns the old "friendship_style" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldFriendshipStyle(ctx context.Context) (v *filter.FriendshipStyle, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendshipStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendshipStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendshipStyle: %w", err)
	}
	return oldValue.FriendshipStyle, nil
}

// ClearFriendshipStyle clears the value of the "friendship_style" field.
func (m *FilterMutation) ClearFriendshipStyle() {
	m.friendship_style = nil
	m.clearedFields[filter.FieldFriendshipStyle] = struct{}{}
}

// FriendshipStyleCleared returns if the "friendship_style" field was cleared in this mutation.
func (m *FilterMutation) FriendshipStyleCleared() bool {
	_, ok := m.clearedFields[filter.FieldFriendshipStyle]
	return ok
}

// ResetFriendshipStyle resets all changes to the "friendship_style" field.
func (m *FilterMutation) ResetFriendshipStyle() {
	m.friendship_style = nil
	delete(m.clearedFields, filter.FieldFriendshipStyle)
}

// SetSocialEnergy sets the "social_energy" field.
func (m *FilterMutation) SetSocialEnergy(fe filter.SocialEnergy) {
	m.social_energy = &fe
}

// SocialEnergy returns the value of the "social_energy" field in the mutation.
func (m *FilterMutation) SocialEnergy() (r filter.SocialEnergy, exists bool) {
	v := m.social_energy
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialEnergy returns the old "social_energy" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldSocialEnergy(ctx context.Context) (v *filter.SocialEnergy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialEnergy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialEnergy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialEnergy: %w", err)
	}
	return oldValue.SocialEnergy, nil
}

// ClearSocialEnergy clears the value of the "social_energy" field.
func (m *FilterMutation) ClearSocialEnergy() {
	m.social_energy = nil
	m.clearedFields[filter.FieldSocialEnergy] = struct{}{}
}

// SocialEnergyCleared returns if the "social_energy" field was cleared in this mutation.
func (m *FilterMutation) SocialEnergyCleared() bool {
	_, ok := m.clearedFields[filter.FieldSocialEnergy]
	return ok
}

// ResetSocialEnergy resets all changes to the "social_energy" field.
func (m *FilterMutation) ResetSocialEnergy() {
	m.social_energy = nil
	delete(m.clearedFields, filter.FieldSocialEnergy)
}

// SetHangoutPreference sets the "hangout_preference" field.
func (m *FilterMutation) SetHangoutPreference(fp filter.HangoutPreference) {
	m.hangout_preference = &fp
}

// HangoutPreference returns the value of the "hangout_preference" field in the mutation.
func (m *FilterMutation) HangoutPreference() (r filter.HangoutPreference, exists bool) {
	v := m.hangout_preference
	if v == nil {
		return
	}
	return *v, true
}

// OldHangoutPreference returns the old "hangout_preference" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldHangoutPreference(ctx context.Context) (v *filter.HangoutPreference, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHangoutPreference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHangoutPreference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHangoutPreference: %w", err)
	}
	return oldValue.HangoutPreference, nil
}

// ClearHangoutPreference clears the value of the "hangout_preference" field.
func (m *FilterMutation) ClearHangoutPreference() {
	m.hangout_preference = nil
	m.clearedFields[filter.FieldHangoutPreference] = struct{}{}
}

// HangoutPreferenceCleared returns if the "hangout_preference" field was cleared in this mutation.
func (m *FilterMutation) HangoutPreferenceCleared() bool {
	_, ok := m.clearedFields[filter.FieldHangoutPreference]
	return ok
}

// ResetHangoutPreference resets all changes to the "hangout_preference" field.
func (m *FilterMutation) ResetHangoutPreference() {
	m.hangout_preference = nil
	delete(m.clearedFields, filter.FieldHangoutPreference)
}

// SetConversationDepth sets the "conversation_depth" field.
func (m *FilterMutation) SetConversationDepth(fd filter.ConversationDepth) {
	m.conversation_depth = &fd
}

// ConversationDepth returns the value of the "conversation_depth" field in the mutation.
func (m *FilterMutation) ConversationDepth() (r filter.ConversationDepth, exists bool) {
	v := m.conversation_depth
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationDepth returns the old "conversation_depth" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldConversationDepth(ctx context.Context) (v *filter.ConversationDepth, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationDepth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationDepth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationDepth: %w", err)
	}
	return oldValue.ConversationDepth, nil
}

// ClearConversationDepth clears the value of the "conversation_depth" field.
func (m *FilterMutation) ClearConversationDepth() {
	m.conversation_depth = nil
	m.clearedFields[filter.FieldConversationDepth] = struct{}{}
}

// ConversationDepthCleared returns if the "conversation_depth" field was cleared in this mutation.
func (m *FilterMutation) ConversationDepthCleared() bool {
	_, ok := m.clearedFields[filter.FieldConversationDepth]
	return ok
}

// ResetConversationDepth resets all changes to the "conversation_depth" field.
func (m *FilterMutation) ResetConversationDepth() {
	m.conversation_depth = nil
	delete(m.clearedFields, filter.FieldConversationDepth)
}

// SetGoalCategory sets the "goal_category" field.
func (m *FilterMutation) SetGoalCategory(fc filter.GoalCategory) {
	m.goal_category = &fc
}

// GoalCategory returns the value of the "goal_category" field in the mutation.
func (m *FilterMutation) GoalCategory() (r filter.GoalCategory, exists bool) {
	v := m.goal_category
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalCategory returns the old "goal_category" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldGoalCategory(ctx context.Context) (v *filter.GoalCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalCategory: %w", err)
	}
	return oldValue.GoalCategory, nil
}

// ClearGoalCategory clears the value of the "goal_category" field.
func (m *FilterMutation) ClearGoalCategory() {
	m.goal_category = nil
	m.clearedFields[filter.FieldGoalCategory] = struct{}{}
}

// GoalCategoryCleared returns if the "goal_category" field was cleared in this mutation.
func (m *FilterMutation) GoalCategoryCleared() bool {
	_, ok := m.clearedFields[filter.FieldGoalCategory]
	return ok
}

// ResetGoalCategory resets all changes to the "goal_category" field.
func (m *FilterMutation) ResetGoalCategory() {
	m.goal_category = nil
	delete(m.clearedFields, filter.FieldGoalCategory)
}

// SetAccountabilityStyle sets the "accountability_style" field.
func (m *FilterMutation) SetAccountabilityStyle(fs filter.AccountabilityStyle) {
	m.accountability_style = &fs
}

// AccountabilityStyle returns the value of the "accountability_style" field in the mutation.
func (m *FilterMutation) AccountabilityStyle() (r filter.AccountabilityStyle, exists bool) {
	v := m.accountability_style
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountabilityStyle returns the old "accountability_style" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldAccountabilityStyle(ctx context.Context) (v *filter.AccountabilityStyle, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountabilityStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountabilityStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountabilityStyle: %w", err)
	}
	return oldValue.AccountabilityStyle, nil
}

// ClearAccountabilityStyle clears the value of the "accountability_style" field.
func (m *FilterMutation) ClearAccountabilityStyle() {
	m.accountability_style = nil
	m.clearedFields[filter.FieldAccountabilityStyle] = struct{}{}
}

// AccountabilityStyleCleared returns if the "accountability_style" field was cleared in this mutation.
func (m *FilterMutation) AccountabilityStyleCleared() bool {
	_, ok := m.clearedFields[filter.FieldAccountabilityStyle]
	return ok
}

// ResetAccountabilityStyle resets all changes to the "accountability_style" field.
func (m *FilterMutation) ResetAccountabilityStyle() {
	m.accountability_style = nil
	delete(m.clearedFields, filter.FieldAccountabilityStyle)
}

// SetCheckInFrequency sets the "check_in_frequency" field.
func (m *FilterMutation) SetCheckInFrequency(fif filter.CheckInFrequency) {
	m.check_in_frequency = &fif
}

// CheckInFrequency returns the value of the "check_in_frequency" field in the mutation.
func (m *FilterMutation) CheckInFrequency() (r filter.CheckInFrequency, exists bool) {
	v := m.check_in_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckInFrequency returns the old "check_in_frequency" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldCheckInFrequency(ctx context.Context) (v *filter.CheckInFrequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckInFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckInFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckInFrequency: %w", err)
	}
	return oldValue.CheckInFrequency, nil
}

// ClearCheckInFrequency clears the value of the "check_in_frequency" field.
func (m *FilterMutation) ClearCheckInFrequency() {
	m.check_in_frequency = nil
	m.clearedFields[filter.FieldCheckInFrequency] = struct{}{}
}

// CheckInFrequencyCleared returns if the "check_in_frequency" field was cleared in this mutation.
func (m *FilterMutation) CheckInFrequencyCleared() bool {
	_, ok := m.clearedFields[filter.FieldCheckInFrequency]
	return ok
}

// ResetCheckInFrequency resets all changes to the "check_in_frequency" field.
func (m *FilterMutation) ResetCheckInFrequency() {
	m.check_in_frequency = nil
	delete(m.clearedFields, filter.FieldCheckInFrequency)
}

// SetCommitmentLevel sets the "commitment_level" field.
func (m *FilterMutation) SetCommitmentLevel(fl filter.CommitmentLevel) {
	m.commitment_level = &fl
}

// CommitmentLevel returns the value of the "commitment_level" field in the mutation.
func (m *FilterMutation) CommitmentLevel() (r filter.CommitmentLevel, exists bool) {
	v := m.commitment_level
	if v == nil {
		return
	}
	return *v, true
}

// OldCommitmentLevel returns the old "commitment_level" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldCommitmentLevel(ctx context.Context) (v *filter.CommitmentLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommitmentLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommitmentLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommitmentLevel: %w", err)
	}
	return oldValue.CommitmentLevel, nil
}

// ClearCommitmentLevel clears the value of the "commitment_level" field.
func (m *FilterMutation) ClearCommitmentLevel() {
	m.commitment_level = nil
	m.clearedFields[filter.FieldCommitmentLevel] = struct{}{}
}

// CommitmentLevelCleared returns if the "commitment_level" field was cleared in this mutation.
func (m *FilterMutation) CommitmentLevelCleared() bool {
	_, ok := m.clearedFields[filter.FieldCommitmentLevel]
	return ok
}

// ResetCommitmentLevel resets all changes to the "commitment_level" field.
func (m *FilterMutation) ResetCommitmentLevel() {
	m.commitment_level = nil
	delete(m.clearedFields, filter.FieldCommitmentLevel)
}

// SetFilterConfig sets the "filter_config" field.
func (m *FilterMutation) SetFilterConfig(value map[string]interface{}) {
	m.filter_config = &value
}

// FilterConfig returns the value of the "filter_config" field in the mutation.
func (m *FilterMutation) FilterConfig() (r map[string]interface{}, exists bool) {
	v := m.filter_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterConfig returns the old "filter_config" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldFilterConfig(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterConfig: %w", err)
	}
	return oldValue.FilterConfig, nil
}

// ClearFilterConfig clears the value of the "filter_config" field.
func (m *FilterMutation) ClearFilterConfig() {
	m.filter_config = nil
	m.clearedFields[filter.FieldFilterConfig] = struct{}{}
}

// FilterConfigCleared returns if the "filter_config" field was cleared in this mutation.
func (m *FilterMutation) FilterConfigCleared() bool {
	_, ok := m.clearedFields[filter.FieldFilterConfig]
	return ok
}

// ResetFilterConfig resets all changes to the "filter_config" field.
func (m *FilterMutation) ResetFilterConfig() {
	m.filter_config = nil
	delete(m.clearedFields, filter.FieldFilterConfig)
}

// SetIsPending sets the "is_pending" field.
func (m *FilterMutation) SetIsPending(b bool) {
	m.is_pending = &b
}

// IsPending returns the value of the "is_pending" field in the mutation.
func (m *FilterMutation) IsPending() (r bool, exists bool) {
	v := m.is_pending
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPending returns the old "is_pending" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldIsPending(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPending is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPending requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPending: %w", err)
	}
	return oldValue.IsPending, nil
}

// ResetIsPending resets all changes to the "is_pending" field.
func (m *FilterMutation) ResetIsPending() {
	m.is_pending = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FilterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FilterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FilterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FilterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FilterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Filter entity.
// If the Filter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FilterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FilterMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[filter.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FilterMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FilterMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FilterMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the FilterMutation builder.
func (m *FilterMutation) Where(ps ...predicate.Filter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Filter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Filter).
func (m *FilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilterMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.user != nil {
		fields = append(fields, filter.FieldUserID)
	}
	if m.server_type != nil {
		fields = append(fields, filter.FieldServerType)
	}
	if m.min_age != nil {
		fields = append(fields, filter.FieldMinAge)
	}
	if m.max_age != nil {
		fields = append(fields, filter.FieldMaxAge)
	}
	if m.gender_preference != nil {
		fields = append(fields, filter.FieldGenderPreference)
	}
	if m.relationship_intent != nil {
		fields = append(fields, filter.FieldRelationshipIntent)
	}
	if m.family_planning != nil {
		fields = append(fields, filter.FieldFamilyPlanning)
	}
	if m.living_situation != nil {
		fields = append(fields, filter.FieldLivingSituation)
	}
	if m.dietary_preference != nil {
		fields = append(fields, filter.FieldDietaryPreference)
	}
	if m.friendship_style != nil {
		fields = append(fields, filter.FieldFriendshipStyle)
	}
	if m.social_energy != nil {
		fields = append(fields, filter.FieldSocialEnergy)
	}
	if m.hangout_preference != nil {
		fields = append(fields, filter.FieldHangoutPreference)
	}
	if m.conversation_depth != nil {
		fields = append(fields, filter.FieldConversationDepth)
	}
	if m.goal_category != nil {
		fields = append(fields, filter.FieldGoalCategory)
	}
	if m.accountability_style != nil {
		fields = append(fields, filter.FieldAccountabilityStyle)
	}
	if m.check_in_frequency != nil {
		fields = append(fields, filter.FieldCheckInFrequency)
	}
	if m.commitment_level != nil {
		fields = append(fields, filter.FieldCommitmentLevel)
	}
	if m.filter_config != nil {
		fields = append(fields, filter.FieldFilterConfig)
	}
	if m.is_pending != nil {
		fields = append(fields, filter.FieldIsPending)
	}
	if m.created_at != nil {
		fields = append(fields, filter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, filter.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filter.FieldUserID:
		return m.UserID()
	case filter.FieldServerType:
		return m.ServerType()
	case filter.FieldMinAge:
		return m.MinAge()
	case filter.FieldMaxAge:
		return m.MaxAge()
	case filter.FieldGenderPreference:
		return m.GenderPreference()
	case filter.FieldRelationshipIntent:
		return m.RelationshipIntent()
	case filter.FieldFamilyPlanning:
		return m.FamilyPlanning()
	case filter.FieldLivingSituation:
		return m.LivingSituation()
	case filter.FieldDietaryPreference:
		return m.DietaryPreference()
	case filter.FieldFriendshipStyle:
		return m.FriendshipStyle()
	case filter.FieldSocialEnergy:
		return m.SocialEnergy()
	case filter.FieldHangoutPreference:
		return m.HangoutPreference()
	case filter.FieldConversationDepth:
		return m.ConversationDepth()
	case filter.FieldGoalCategory:
		return m.GoalCategory()
	case filter.FieldAccountabilityStyle:
		return m.AccountabilityStyle()
	case filter.FieldCheckInFrequency:
		return m.CheckInFrequency()
	case filter.FieldCommitmentLevel:
		return m.CommitmentLevel()
	case filter.FieldFilterConfig:
		return m.FilterConfig()
	case filter.FieldIsPending:
		return m.IsPending()
	case filter.FieldCreatedAt:
		return m.CreatedAt()
	case filter.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filter.FieldUserID:
		return m.OldUserID(ctx)
	case filter.FieldServerType:
		return m.OldServerType(ctx)
	case filter.FieldMinAge:
		return m.OldMinAge(ctx)
	case filter.FieldMaxAge:
		return m.OldMaxAge(ctx)
	case filter.FieldGenderPreference:
		return m.OldGenderPreference(ctx)
	case filter.FieldRelationshipIntent:
		return m.OldRelationshipIntent(ctx)
	case filter.FieldFamilyPlanning:
		return m.OldFamilyPlanning(ctx)
	case filter.FieldLivingSituation:
		return m.OldLivingSituation(ctx)
	case filter.FieldDietaryPreference:
		return m.OldDietaryPreference(ctx)
	case filter.FieldFriendshipStyle:
		return m.OldFriendshipStyle(ctx)
	case filter.FieldSocialEnergy:
		return m.OldSocialEnergy(ctx)
	case filter.FieldHangoutPreference:
		return m.OldHangoutPreference(ctx)
	case filter.FieldConversationDepth:
		return m.OldConversationDepth(ctx)
	case filter.FieldGoalCategory:
		return m.OldGoalCategory(ctx)
	case filter.FieldAccountabilityStyle:
		return m.OldAccountabilityStyle(ctx)
	case filter.FieldCheckInFrequency:
		return m.OldCheckInFrequency(ctx)
	case filter.FieldCommitmentLevel:
		return m.OldCommitmentLevel(ctx)
	case filter.FieldFilterConfig:
		return m.OldFilterConfig(ctx)
	case filter.FieldIsPending:
		return m.OldIsPending(ctx)
	case filter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Filter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filter.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case filter.FieldServerType:
		v, ok := value.(filter.ServerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerType(v)
		return nil
	case filter.FieldMinAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinAge(v)
		return nil
	case filter.FieldMaxAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAge(v)
		return nil
	case filter.FieldGenderPreference:
		v, ok := value.(filter.GenderPreference)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenderPreference(v)
		return nil
	case filter.FieldRelationshipIntent:
		v, ok := value.(filter.RelationshipIntent)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationshipIntent(v)
		return nil
	case filter.FieldFamilyPlanning:
		v, ok := value.(filter.FamilyPlanning)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFamilyPlanning(v)
		return nil
	case filter.FieldLivingSituation:
		v, ok := value.(filter.LivingSituation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLivingSituation(v)
		return nil
	case filter.FieldDietaryPreference:
		v, ok := value.(filter.DietaryPreference)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDietaryPreference(v)
		return nil
	case filter.FieldFriendshipStyle:
		v, ok := value.(filter.FriendshipStyle)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendshipStyle(v)
		return nil
	case filter.FieldSocialEnergy:
		v, ok := value.(filter.SocialEnergy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialEnergy(v)
		return nil
	case filter.FieldHangoutPreference:
		v, ok := value.(filter.HangoutPreference)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHangoutPreference(v)
		return nil
	case filter.FieldConversationDepth:
		v, ok := value.(filter.ConversationDepth)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationDepth(v)
		return nil
	case filter.FieldGoalCategory:
		v, ok := value.(filter.GoalCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalCategory(v)
		return nil
	case filter.FieldAccountabilityStyle:
		v, ok := value.(filter.AccountabilityStyle)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountabilityStyle(v)
		return nil
	case filter.FieldCheckInFrequency:
		v, ok := value.(filter.CheckInFrequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckInFrequency(v)
		return nil
	case filter.FieldCommitmentLevel:
		v, ok := value.(filter.CommitmentLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommitmentLevel(v)
		return nil
	case filter.FieldFilterConfig:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterConfig(v)
		return nil
	case filter.FieldIsPending:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPending(v)
		return nil
	case filter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Filter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilterMutation) AddedFields() []string {
	var fields []string
	if m.addmin_age != nil {
		fields = append(fields, filter.FieldMinAge)
	}
	if m.addmax_age != nil {
		fields = append(fields, filter.FieldMaxAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filter.FieldMinAge:
		return m.AddedMinAge()
	case filter.FieldMaxAge:
		return m.AddedMaxAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filter.FieldMinAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinAge(v)
		return nil
	case filter.FieldMaxAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAge(v)
		return nil
	}
	return fmt.Errorf("unknown Filter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filter.FieldMinAge) {
		fields = append(fields, filter.FieldMinAge)
	}
	if m.FieldCleared(filter.FieldMaxAge) {
		fields = append(fields, filter.FieldMaxAge)
	}
	if m.FieldCleared(filter.FieldGenderPreference) {
		fields = append(fields, filter.FieldGenderPreference)
	}
	if m.FieldCleared(filter.FieldRelationshipIntent) {
		fields = append(fields, filter.FieldRelationshipIntent)
	}
	if m.FieldCleared(filter.FieldFamilyPlanning) {
		fields = append(fields, filter.FieldFamilyPlanning)
	}
	if m.FieldCleared(filter.FieldLivingSituation) {
		fields = append(fields, filter.FieldLivingSituation)
	}
	if m.FieldCleared(filter.FieldDietaryPreference) {
		fields = append(fields, filter.FieldDietaryPreference)
	}
	if m.FieldCleared(filter.FieldFriendshipStyle) {
		fields = append(fields, filter.FieldFriendshipStyle)
	}
	if m.FieldCleared(filter.FieldSocialEnergy) {
		fields = append(fields, filter.FieldSocialEnergy)
	}
	if m.FieldCleared(filter.FieldHangoutPreference) {
		fields = append(fields, filter.FieldHangoutPreference)
	}
	if m.FieldCleared(filter.FieldConversationDepth) {
		fields = append(fields, filter.FieldConversationDepth)
	}
	if m.FieldCleared(filter.FieldGoalCategory) {
		fields = append(fields, filter.FieldGoalCategory)
	}
	if m.FieldCleared(filter.FieldAccountabilityStyle) {
		fields = append(fields, filter.FieldAccountabilityStyle)
	}
	if m.FieldCleared(filter.FieldCheckInFrequency) {
		fields = append(fields, filter.FieldCheckInFrequency)
	}
	if m.FieldCleared(filter.FieldCommitmentLevel) {
		fields = append(fields, filter.FieldCommitmentLevel)
	}
	if m.FieldCleared(filter.FieldFilterConfig) {
		fields = append(fields, filter.FieldFilterConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilterMutation) ClearField(name string) error {
	switch name {
	case filter.FieldMinAge:
		m.ClearMinAge()
		return nil
	case filter.FieldMaxAge:
		m.ClearMaxAge()
		return nil
	case filter.FieldGenderPreference:
		m.ClearGenderPreference()
		return nil
	case filter.FieldRelationshipIntent:
		m.ClearRelationshipIntent()
		return nil
	case filter.FieldFamilyPlanning:
		m.ClearFamilyPlanning()
		return nil
	case filter.FieldLivingSituation:
		m.ClearLivingSituation()
		return nil
	case filter.FieldDietaryPreference:
		m.ClearDietaryPreference()
		return nil
	case filter.FieldFriendshipStyle:
		m.ClearFriendshipStyle()
		return nil
	case filter.FieldSocialEnergy:
		m.ClearSocialEnergy()
		return nil
	case filter.FieldHangoutPreference:
		m.ClearHangoutPreference()
		return nil
	case filter.FieldConversationDepth:
		m.ClearConversationDepth()
		return nil
	case filter.FieldGoalCategory:
		m.ClearGoalCategory()
		return nil
	case filter.FieldAccountabilityStyle:
		m.ClearAccountabilityStyle()
		return nil
	case filter.FieldCheckInFrequency:
		m.ClearCheckInFrequency()
		return nil
	case filter.FieldCommitmentLevel:
		m.ClearCommitmentLevel()
		return nil
	case filter.FieldFilterConfig:
		m.ClearFilterConfig()
		return nil
	}
	return fmt.Errorf("unknown Filter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilterMutation) ResetField(name string) error {
	switch name {
	case filter.FieldUserID:
		m.ResetUserID()
		return nil
	case filter.FieldServerType:
		m.ResetServerType()
		return nil
	case filter.FieldMinAge:
		m.ResetMinAge()
		return nil
	case filter.FieldMaxAge:
		m.ResetMaxAge()
		return nil
	case filter.FieldGenderPreference:
		m.ResetGenderPreference()
		return nil
	case filter.FieldRelationshipIntent:
		m.ResetRelationshipIntent()
		return nil
	case filter.FieldFamilyPlanning:
		m.ResetFamilyPlanning()
		return nil
	case filter.FieldLivingSituation:
		m.ResetLivingSituation()
		return nil
	case filter.FieldDietaryPreference:
		m.ResetDietaryPreference()
		return nil
	case filter.FieldFriendshipStyle:
		m.ResetFriendshipStyle()
		return nil
	case filter.FieldSocialEnergy:
		m.ResetSocialEnergy()
		return nil
	case filter.FieldHangoutPreference:
		m.ResetHangoutPreference()
		return nil
	case filter.FieldConversationDepth:
		m.ResetConversationDepth()
		return nil
	case filter.FieldGoalCategory:
		m.ResetGoalCategory()
		return nil
	case filter.FieldAccountabilityStyle:
		m.ResetAccountabilityStyle()
		return nil
	case filter.FieldCheckInFrequency:
		m.ResetCheckInFrequency()
		return nil
	case filter.FieldCommitmentLevel:
		m.ResetCommitmentLevel()
		return nil
	case filter.FieldFilterConfig:
		m.ResetFilterConfig()
		return nil
	case filter.FieldIsPending:
		m.ResetIsPending()
		return nil
	case filter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Filter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, filter.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filter.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, filter.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilterMutation) EdgeCleared(name string) bool {
	switch name {
	case filter.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilterMutation) ClearEdge(name string) error {
	switch name {
	case filter.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Filter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilterMutation) ResetEdge(name string) error {
	switch name {
	case filter.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Filter edge %s", name)
}

// HobbyMutation represents an operation that mutates the Hobby nodes in the graph.
type HobbyMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	micro_description   *string
	display_order       *int
	adddisplay_order    *int
	created_at          *time.Time
	deleted_at          *time.Time
	clearedFields       map[string]struct{}
	user                *string
	cleareduser         bool
	hobby_option        *string
	clearedhobby_option bool
	done                bool
	oldValue            func(context.Context) (*Hobby, error)
	predicates          []predicate.Hobby
}

var _ ent.Mutation = (*HobbyMutation)(nil)

// hobbyOption allows management of the mutation configuration using functional options.
type hobbyOption func(*HobbyMutation)

// newHobbyMutation creates new mutation for the Hobby entity.
func newHobbyMutation(c config, op Op, opts ...hobbyOption) *HobbyMutation {
	m := &HobbyMutation{
		config:        c,
		op:            op,
		typ:           TypeHobby,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHobbyID sets the ID field of the mutation.
func withHobbyID(id string) hobbyOption {
	return func(m *HobbyMutation) {
		var (
			err   error
			once  sync.Once
			value *Hobby
		)
		m.oldValue = func(ctx context.Context) (*Hobby, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hobby.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHobby sets the old Hobby of the mutation.
func withHobby(node *Hobby) hobbyOption {
	return func(m *HobbyMutation) {
		m.oldValue = func(context.Context) (*Hobby, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HobbyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HobbyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hobby entities.
func (m *HobbyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HobbyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HobbyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hobby.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *HobbyMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *HobbyMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Hobby entity.
// If the Hobby object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *HobbyMutation) ResetUserID() {
	m.user = nil
}

// SetHobbyOptionID sets the "hobby_option_id" field.
func (m *HobbyMutation) SetHobbyOptionID(s string) {
	m.hobby_option = &s
}

// HobbyOptionID returns the value of the "hobby_option_id" field in the mutation.
func (m *HobbyMutation) HobbyOptionID() (r string, exists bool) {
	v := m.hobby_option
	if v == nil {
		return
	}
	return *v, true
}

// OldHobbyOptionID returns the old "hobby_option_id" field's value of the Hobby entity.
// If the Hobby object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyMutation) OldHobbyOptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHobbyOptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHobbyOptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHobbyOptionID: %w", err)
	}
	return oldValue.HobbyOptionID, nil
}

// ResetHobbyOptionID resets all changes to the "hobby_option_id" field.
func (m *HobbyMutation) ResetHobbyOptionID() {
	m.hobby_option = nil
}

// SetMicroDescription sets the "micro_description" field.
func (m *HobbyMutation) SetMicroDescription(s string) {
	m.micro_description = &s
}

// MicroDescription returns the value of the "micro_description" field in the mutation.
func (m *HobbyMutation) MicroDescription() (r string, exists bool) {
	v := m.micro_description
	if v == nil {
		return
	}
	return *v, true
}

// OldMicroDescription returns the old "micro_description" field's value of the Hobby entity.
// If the Hobby object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyMutation) OldMicroDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMicroDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMicroDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMicroDescription: %w", err)
	}
	return oldValue.MicroDescription, nil
}

// ClearMicroDescription clears the value of the "micro_description" field.
func (m *HobbyMutation) ClearMicroDescription() {
	m.micro_description = nil
	m.clearedFields[hobby.FieldMicroDescription] = struct{}{}
}

// MicroDescriptionCleared returns if the "micro_description" field was cleared in this mutation.
func (m *HobbyMutation) MicroDescriptionCleared() bool {
	_, ok := m.clearedFields[hobby.FieldMicroDescription]
	return ok
}

// ResetMicroDescription resets all changes to the "micro_description" field.
func (m *HobbyMutation) ResetMicroDescription() {
	m.micro_description = nil
	delete(m.clearedFields, hobby.FieldMicroDescription)
}

// SetDisplayOrder sets the "display_order" field.
func (m *HobbyMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *HobbyMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the Hobby entity.
// If the Hobby object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *HobbyMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *HobbyMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *HobbyMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HobbyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HobbyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Hobby entity.
// If the Hobby object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HobbyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *HobbyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *HobbyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Hobby entity.
// If the Hobby object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *HobbyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[hobby.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *HobbyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[hobby.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *HobbyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, hobby.FieldDeletedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *HobbyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[hobby.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *HobbyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *HobbyMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *HobbyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearHobbyOption clears the "hobby_option" edge to the HobbyOption entity.
func (m *HobbyMutation) ClearHobbyOption() {
	m.clearedhobby_option = true
	m.clearedFields[hobby.FieldHobbyOptionID] = struct{}{}
}

// HobbyOptionCleared reports if the "hobby_option" edge to the HobbyOption entity was cleared.
func (m *HobbyMutation) HobbyOptionCleared() bool {
	return m.clearedhobby_option
}

// HobbyOptionIDs returns the "hobby_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HobbyOptionID instead. It exists only for internal usage by the builders.
func (m *HobbyMutation) HobbyOptionIDs() (ids []string) {
	if id := m.hobby_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHobbyOption resets all changes to the "hobby_option" edge.
func (m *HobbyMutation) ResetHobbyOption() {
	m.hobby_option = nil
	m.clearedhobby_option = false
}

// Where appends a list predicates to the HobbyMutation builder.
func (m *HobbyMutation) Where(ps ...predicate.Hobby) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HobbyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HobbyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hobby, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HobbyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HobbyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hobby).
func (m *HobbyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HobbyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user != nil {
		fields = append(fields, hobby.FieldUserID)
	}
	if m.hobby_option != nil {
		fields = append(fields, hobby.FieldHobbyOptionID)
	}
	if m.micro_description != nil {
		fields = append(fields, hobby.FieldMicroDescription)
	}
	if m.display_order != nil {
		fields = append(fields, hobby.FieldDisplayOrder)
	}
	if m.created_at != nil {
		fields = append(fields, hobby.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, hobby.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HobbyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hobby.FieldUserID:
		return m.UserID()
	case hobby.FieldHobbyOptionID:
		return m.HobbyOptionID()
	case hobby.FieldMicroDescription:
		return m.MicroDescription()
	case hobby.FieldDisplayOrder:
		return m.DisplayOrder()
	case hobby.FieldCreatedAt:
		return m.CreatedAt()
	case hobby.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HobbyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hobby.FieldUserID:
		return m.OldUserID(ctx)
	case hobby.FieldHobbyOptionID:
		return m.OldHobbyOptionID(ctx)
	case hobby.FieldMicroDescription:
		return m.OldMicroDescription(ctx)
	case hobby.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case hobby.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hobby.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Hobby field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HobbyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hobby.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case hobby.FieldHobbyOptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHobbyOptionID(v)
		return nil
	case hobby.FieldMicroDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMicroDescription(v)
		return nil
	case hobby.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case hobby.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hobby.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Hobby field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HobbyMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, hobby.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HobbyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hobby.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HobbyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hobby.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Hobby numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HobbyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hobby.FieldMicroDescription) {
		fields = append(fields, hobby.FieldMicroDescription)
	}
	if m.FieldCleared(hobby.FieldDeletedAt) {
		fields = append(fields, hobby.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HobbyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HobbyMutation) ClearField(name string) error {
	switch name {
	case hobby.FieldMicroDescription:
		m.ClearMicroDescription()
		return nil
	case hobby.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Hobby nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HobbyMutation) ResetField(name string) error {
	switch name {
	case hobby.FieldUserID:
		m.ResetUserID()
		return nil
	case hobby.FieldHobbyOptionID:
		m.ResetHobbyOptionID()
		return nil
	case hobby.FieldMicroDescription:
		m.ResetMicroDescription()
		return nil
	case hobby.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case hobby.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hobby.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Hobby field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HobbyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, hobby.EdgeUser)
	}
	if m.hobby_option != nil {
		edges = append(edges, hobby.EdgeHobbyOption)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HobbyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hobby.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case hobby.EdgeHobbyOption:
		if id := m.hobby_option; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HobbyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HobbyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HobbyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, hobby.EdgeUser)
	}
	if m.clearedhobby_option {
		edges = append(edges, hobby.EdgeHobbyOption)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HobbyMutation) EdgeCleared(name string) bool {
	switch name {
	case hobby.EdgeUser:
		return m.cleareduser
	case hobby.EdgeHobbyOption:
		return m.clearedhobby_option
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HobbyMutation) ClearEdge(name string) error {
	switch name {
	case hobby.EdgeUser:
		m.ClearUser()
		return nil
	case hobby.EdgeHobbyOption:
		m.ClearHobbyOption()
		return nil
	}
	return fmt.Errorf("unknown Hobby unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HobbyMutation) ResetEdge(name string) error {
	switch name {
	case hobby.EdgeUser:
		m.ResetUser()
		return nil
	case hobby.EdgeHobbyOption:
		m.ResetHobbyOption()
		return nil
	}
	return fmt.Errorf("unknown Hobby edge %s", name)
}

// HobbyOptionMutation represents an operation that mutates the HobbyOption nodes in the graph.
type HobbyOptionMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	name                     *string
	category                 *string
	icon_name                *string
	micro_descriptions       *[]string
	appendmicro_descriptions []string
	is_active                *bool
	sort_order               *int
	addsort_order            *int
	clearedFields            map[string]struct{}
	hobbies                  map[string]struct{}
	removedhobbies           map[string]struct{}
	clearedhobbies           bool
	done                     bool
	oldValue                 func(context.Context) (*HobbyOption, error)
	predicates               []predicate.HobbyOption
}

var _ ent.Mutation = (*HobbyOptionMutation)(nil)

// hobbyoptionOption allows management of the mutation configuration using functional options.
type hobbyoptionOption func(*HobbyOptionMutation)

// newHobbyOptionMutation creates new mutation for the HobbyOption entity.
func newHobbyOptionMutation(c config, op Op, opts ...hobbyoptionOption) *HobbyOptionMutation {
	m := &HobbyOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeHobbyOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHobbyOptionID sets the ID field of the mutation.
func withHobbyOptionID(id string) hobbyoptionOption {
	return func(m *HobbyOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *HobbyOption
		)
		m.oldValue = func(ctx context.Context) (*HobbyOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HobbyOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHobbyOption sets the old HobbyOption of the mutation.
func withHobbyOption(node *HobbyOption) hobbyoptionOption {
	return func(m *HobbyOptionMutation) {
		m.oldValue = func(context.Context) (*HobbyOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HobbyOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HobbyOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HobbyOption entities.
func (m *HobbyOptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HobbyOptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HobbyOptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HobbyOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *HobbyOptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HobbyOptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HobbyOption entity.
// If the HobbyOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyOptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HobbyOptionMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *HobbyOptionMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *HobbyOptionMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the HobbyOption entity.
// If the HobbyOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyOptionMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *HobbyOptionMutation) ResetCategory() {
	m.category = nil
}

// SetIconName sets the "icon_name" field.
func (m *HobbyOptionMutation) SetIconName(s string) {
	m.icon_name = &s
}

// IconName returns the value of the "icon_name" field in the mutation.
func (m *HobbyOptionMutation) IconName() (r string, exists bool) {
	v := m.icon_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIconName returns the old "icon_name" field's value of the HobbyOption entity.
// If the HobbyOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyOptionMutation) OldIconName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconName: %w", err)
	}
	return oldValue.IconName, nil
}

// ClearIconName clears the value of the "icon_name" field.
func (m *HobbyOptionMutation) ClearIconName() {
	m.icon_name = nil
	m.clearedFields[hobbyoption.FieldIconName] = struct{}{}
}

// IconNameCleared returns if the "icon_name" field was cleared in this mutation.
func (m *HobbyOptionMutation) IconNameCleared() bool {
	_, ok := m.clearedFields[hobbyoption.FieldIconName]
	return ok
}

// ResetIconName resets all changes to the "icon_name" field.
func (m *HobbyOptionMutation) ResetIconName() {
	m.icon_name = nil
	delete(m.clearedFields, hobbyoption.FieldIconName)
}

// SetMicroDescriptions sets the "micro_descriptions" field.
func (m *HobbyOptionMutation) SetMicroDescriptions(s []string) {
	m.micro_descriptions = &s
	m.appendmicro_descriptions = nil
}

// MicroDescriptions returns the value of the "micro_descriptions" field in the mutation.
func (m *HobbyOptionMutation) MicroDescriptions() (r []string, exists bool) {
	v := m.micro_descriptions
	if v == nil {
		return
	}
	return *v, true
}

// OldMicroDescriptions returns the old "micro_descriptions" field's value of the HobbyOption entity.
// If the HobbyOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyOptionMutation) OldMicroDescriptions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMicroDescriptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMicroDescriptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMicroDescriptions: %w", err)
	}
	return oldValue.MicroDescriptions, nil
}

// AppendMicroDescriptions adds s to the "micro_descriptions" field.
func (m *HobbyOptionMutation) AppendMicroDescriptions(s []string) {
	m.appendmicro_descriptions = append(m.appendmicro_descriptions, s...)
}

// AppendedMicroDescriptions returns the list of values that were appended to the "micro_descriptions" field in this mutation.
func (m *HobbyOptionMutation) AppendedMicroDescriptions() ([]string, bool) {
	if len(m.appendmicro_descriptions) == 0 {
		return nil, false
	}
	return m.appendmicro_descriptions, true
}

// ClearMicroDescriptions clears the value of the "micro_descriptions" field.
func (m *HobbyOptionMutation) ClearMicroDescriptions() {
	m.micro_descriptions = nil
	m.appendmicro_descriptions = nil
	m.clearedFields[hobbyoption.FieldMicroDescriptions] = struct{}{}
}

// MicroDescriptionsCleared returns if the "micro_descriptions" field was cleared in this mutation.
func (m *HobbyOptionMutation) MicroDescriptionsCleared() bool {
	_, ok := m.clearedFields[hobbyoption.FieldMicroDescriptions]
	return ok
}

// ResetMicroDescriptions resets all changes to the "micro_descriptions" field.
func (m *HobbyOptionMutation) ResetMicroDescriptions() {
	m.micro_descriptions = nil
	m.appendmicro_descriptions = nil
	delete(m.clearedFields, hobbyoption.FieldMicroDescriptions)
}

// SetIsActive sets the "is_active" field.
func (m *HobbyOptionMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *HobbyOptionMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the HobbyOption entity.
// If the HobbyOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyOptionMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *HobbyOptionMutation) ResetIsActive() {
	m.is_active = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *HobbyOptionMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *HobbyOptionMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the HobbyOption entity.
// If the HobbyOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HobbyOptionMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *HobbyOptionMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *HobbyOptionMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *HobbyOptionMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// AddHobbyIDs adds the "hobbies" edge to the Hobby entity by ids.
func (m *HobbyOptionMutation) AddHobbyIDs(ids ...string) {
	if m.hobbies == nil {
		m.hobbies = make(map[string]struct{})
	}
	for i := range ids {
		m.hobbies[ids[i]] = struct{}{}
	}
}

// ClearHobbies clears the "hobbies" edge to the Hobby entity.
func (m *HobbyOptionMutation) ClearHobbies() {
	m.clearedhobbies = true
}

// HobbiesCleared reports if the "hobbies" edge to the Hobby entity was cleared.
func (m *HobbyOptionMutation) HobbiesCleared() bool {
	return m.clearedhobbies
}

// RemoveHobbyIDs removes the "hobbies" edge to the Hobby entity by IDs.
func (m *HobbyOptionMutation) RemoveHobbyIDs(ids ...string) {
	if m.removedhobbies == nil {
		m.removedhobbies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hobbies, ids[i])
		m.removedhobbies[ids[i]] = struct{}{}
	}
}

// RemovedHobbies returns the removed IDs of the "hobbies" edge to the Hobby entity.
func (m *HobbyOptionMutation) RemovedHobbiesIDs() (ids []string) {
	for id := range m.removedhobbies {
		ids = append(ids, id)
	}
	return
}

// HobbiesIDs returns the "hobbies" edge IDs in the mutation.
func (m *HobbyOptionMutation) HobbiesIDs() (ids []string) {
	for id := range m.hobbies {
		ids = append(ids, id)
	}
	return
}

// ResetHobbies resets all changes to the "hobbies" edge.
func (m *HobbyOptionMutation) ResetHobbies() {
	m.hobbies = nil
	m.clearedhobbies = false
	m.removedhobbies = nil
}

// Where appends a list predicates to the HobbyOptionMutation builder.
func (m *HobbyOptionMutation) Where(ps ...predicate.HobbyOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HobbyOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HobbyOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HobbyOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HobbyOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HobbyOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HobbyOption).
func (m *HobbyOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HobbyOptionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, hobbyoption.FieldName)
	}
	if m.category != nil {
		fields = append(fields, hobbyoption.FieldCategory)
	}
	if m.icon_name != nil {
		fields = append(fields, hobbyoption.FieldIconName)
	}
	if m.micro_descriptions != nil {
		fields = append(fields, hobbyoption.FieldMicroDescriptions)
	}
	if m.is_active != nil {
		fields = append(fields, hobbyoption.FieldIsActive)
	}
	if m.sort_order != nil {
		fields = append(fields, hobbyoption.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HobbyOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hobbyoption.FieldName:
		return m.Name()
	case hobbyoption.FieldCategory:
		return m.Category()
	case hobbyoption.FieldIconName:
		return m.IconName()
	case hobbyoption.FieldMicroDescriptions:
		return m.MicroDescriptions()
	case hobbyoption.FieldIsActive:
		return m.IsActive()
	case hobbyoption.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HobbyOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hobbyoption.FieldName:
		return m.OldName(ctx)
	case hobbyoption.FieldCategory:
		return m.OldCategory(ctx)
	case hobbyoption.FieldIconName:
		return m.OldIconName(ctx)
	case hobbyoption.FieldMicroDescriptions:
		return m.OldMicroDescriptions(ctx)
	case hobbyoption.FieldIsActive:
		return m.OldIsActive(ctx)
	case hobbyoption.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown HobbyOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HobbyOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hobbyoption.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hobbyoption.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case hobbyoption.FieldIconName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconName(v)
		return nil
	case hobbyoption.FieldMicroDescriptions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMicroDescriptions(v)
		return nil
	case hobbyoption.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case hobbyoption.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown HobbyOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HobbyOptionMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, hobbyoption.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HobbyOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hobbyoption.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HobbyOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hobbyoption.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown HobbyOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HobbyOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hobbyoption.FieldIconName) {
		fields = append(fields, hobbyoption.FieldIconName)
	}
	if m.FieldCleared(hobbyoption.FieldMicroDescriptions) {
		fields = append(fields, hobbyoption.FieldMicroDescriptions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HobbyOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HobbyOptionMutation) ClearField(name string) error {
	switch name {
	case hobbyoption.FieldIconName:
		m.ClearIconName()
		return nil
	case hobbyoption.FieldMicroDescriptions:
		m.ClearMicroDescriptions()
		return nil
	}
	return fmt.Errorf("unknown HobbyOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HobbyOptionMutation) ResetField(name string) error {
	switch name {
	case hobbyoption.FieldName:
		m.ResetName()
		return nil
	case hobbyoption.FieldCategory:
		m.ResetCategory()
		return nil
	case hobbyoption.FieldIconName:
		m.ResetIconName()
		return nil
	case hobbyoption.FieldMicroDescriptions:
		m.ResetMicroDescriptions()
		return nil
	case hobbyoption.FieldIsActive:
		m.ResetIsActive()
		return nil
	case hobbyoption.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown HobbyOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HobbyOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hobbies != nil {
		edges = append(edges, hobbyoption.EdgeHobbies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HobbyOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hobbyoption.EdgeHobbies:
		ids := make([]ent.Value, 0, len(m.hobbies))
		for id := range m.hobbies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HobbyOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhobbies != nil {
		edges = append(edges, hobbyoption.EdgeHobbies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HobbyOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hobbyoption.EdgeHobbies:
		ids := make([]ent.Value, 0, len(m.removedhobbies))
		for id := range m.removedhobbies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HobbyOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhobbies {
		edges = append(edges, hobbyoption.EdgeHobbies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HobbyOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case hobbyoption.EdgeHobbies:
		return m.clearedhobbies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HobbyOptionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown HobbyOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HobbyOptionMutation) ResetEdge(name string) error {
	switch name {
	case hobbyoption.EdgeHobbies:
		m.ResetHobbies()
		return nil
	}
	return fmt.Errorf("unknown HobbyOption edge %s", name)
}

// InterestMutation represents an operation that mutates the Interest nodes in the graph.
type InterestMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	server_type           *interest.ServerType
	interest_status       *interest.InterestStatus
	created_at            *time.Time
	matched_at            *time.Time
	deleted_at            *time.Time
	clearedFields         map[string]struct{}
	sender                *string
	clearedsender         bool
	receiver              *string
	clearedreceiver       bool
	discovery_card        *string
	cleareddiscovery_card bool
	done                  bool
	oldValue              func(context.Context) (*Interest, error)
	predicates            []predicate.Interest
}

var _ ent.Mutation = (*InterestMutation)(nil)

// interestOption allows management of the mutation configuration using functional options.
type interestOption func(*InterestMutation)

// newInterestMutation creates new mutation for the Interest entity.
func newInterestMutation(c config, op Op, opts ...interestOption) *InterestMutation {
	m := &InterestMutation{
		config:        c,
		op:            op,
		typ:           TypeInterest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInterestID sets the ID field of the mutation.
func withInterestID(id string) interestOption {
	return func(m *InterestMutation) {
		var (
			err   error
			once  sync.Once
			value *Interest
		)
		m.oldValue = func(ctx context.Context) (*Interest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Interest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInterest sets the old Interest of the mutation.
func withInterest(node *Interest) interestOption {
	return func(m *InterestMutation) {
		m.oldValue = func(context.Context) (*Interest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InterestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InterestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Interest entities.
func (m *InterestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InterestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InterestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Interest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSenderUserID sets the "sender_user_id" field.
func (m *InterestMutation) SetSenderUserID(s string) {
	m.sender = &s
}

// SenderUserID returns the value of the "sender_user_id" field in the mutation.
func (m *InterestMutation) SenderUserID() (r string, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderUserID returns the old "sender_user_id" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldSenderUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderUserID: %w", err)
	}
	return oldValue.SenderUserID, nil
}

// ResetSenderUserID resets all changes to the "sender_user_id" field.
func (m *InterestMutation) ResetSenderUserID() {
	m.sender = nil
}

// SetReceiverUserID sets the "receiver_user_id" field.
func (m *InterestMutation) SetReceiverUserID(s string) {
	m.receiver = &s
}

// ReceiverUserID returns the value of the "receiver_user_id" field in the mutation.
func (m *InterestMutation) ReceiverUserID() (r string, exists bool) {
	v := m.receiver
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverUserID returns the old "receiver_user_id" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldReceiverUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverUserID: %w", err)
	}
	return oldValue.ReceiverUserID, nil
}

// ResetReceiverUserID resets all changes to the "receiver_user_id" field.
func (m *InterestMutation) ResetReceiverUserID() {
	m.receiver = nil
}

// SetServerType sets the "server_type" field.
func (m *InterestMutation) SetServerType(it interest.ServerType) {
	m.server_type = &it
}

// ServerType returns the value of the "server_type" field in the mutation.
func (m *InterestMutation) ServerType() (r interest.ServerType, exists bool) {
	v := m.server_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerType returns the old "server_type" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldServerType(ctx context.Context) (v interest.ServerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerType: %w", err)
	}
	return oldValue.ServerType, nil
}

// ResetServerType resets all changes to the "server_type" field.
func (m *InterestMutation) ResetServerType() {
	m.server_type = nil
}

// SetDiscoveryCardID sets the "discovery_card_id" field.
func (m *InterestMutation) SetDiscoveryCardID(s string) {
	m.discovery_card = &s
}

// DiscoveryCardID returns the value of the "discovery_card_id" field in the mutation.
func (m *InterestMutation) DiscoveryCardID() (r string, exists bool) {
	v := m.discovery_card
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscoveryCardID returns the old "discovery_card_id" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldDiscoveryCardID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscoveryCardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscoveryCardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscoveryCardID: %w", err)
	}
	return oldValue.DiscoveryCardID, nil
}

// ClearDiscoveryCardID clears the value of the "discovery_card_id" field.
func (m *InterestMutation) ClearDiscoveryCardID() {
	m.discovery_card = nil
	m.clearedFields[interest.FieldDiscoveryCardID] = struct{}{}
}

// DiscoveryCardIDCleared returns if the "discovery_card_id" field was cleared in this mutation.
func (m *InterestMutation) DiscoveryCardIDCleared() bool {
	_, ok := m.clearedFields[interest.FieldDiscoveryCardID]
	return ok
}

// ResetDiscoveryCardID resets all changes to the "discovery_card_id" field.
func (m *InterestMutation) ResetDiscoveryCardID() {
	m.discovery_card = nil
	delete(m.clearedFields, interest.FieldDiscoveryCardID)
}

// SetInterestStatus sets the "interest_status" field.
func (m *InterestMutation) SetInterestStatus(is interest.InterestStatus) {
	m.interest_status = &is
}

// InterestStatus returns the value of the "interest_status" field in the mutation.
func (m *InterestMutation) InterestStatus() (r interest.InterestStatus, exists bool) {
	v := m.interest_status
	if v == nil {
		return
	}
	return *v, true
}

// OldInterestStatus returns the old "interest_status" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldInterestStatus(ctx context.Context) (v interest.InterestStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterestStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterestStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterestStatus: %w", err)
	}
	return oldValue.InterestStatus, nil
}

// ResetInterestStatus resets all changes to the "interest_status" field.
func (m *InterestMutation) ResetInterestStatus() {
	m.interest_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InterestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InterestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InterestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetMatchedAt sets the "matched_at" field.
func (m *InterestMutation) SetMatchedAt(t time.Time) {
	m.matched_at = &t
}

// MatchedAt returns the value of the "matched_at" field in the mutation.
func (m *InterestMutation) MatchedAt() (r time.Time, exists bool) {
	v := m.matched_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchedAt returns the old "matched_at" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldMatchedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchedAt: %w", err)
	}
	return oldValue.MatchedAt, nil
}

// ClearMatchedAt clears the value of the "matched_at" field.
func (m *InterestMutation) ClearMatchedAt() {
	m.matched_at = nil
	m.clearedFields[interest.FieldMatchedAt] = struct{}{}
}

// MatchedAtCleared returns if the "matched_at" field was cleared in this mutation.
func (m *InterestMutation) MatchedAtCleared() bool {
	_, ok := m.clearedFields[interest.FieldMatchedAt]
	return ok
}

// ResetMatchedAt resets all changes to the "matched_at" field.
func (m *InterestMutation) ResetMatchedAt() {
	m.matched_at = nil
	delete(m.clearedFields, interest.FieldMatchedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InterestMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InterestMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Interest entity.
// If the Interest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InterestMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InterestMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[interest.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InterestMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[interest.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InterestMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, interest.FieldDeletedAt)
}

// SetSenderID sets the "sender" edge to the User entity by id.
func (m *InterestMutation) SetSenderID(id string) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the User entity.
func (m *InterestMutation) ClearSender() {
	m.clearedsender = true
	m.clearedFields[interest.FieldSenderUserID] = struct{}{}
}

// SenderCleared reports if the "sender" edge to the User entity was cleared.
func (m *InterestMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *InterestMutation) SenderID() (id string, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *InterestMutation) SenderIDs() (ids []string) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *InterestMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// SetReceiverID sets the "receiver" edge to the User entity by id.
func (m *InterestMutation) SetReceiverID(id string) {
	m.receiver = &id
}

// ClearReceiver clears the "receiver" edge to the User entity.
func (m *InterestMutation) ClearReceiver() {
	m.clearedreceiver = true
	m.clearedFields[interest.FieldReceiverUserID] = struct{}{}
}

// ReceiverCleared reports if the "receiver" edge to the User entity was cleared.
func (m *InterestMutation) ReceiverCleared() bool {
	return m.clearedreceiver
}

// ReceiverID returns the "receiver" edge ID in the mutation.
func (m *InterestMutation) ReceiverID() (id string, exists bool) {
	if m.receiver != nil {
		return *m.receiver, true
	}
	return
}

// ReceiverIDs returns the "receiver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiverID instead. It exists only for internal usage by the builders.
func (m *InterestMutation) ReceiverIDs() (ids []string) {
	if id := m.receiver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceiver resets all changes to the "receiver" edge.
func (m *InterestMutation) ResetReceiver() {
	m.receiver = nil
	m.clearedreceiver = false
}

// ClearDiscoveryCard clears the "discovery_card" edge to the DiscoveryCard entity.
func (m *InterestMutation) ClearDiscoveryCard() {
	m.cleareddiscovery_card = true
	m.clearedFields[interest.FieldDiscoveryCardID] = struct{}{}
}

// DiscoveryCardCleared reports if the "discovery_card" edge to the DiscoveryCard entity was cleared.
func (m *InterestMutation) DiscoveryCardCleared() bool {
	return m.DiscoveryCardIDCleared() || m.cleareddiscovery_card
}

// DiscoveryCardIDs returns the "discovery_card" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscoveryCardID instead. It exists only for internal usage by the builders.
func (m *InterestMutation) DiscoveryCardIDs() (ids []string) {
	if id := m.discovery_card; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscoveryCard resets all changes to the "discovery_card" edge.
func (m *InterestMutation) ResetDiscoveryCard() {
	m.discovery_card = nil
	m.cleareddiscovery_card = false
}

// Where appends a list predicates to the InterestMutation builder.
func (m *InterestMutation) Where(ps ...predicate.Interest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InterestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InterestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Interest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InterestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InterestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Interest).
func (m *InterestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InterestMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.sender != nil {
		fields = append(fields, interest.FieldSenderUserID)
	}
	if m.receiver != nil {
		fields = append(fields, interest.FieldReceiverUserID)
	}
	if m.server_type != nil {
		fields = append(fields, interest.FieldServerType)
	}
	if m.discovery_card != nil {
		fields = append(fields, interest.FieldDiscoveryCardID)
	}
	if m.interest_status != nil {
		fields = append(fields, interest.FieldInterestStatus)
	}
	if m.created_at != nil {
		fields = append(fields, interest.FieldCreatedAt)
	}
	if m.matched_at != nil {
		fields = append(fields, interest.FieldMatchedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, interest.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InterestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case interest.FieldSenderUserID:
		return m.SenderUserID()
	case interest.FieldReceiverUserID:
		return m.ReceiverUserID()
	case interest.FieldServerType:
		return m.ServerType()
	case interest.FieldDiscoveryCardID:
		return m.DiscoveryCardID()
	case interest.FieldInterestStatus:
		return m.InterestStatus()
	case interest.FieldCreatedAt:
		return m.CreatedAt()
	case interest.FieldMatchedAt:
		return m.MatchedAt()
	case interest.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InterestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case interest.FieldSenderUserID:
		return m.OldSenderUserID(ctx)
	case interest.FieldReceiverUserID:
		return m.OldReceiverUserID(ctx)
	case interest.FieldServerType:
		return m.OldServerType(ctx)
	case interest.FieldDiscoveryCardID:
		return m.OldDiscoveryCardID(ctx)
	case interest.FieldInterestStatus:
		return m.OldInterestStatus(ctx)
	case interest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case interest.FieldMatchedAt:
		return m.OldMatchedAt(ctx)
	case interest.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Interest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case interest.FieldSenderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderUserID(v)
		return nil
	case interest.FieldReceiverUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverUserID(v)
		return nil
	case interest.FieldServerType:
		v, ok := value.(interest.ServerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerType(v)
		return nil
	case interest.FieldDiscoveryCardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscoveryCardID(v)
		return nil
	case interest.FieldInterestStatus:
		v, ok := value.(interest.InterestStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterestStatus(v)
		return nil
	case interest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case interest.FieldMatchedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchedAt(v)
		return nil
	case interest.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Interest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InterestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InterestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InterestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Interest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InterestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(interest.FieldDiscoveryCardID) {
		fields = append(fields, interest.FieldDiscoveryCardID)
	}
	if m.FieldCleared(interest.FieldMatchedAt) {
		fields = append(fields, interest.FieldMatchedAt)
	}
	if m.FieldCleared(interest.FieldDeletedAt) {
		fields = append(fields, interest.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InterestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InterestMutation) ClearField(name string) error {
	switch name {
	case interest.FieldDiscoveryCardID:
		m.ClearDiscoveryCardID()
		return nil
	case interest.FieldMatchedAt:
		m.ClearMatchedAt()
		return nil
	case interest.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Interest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InterestMutation) ResetField(name string) error {
	switch name {
	case interest.FieldSenderUserID:
		m.ResetSenderUserID()
		return nil
	case interest.FieldReceiverUserID:
		m.ResetReceiverUserID()
		return nil
	case interest.FieldServerType:
		m.ResetServerType()
		return nil
	case interest.FieldDiscoveryCardID:
		m.ResetDiscoveryCardID()
		return nil
	case interest.FieldInterestStatus:
		m.ResetInterestStatus()
		return nil
	case interest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case interest.FieldMatchedAt:
		m.ResetMatchedAt()
		return nil
	case interest.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Interest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InterestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.sender != nil {
		edges = append(edges, interest.EdgeSender)
	}
	if m.receiver != nil {
		edges = append(edges, interest.EdgeReceiver)
	}
	if m.discovery_card != nil {
		edges = append(edges, interest.EdgeDiscoveryCard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InterestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case interest.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case interest.EdgeReceiver:
		if id := m.receiver; id != nil {
			return []ent.Value{*id}
		}
	case interest.EdgeDiscoveryCard:
		if id := m.discovery_card; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InterestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InterestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InterestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsender {
		edges = append(edges, interest.EdgeSender)
	}
	if m.clearedreceiver {
		edges = append(edges, interest.EdgeReceiver)
	}
	if m.cleareddiscovery_card {
		edges = append(edges, interest.EdgeDiscoveryCard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InterestMutation) EdgeCleared(name string) bool {
	switch name {
	case interest.EdgeSender:
		return m.clearedsender
	case interest.EdgeReceiver:
		return m.clearedreceiver
	case interest.EdgeDiscoveryCard:
		return m.cleareddiscovery_card
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InterestMutation) ClearEdge(name string) error {
	switch name {
	case interest.EdgeSender:
		m.ClearSender()
		return nil
	case interest.EdgeReceiver:
		m.ClearReceiver()
		return nil
	case interest.EdgeDiscoveryCard:
		m.ClearDiscoveryCard()
		return nil
	}
	return fmt.Errorf("unknown Interest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InterestMutation) ResetEdge(name string) error {
	switch name {
	case interest.EdgeSender:
		m.ResetSender()
		return nil
	case interest.EdgeReceiver:
		m.ResetReceiver()
		return nil
	case interest.EdgeDiscoveryCard:
		m.ResetDiscoveryCard()
		return nil
	}
	return fmt.Errorf("unknown Interest edge %s", name)
}

// NudgeMutation represents an operation that mutates the Nudge nodes in the graph.
type NudgeMutation struct {
	config
	op              Op
	typ             string
	id              *string
	day_number      *int
	addday_number   *int
	nudge_status    *nudge.NudgeStatus
	message         *string
	created_at      *time.Time
	seen_at         *time.Time
	responded_at    *time.Time
	clearedFields   map[string]struct{}
	streak          *string
	clearedstreak   bool
	sender          *string
	clearedsender   bool
	receiver        *string
	clearedreceiver bool
	done            bool
	oldValue        func(context.Context) (*Nudge, error)
	predicates      []predicate.Nudge
}

var _ ent.Mutation = (*NudgeMutation)(nil)

// nudgeOption allows management of the mutation configuration using functional options.
type nudgeOption func(*NudgeMutation)

// newNudgeMutation creates new mutation for the Nudge entity.
func newNudgeMutation(c config, op Op, opts ...nudgeOption) *NudgeMutation {
	m := &NudgeMutation{
		config:        c,
		op:            op,
		typ:           TypeNudge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNudgeID sets the ID field of the mutation.
func withNudgeID(id string) nudgeOption {
	return func(m *NudgeMutation) {
		var (
			err   error
			once  sync.Once
			value *Nudge
		)
		m.oldValue = func(ctx context.Context) (*Nudge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nudge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNudge sets the old Nudge of the mutation.
func withNudge(node *Nudge) nudgeOption {
	return func(m *NudgeMutation) {
		m.oldValue = func(context.Context) (*Nudge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NudgeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NudgeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Nudge entities.
func (m *NudgeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NudgeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NudgeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Nudge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStreakID sets the "streak_id" field.
func (m *NudgeMutation) SetStreakID(s string) {
	m.streak = &s
}

// StreakID returns the value of the "streak_id" field in the mutation.
func (m *NudgeMutation) StreakID() (r string, exists bool) {
	v := m.streak
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakID returns the old "streak_id" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldStreakID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakID: %w", err)
	}
	return oldValue.StreakID, nil
}

// ResetStreakID resets all changes to the "streak_id" field.
func (m *NudgeMutation) ResetStreakID() {
	m.streak = nil
}

// SetSenderUserID sets the "sender_user_id" field.
func (m *NudgeMutation) SetSenderUserID(s string) {
	m.sender = &s
}

// SenderUserID returns the value of the "sender_user_id" field in the mutation.
func (m *NudgeMutation) SenderUserID() (r string, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderUserID returns the old "sender_user_id" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldSenderUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderUserID: %w", err)
	}
	return oldValue.SenderUserID, nil
}

// ResetSenderUserID resets all changes to the "sender_user_id" field.
func (m *NudgeMutation) ResetSenderUserID() {
	m.sender = nil
}

// SetReceiverUserID sets the "receiver_user_id" field.
func (m *NudgeMutation) SetReceiverUserID(s string) {
	m.receiver = &s
}

// ReceiverUserID returns the value of the "receiver_user_id" field in the mutation.
func (m *NudgeMutation) ReceiverUserID() (r string, exists bool) {
	v := m.receiver
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverUserID returns the old "receiver_user_id" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldReceiverUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverUserID: %w", err)
	}
	return oldValue.ReceiverUserID, nil
}

// ResetReceiverUserID resets all changes to the "receiver_user_id" field.
func (m *NudgeMutation) ResetReceiverUserID() {
	m.receiver = nil
}

// SetDayNumber sets the "day_number" field.
func (m *NudgeMutation) SetDayNumber(i int) {
	m.day_number = &i
	m.addday_number = nil
}

// DayNumber returns the value of the "day_number" field in the mutation.
func (m *NudgeMutation) DayNumber() (r int, exists bool) {
	v := m.day_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDayNumber returns the old "day_number" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldDayNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayNumber: %w", err)
	}
	return oldValue.DayNumber, nil
}

// AddDayNumber adds i to the "day_number" field.
func (m *NudgeMutation) AddDayNumber(i int) {
	if m.addday_number != nil {
		*m.addday_number += i
	} else {
		m.addday_number = &i
	}
}

// AddedDayNumber returns the value that was added to the "day_number" field in this mutation.
func (m *NudgeMutation) AddedDayNumber() (r int, exists bool) {
	v := m.addday_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetDayNumber resets all changes to the "day_number" field.
func (m *NudgeMutation) ResetDayNumber() {
	m.day_number = nil
	m.addday_number = nil
}

// SetNudgeStatus sets the "nudge_status" field.
func (m *NudgeMutation) SetNudgeStatus(ns nudge.NudgeStatus) {
	m.nudge_status = &ns
}

// NudgeStatus returns the value of the "nudge_status" field in the mutation.
func (m *NudgeMutation) NudgeStatus() (r nudge.NudgeStatus, exists bool) {
	v := m.nudge_status
	if v == nil {
		return
	}
	return *v, true
}

// OldNudgeStatus returns the old "nudge_status" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldNudgeStatus(ctx context.Context) (v nudge.NudgeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNudgeStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNudgeStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNudgeStatus: %w", err)
	}
	return oldValue.NudgeStatus, nil
}

// ResetNudgeStatus resets all changes to the "nudge_status" field.
func (m *NudgeMutation) ResetNudgeStatus() {
	m.nudge_status = nil
}

// SetMessage sets the "message" field.
func (m *NudgeMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *NudgeMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *NudgeMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[nudge.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *NudgeMutation) MessageCleared() bool {
	_, ok := m.clearedFields[nudge.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *NudgeMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, nudge.FieldMessage)
}

// SetCreatedAt sets the "created_at" field.
func (m *NudgeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NudgeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NudgeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetSeenAt sets the "seen_at" field.
func (m *NudgeMutation) SetSeenAt(t time.Time) {
	m.seen_at = &t
}

// SeenAt returns the value of the "seen_at" field in the mutation.
func (m *NudgeMutation) SeenAt() (r time.Time, exists bool) {
	v := m.seen_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSeenAt returns the old "seen_at" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldSeenAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeenAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeenAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeenAt: %w", err)
	}
	return oldValue.SeenAt, nil
}

// ClearSeenAt clears the value of the "seen_at" field.
func (m *NudgeMutation) ClearSeenAt() {
	m.seen_at = nil
	m.clearedFields[nudge.FieldSeenAt] = struct{}{}
}

// SeenAtCleared returns if the "seen_at" field was cleared in this mutation.
func (m *NudgeMutation) SeenAtCleared() bool {
	_, ok := m.clearedFields[nudge.FieldSeenAt]
	return ok
}

// ResetSeenAt resets all changes to the "seen_at" field.
func (m *NudgeMutation) ResetSeenAt() {
	m.seen_at = nil
	delete(m.clearedFields, nudge.FieldSeenAt)
}

// SetRespondedAt sets the "responded_at" field.
func (m *NudgeMutation) SetRespondedAt(t time.Time) {
	m.responded_at = &t
}

// RespondedAt returns the value of the "responded_at" field in the mutation.
func (m *NudgeMutation) RespondedAt() (r time.Time, exists bool) {
	v := m.responded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRespondedAt returns the old "responded_at" field's value of the Nudge entity.
// If the Nudge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NudgeMutation) OldRespondedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespondedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespondedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespondedAt: %w", err)
	}
	return oldValue.RespondedAt, nil
}

// ClearRespondedAt clears the value of the "responded_at" field.
func (m *NudgeMutation) ClearRespondedAt() {
	m.responded_at = nil
	m.clearedFields[nudge.FieldRespondedAt] = struct{}{}
}

// RespondedAtCleared returns if the "responded_at" field was cleared in this mutation.
func (m *NudgeMutation) RespondedAtCleared() bool {
	_, ok := m.clearedFields[nudge.FieldRespondedAt]
	return ok
}

// ResetRespondedAt resets all changes to the "responded_at" field.
func (m *NudgeMutation) ResetRespondedAt() {
	m.responded_at = nil
	delete(m.clearedFields, nudge.FieldRespondedAt)
}

// ClearStreak clears the "streak" edge to the Streak entity.
func (m *NudgeMutation) ClearStreak() {
	m.clearedstreak = true
	m.clearedFields[nudge.FieldStreakID] = struct{}{}
}

// StreakCleared reports if the "streak" edge to the Streak entity was cleared.
func (m *NudgeMutation) StreakCleared() bool {
	return m.clearedstreak
}

// StreakIDs returns the "streak" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StreakID instead. It exists only for internal usage by the builders.
func (m *NudgeMutation) StreakIDs() (ids []string) {
	if id := m.streak; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStreak resets all changes to the "streak" edge.
func (m *NudgeMutation) ResetStreak() {
	m.streak = nil
	m.clearedstreak = false
}

// SetSenderID sets the "sender" edge to the User entity by id.
func (m *NudgeMutation) SetSenderID(id string) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the User entity.
func (m *NudgeMutation) ClearSender() {
	m.clearedsender = true
	m.clearedFields[nudge.FieldSenderUserID] = struct{}{}
}

// SenderCleared reports if the "sender" edge to the User entity was cleared.
func (m *NudgeMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *NudgeMutation) SenderID() (id string, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *NudgeMutation) SenderIDs() (ids []string) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *NudgeMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// SetReceiverID sets the "receiver" edge to the User entity by id.
func (m *NudgeMutation) SetReceiverID(id string) {
	m.receiver = &id
}

// ClearReceiver clears the "receiver" edge to the User entity.
func (m *NudgeMutation) ClearReceiver() {
	m.clearedreceiver = true
	m.clearedFields[nudge.FieldReceiverUserID] = struct{}{}
}

// ReceiverCleared reports if the "receiver" edge to the User entity was cleared.
func (m *NudgeMutation) ReceiverCleared() bool {
	return m.clearedreceiver
}

// ReceiverID returns the "receiver" edge ID in the mutation.
func (m *NudgeMutation) ReceiverID() (id string, exists bool) {
	if m.receiver != nil {
		return *m.receiver, true
	}
	return
}

// ReceiverIDs returns the "receiver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiverID instead. It exists only for internal usage by the builders.
func (m *NudgeMutation) ReceiverIDs() (ids []string) {
	if id := m.receiver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceiver resets all changes to the "receiver" edge.
func (m *NudgeMutation) ResetReceiver() {
	m.receiver = nil
	m.clearedreceiver = false
}

// Where appends a list predicates to the NudgeMutation builder.
func (m *NudgeMutation) Where(ps ...predicate.Nudge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NudgeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NudgeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Nudge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NudgeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NudgeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Nudge).
func (m *NudgeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NudgeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.streak != nil {
		fields = append(fields, nudge.FieldStreakID)
	}
	if m.sender != nil {
		fields = append(fields, nudge.FieldSenderUserID)
	}
	if m.receiver != nil {
		fields = append(fields, nudge.FieldReceiverUserID)
	}
	if m.day_number != nil {
		fields = append(fields, nudge.FieldDayNumber)
	}
	if m.nudge_status != nil {
		fields = append(fields, nudge.FieldNudgeStatus)
	}
	if m.message != nil {
		fields = append(fields, nudge.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, nudge.FieldCreatedAt)
	}
	if m.seen_at != nil {
		fields = append(fields, nudge.FieldSeenAt)
	}
	if m.responded_at != nil {
		fields = append(fields, nudge.FieldRespondedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NudgeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nudge.FieldStreakID:
		return m.StreakID()
	case nudge.FieldSenderUserID:
		return m.SenderUserID()
	case nudge.FieldReceiverUserID:
		return m.ReceiverUserID()
	case nudge.FieldDayNumber:
		return m.DayNumber()
	case nudge.FieldNudgeStatus:
		return m.NudgeStatus()
	case nudge.FieldMessage:
		return m.Message()
	case nudge.FieldCreatedAt:
		return m.CreatedAt()
	case nudge.FieldSeenAt:
		return m.SeenAt()
	case nudge.FieldRespondedAt:
		return m.RespondedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NudgeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nudge.FieldStreakID:
		return m.OldStreakID(ctx)
	case nudge.FieldSenderUserID:
		return m.OldSenderUserID(ctx)
	case nudge.FieldReceiverUserID:
		return m.OldReceiverUserID(ctx)
	case nudge.FieldDayNumber:
		return m.OldDayNumber(ctx)
	case nudge.FieldNudgeStatus:
		return m.OldNudgeStatus(ctx)
	case nudge.FieldMessage:
		return m.OldMessage(ctx)
	case nudge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case nudge.FieldSeenAt:
		return m.OldSeenAt(ctx)
	case nudge.FieldRespondedAt:
		return m.OldRespondedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Nudge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NudgeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nudge.FieldStreakID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakID(v)
		return nil
	case nudge.FieldSenderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderUserID(v)
		return nil
	case nudge.FieldReceiverUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverUserID(v)
		return nil
	case nudge.FieldDayNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayNumber(v)
		return nil
	case nudge.FieldNudgeStatus:
		v, ok := value.(nudge.NudgeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNudgeStatus(v)
		return nil
	case nudge.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case nudge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case nudge.FieldSeenAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeenAt(v)
		return nil
	case nudge.FieldRespondedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespondedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Nudge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NudgeMutation) AddedFields() []string {
	var fields []string
	if m.addday_number != nil {
		fields = append(fields, nudge.FieldDayNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NudgeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nudge.FieldDayNumber:
		return m.AddedDayNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NudgeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nudge.FieldDayNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Nudge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NudgeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nudge.FieldMessage) {
		fields = append(fields, nudge.FieldMessage)
	}
	if m.FieldCleared(nudge.FieldSeenAt) {
		fields = append(fields, nudge.FieldSeenAt)
	}
	if m.FieldCleared(nudge.FieldRespondedAt) {
		fields = append(fields, nudge.FieldRespondedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NudgeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NudgeMutation) ClearField(name string) error {
	switch name {
	case nudge.FieldMessage:
		m.ClearMessage()
		return nil
	case nudge.FieldSeenAt:
		m.ClearSeenAt()
		return nil
	case nudge.FieldRespondedAt:
		m.ClearRespondedAt()
		return nil
	}
	return fmt.Errorf("unknown Nudge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NudgeMutation) ResetField(name string) error {
	switch name {
	case nudge.FieldStreakID:
		m.ResetStreakID()
		return nil
	case nudge.FieldSenderUserID:
		m.ResetSenderUserID()
		return nil
	case nudge.FieldReceiverUserID:
		m.ResetReceiverUserID()
		return nil
	case nudge.FieldDayNumber:
		m.ResetDayNumber()
		return nil
	case nudge.FieldNudgeStatus:
		m.ResetNudgeStatus()
		return nil
	case nudge.FieldMessage:
		m.ResetMessage()
		return nil
	case nudge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case nudge.FieldSeenAt:
		m.ResetSeenAt()
		return nil
	case nudge.FieldRespondedAt:
		m.ResetRespondedAt()
		return nil
	}
	return fmt.Errorf("unknown Nudge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NudgeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.streak != nil {
		edges = append(edges, nudge.EdgeStreak)
	}
	if m.sender != nil {
		edges = append(edges, nudge.EdgeSender)
	}
	if m.receiver != nil {
		edges = append(edges, nudge.EdgeReceiver)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NudgeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nudge.EdgeStreak:
		if id := m.streak; id != nil {
			return []ent.Value{*id}
		}
	case nudge.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case nudge.EdgeReceiver:
		if id := m.receiver; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NudgeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NudgeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NudgeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstreak {
		edges = append(edges, nudge.EdgeStreak)
	}
	if m.clearedsender {
		edges = append(edges, nudge.EdgeSender)
	}
	if m.clearedreceiver {
		edges = append(edges, nudge.EdgeReceiver)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NudgeMutation) EdgeCleared(name string) bool {
	switch name {
	case nudge.EdgeStreak:
		return m.clearedstreak
	case nudge.EdgeSender:
		return m.clearedsender
	case nudge.EdgeReceiver:
		return m.clearedreceiver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NudgeMutation) ClearEdge(name string) error {
	switch name {
	case nudge.EdgeStreak:
		m.ClearStreak()
		return nil
	case nudge.EdgeSender:
		m.ClearSender()
		return nil
	case nudge.EdgeReceiver:
		m.ClearReceiver()
		return nil
	}
	return fmt.Errorf("unknown Nudge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NudgeMutation) ResetEdge(name string) error {
	switch name {
	case nudge.EdgeStreak:
		m.ResetStreak()
		return nil
	case nudge.EdgeSender:
		m.ResetSender()
		return nil
	case nudge.EdgeReceiver:
		m.ResetReceiver()
		return nil
	}
	return fmt.Errorf("unknown Nudge edge %s", name)
}

// PaymentOrderMutation represents an operation that mutates the PaymentOrder nodes in the graph.
type PaymentOrderMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	package_id          *string
	razorpay_order_id   *string
	razorpay_payment_id *string
	razorpay_signature  *string
	amount              *int
	addamount           *int
	currency            *string
	credits_to_add      *int
	addcredits_to_add   *int
	order_status        *paymentorder.OrderStatus
	failure_reason      *string
	created_at          *time.Time
	paid_at             *time.Time
	expires_at          *time.Time
	clearedFields       map[string]struct{}
	user                *string
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*PaymentOrder, error)
	predicates          []predicate.PaymentOrder
}

var _ ent.Mutation = (*PaymentOrderMutation)(nil)

// paymentorderOption allows management of the mutation configuration using functional options.
type paymentorderOption func(*PaymentOrderMutation)

// newPaymentOrderMutation creates new mutation for the PaymentOrder entity.
func newPaymentOrderMutation(c config, op Op, opts ...paymentorderOption) *PaymentOrderMutation {
	m := &PaymentOrderMutation{
		config:        c,
		op:            op,
		typ:           TypePaymentOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentOrderID sets the ID field of the mutation.
func withPaymentOrderID(id string) paymentorderOption {
	return func(m *PaymentOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *PaymentOrder
		)
		m.oldValue = func(ctx context.Context) (*PaymentOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PaymentOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPaymentOrder sets the old PaymentOrder of the mutation.
func withPaymentOrder(node *PaymentOrder) paymentorderOption {
	return func(m *PaymentOrderMutation) {
		m.oldValue = func(context.Context) (*PaymentOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PaymentOrder entities.
func (m *PaymentOrderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentOrderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentOrderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PaymentOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PaymentOrderMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentOrderMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentOrderMutation) ResetUserID() {
	m.user = nil
}

// SetPackageID sets the "package_id" field.
func (m *PaymentOrderMutation) SetPackageID(s string) {
	m.package_id = &s
}

// PackageID returns the value of the "package_id" field in the mutation.
func (m *PaymentOrderMutation) PackageID() (r string, exists bool) {
	v := m.package_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPackageID returns the old "package_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldPackageID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackageID: %w", err)
	}
	return oldValue.PackageID, nil
}

// ClearPackageID clears the value of the "package_id" field.
func (m *PaymentOrderMutation) ClearPackageID() {
	m.package_id = nil
	m.clearedFields[paymentorder.FieldPackageID] = struct{}{}
}

// PackageIDCleared returns if the "package_id" field was cleared in this mutation.
func (m *PaymentOrderMutation) PackageIDCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldPackageID]
	return ok
}

// ResetPackageID resets all changes to the "package_id" field.
func (m *PaymentOrderMutation) ResetPackageID() {
	m.package_id = nil
	delete(m.clearedFields, paymentorder.FieldPackageID)
}

// SetRazorpayOrderID sets the "razorpay_order_id" field.
func (m *PaymentOrderMutation) SetRazorpayOrderID(s string) {
	m.razorpay_order_id = &s
}

// RazorpayOrderID returns the value of the "razorpay_order_id" field in the mutation.
func (m *PaymentOrderMutation) RazorpayOrderID() (r string, exists bool) {
	v := m.razorpay_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRazorpayOrderID returns the old "razorpay_order_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldRazorpayOrderID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRazorpayOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRazorpayOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRazorpayOrderID: %w", err)
	}
	return oldValue.RazorpayOrderID, nil
}

// ResetRazorpayOrderID resets all changes to the "razorpay_order_id" field.
func (m *PaymentOrderMutation) ResetRazorpayOrderID() {
	m.razorpay_order_id = nil
}

// SetRazorpayPaymentID sets the "razorpay_payment_id" field.
func (m *PaymentOrderMutation) SetRazorpayPaymentID(s string) {
	m.razorpay_payment_id = &s
}

// RazorpayPaymentID returns the value of the "razorpay_payment_id" field in the mutation.
func (m *PaymentOrderMutation) RazorpayPaymentID() (r string, exists bool) {
	v := m.razorpay_payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRazorpayPaymentID returns the old "razorpay_payment_id" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldRazorpayPaymentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRazorpayPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRazorpayPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRazorpayPaymentID: %w", err)
	}
	return oldValue.RazorpayPaymentID, nil
}

// ClearRazorpayPaymentID clears the value of the "razorpay_payment_id" field.
func (m *PaymentOrderMutation) ClearRazorpayPaymentID() {
	m.razorpay_payment_id = nil
	m.clearedFields[paymentorder.FieldRazorpayPaymentID] = struct{}{}
}

// RazorpayPaymentIDCleared returns if the "razorpay_payment_id" field was cleared in this mutation.
func (m *PaymentOrderMutation) RazorpayPaymentIDCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldRazorpayPaymentID]
	return ok
}

// ResetRazorpayPaymentID resets all changes to the "razorpay_payment_id" field.
func (m *PaymentOrderMutation) ResetRazorpayPaymentID() {
	m.razorpay_payment_id = nil
	delete(m.clearedFields, paymentorder.FieldRazorpayPaymentID)
}

// SetRazorpaySignature sets the "razorpay_signature" field.
func (m *PaymentOrderMutation) SetRazorpaySignature(s string) {
	m.razorpay_signature = &s
}

// RazorpaySignature returns the value of the "razorpay_signature" field in the mutation.
func (m *PaymentOrderMutation) RazorpaySignature() (r string, exists bool) {
	v := m.razorpay_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldRazorpaySignature returns the old "razorpay_signature" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldRazorpaySignature(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRazorpaySignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRazorpaySignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRazorpaySignature: %w", err)
	}
	return oldValue.RazorpaySignature, nil
}

// ClearRazorpaySignature clears the value of the "razorpay_signature" field.
func (m *PaymentOrderMutation) ClearRazorpaySignature() {
	m.razorpay_signature = nil
	m.clearedFields[paymentorder.FieldRazorpaySignature] = struct{}{}
}

// RazorpaySignatureCleared returns if the "razorpay_signature" field was cleared in this mutation.
func (m *PaymentOrderMutation) RazorpaySignatureCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldRazorpaySignature]
	return ok
}

// ResetRazorpaySignature resets all changes to the "razorpay_signature" field.
func (m *PaymentOrderMutation) ResetRazorpaySignature() {
	m.razorpay_signature = nil
	delete(m.clearedFields, paymentorder.FieldRazorpaySignature)
}

// SetAmount sets the "amount" field.
func (m *PaymentOrderMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentOrderMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "amount" field.
func (m *PaymentOrderMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentOrderMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCurrency sets the "currency" field.
func (m *PaymentOrderMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *PaymentOrderMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ResetCurrency resets all changes to the "currency" field.
func (m *PaymentOrderMutation) ResetCurrency() {
	m.currency = nil
}

// SetCreditsToAdd sets the "credits_to_add" field.
func (m *PaymentOrderMutation) SetCreditsToAdd(i int) {
	m.credits_to_add = &i
	m.addcredits_to_add = nil
}

// CreditsToAdd returns the value of the "credits_to_add" field in the mutation.
func (m *PaymentOrderMutation) CreditsToAdd() (r int, exists bool) {
	v := m.credits_to_add
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditsToAdd returns the old "credits_to_add" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldCreditsToAdd(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditsToAdd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditsToAdd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditsToAdd: %w", err)
	}
	return oldValue.CreditsToAdd, nil
}

// AddCreditsToAdd adds i to the "credits_to_add" field.
func (m *PaymentOrderMutation) AddCreditsToAdd(i int) {
	if m.addcredits_to_add != nil {
		*m.addcredits_to_add += i
	} else {
		m.addcredits_to_add = &i
	}
}

// AddedCreditsToAdd returns the value that was added to the "credits_to_add" field in this mutation.
func (m *PaymentOrderMutation) AddedCreditsToAdd() (r int, exists bool) {
	v := m.addcredits_to_add
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditsToAdd resets all changes to the "credits_to_add" field.
func (m *PaymentOrderMutation) ResetCreditsToAdd() {
	m.credits_to_add = nil
	m.addcredits_to_add = nil
}

// SetOrderStatus sets the "order_status" field.
func (m *PaymentOrderMutation) SetOrderStatus(ps paymentorder.OrderStatus) {
	m.order_status = &ps
}

// OrderStatus returns the value of the "order_status" field in the mutation.
func (m *PaymentOrderMutation) OrderStatus() (r paymentorder.OrderStatus, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatus returns the old "order_status" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldOrderStatus(ctx context.Context) (v paymentorder.OrderStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatus: %w", err)
	}
	return oldValue.OrderStatus, nil
}

// ResetOrderStatus resets all changes to the "order_status" field.
func (m *PaymentOrderMutation) ResetOrderStatus() {
	m.order_status = nil
}

// SetFailureReason sets the "failure_reason" field.
func (m *PaymentOrderMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *PaymentOrderMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldFailureReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *PaymentOrderMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[paymentorder.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *PaymentOrderMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *PaymentOrderMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, paymentorder.FieldFailureReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetPaidAt sets the "paid_at" field.
func (m *PaymentOrderMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *PaymentOrderMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *PaymentOrderMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[paymentorder.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *PaymentOrderMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *PaymentOrderMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, paymentorder.FieldPaidAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *PaymentOrderMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PaymentOrderMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PaymentOrder entity.
// If the PaymentOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentOrderMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *PaymentOrderMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[paymentorder.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *PaymentOrderMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[paymentorder.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PaymentOrderMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, paymentorder.FieldExpiresAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PaymentOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[paymentorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PaymentOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PaymentOrderMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PaymentOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PaymentOrderMutation builder.
func (m *PaymentOrderMutation) Where(ps ...predicate.PaymentOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PaymentOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PaymentOrder).
func (m *PaymentOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentOrderMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.user != nil {
		fields = append(fields, paymentorder.FieldUserID)
	}
	if m.package_id != nil {
		fields = append(fields, paymentorder.FieldPackageID)
	}
	if m.razorpay_order_id != nil {
		fields = append(fields, paymentorder.FieldRazorpayOrderID)
	}
	if m.razorpay_payment_id != nil {
		fields = append(fields, paymentorder.FieldRazorpayPaymentID)
	}
	if m.razorpay_signature != nil {
		fields = append(fields, paymentorder.FieldRazorpaySignature)
	}
	if m.amount != nil {
		fields = append(fields, paymentorder.FieldAmount)
	}
	if m.currency != nil {
		fields = append(fields, paymentorder.FieldCurrency)
	}
	if m.credits_to_add != nil {
		fields = append(fields, paymentorder.FieldCreditsToAdd)
	}
	if m.order_status != nil {
		fields = append(fields, paymentorder.FieldOrderStatus)
	}
	if m.failure_reason != nil {
		fields = append(fields, paymentorder.FieldFailureReason)
	}
	if m.created_at != nil {
		fields = append(fields, paymentorder.FieldCreatedAt)
	}
	if m.paid_at != nil {
		fields = append(fields, paymentorder.FieldPaidAt)
	}
	if m.expires_at != nil {
		fields = append(fields, paymentorder.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case paymentorder.FieldUserID:
		return m.UserID()
	case paymentorder.FieldPackageID:
		return m.PackageID()
	case paymentorder.FieldRazorpayOrderID:
		return m.RazorpayOrderID()
	case paymentorder.FieldRazorpayPaymentID:
		return m.RazorpayPaymentID()
	case paymentorder.FieldRazorpaySignature:
		return m.RazorpaySignature()
	case paymentorder.FieldAmount:
		return m.Amount()
	case paymentorder.FieldCurrency:
		return m.Currency()
	case paymentorder.FieldCreditsToAdd:
		return m.CreditsToAdd()
	case paymentorder.FieldOrderStatus:
		return m.OrderStatus()
	case paymentorder.FieldFailureReason:
		return m.FailureReason()
	case paymentorder.FieldCreatedAt:
		return m.CreatedAt()
	case paymentorder.FieldPaidAt:
		return m.PaidAt()
	case paymentorder.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case paymentorder.FieldUserID:
		return m.OldUserID(ctx)
	case paymentorder.FieldPackageID:
		return m.OldPackageID(ctx)
	case paymentorder.FieldRazorpayOrderID:
		return m.OldRazorpayOrderID(ctx)
	case paymentorder.FieldRazorpayPaymentID:
		return m.OldRazorpayPaymentID(ctx)
	case paymentorder.FieldRazorpaySignature:
		return m.OldRazorpaySignature(ctx)
	case paymentorder.FieldAmount:
		return m.OldAmount(ctx)
	case paymentorder.FieldCurrency:
		return m.OldCurrency(ctx)
	case paymentorder.FieldCreditsToAdd:
		return m.OldCreditsToAdd(ctx)
	case paymentorder.FieldOrderStatus:
		return m.OldOrderStatus(ctx)
	case paymentorder.FieldFailureReason:
		return m.OldFailureReason(ctx)
	case paymentorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case paymentorder.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case paymentorder.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown PaymentOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case paymentorder.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case paymentorder.FieldPackageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackageID(v)
		return nil
	case paymentorder.FieldRazorpayOrderID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRazorpayOrderID(v)
		return nil
	case paymentorder.FieldRazorpayPaymentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRazorpayPaymentID(v)
		return nil
	case paymentorder.FieldRazorpaySignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRazorpaySignature(v)
		return nil
	case paymentorder.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case paymentorder.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case paymentorder.FieldCreditsToAdd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditsToAdd(v)
		return nil
	case paymentorder.FieldOrderStatus:
		v, ok := value.(paymentorder.OrderStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatus(v)
		return nil
	case paymentorder.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	case paymentorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case paymentorder.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case paymentorder.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentOrderMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, paymentorder.FieldAmount)
	}
	if m.addcredits_to_add != nil {
		fields = append(fields, paymentorder.FieldCreditsToAdd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case paymentorder.FieldAmount:
		return m.AddedAmount()
	case paymentorder.FieldCreditsToAdd:
		return m.AddedCreditsToAdd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case paymentorder.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case paymentorder.FieldCreditsToAdd:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditsToAdd(v)
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(paymentorder.FieldPackageID) {
		fields = append(fields, paymentorder.FieldPackageID)
	}
	if m.FieldCleared(paymentorder.FieldRazorpayPaymentID) {
		fields = append(fields, paymentorder.FieldRazorpayPaymentID)
	}
	if m.FieldCleared(paymentorder.FieldRazorpaySignature) {
		fields = append(fields, paymentorder.FieldRazorpaySignature)
	}
	if m.FieldCleared(paymentorder.FieldFailureReason) {
		fields = append(fields, paymentorder.FieldFailureReason)
	}
	if m.FieldCleared(paymentorder.FieldPaidAt) {
		fields = append(fields, paymentorder.FieldPaidAt)
	}
	if m.FieldCleared(paymentorder.FieldExpiresAt) {
		fields = append(fields, paymentorder.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentOrderMutation) ClearField(name string) error {
	switch name {
	case paymentorder.FieldPackageID:
		m.ClearPackageID()
		return nil
	case paymentorder.FieldRazorpayPaymentID:
		m.ClearRazorpayPaymentID()
		return nil
	case paymentorder.FieldRazorpaySignature:
		m.ClearRazorpaySignature()
		return nil
	case paymentorder.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	case paymentorder.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case paymentorder.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentOrderMutation) ResetField(name string) error {
	switch name {
	case paymentorder.FieldUserID:
		m.ResetUserID()
		return nil
	case paymentorder.FieldPackageID:
		m.ResetPackageID()
		return nil
	case paymentorder.FieldRazorpayOrderID:
		m.ResetRazorpayOrderID()
		return nil
	case paymentorder.FieldRazorpayPaymentID:
		m.ResetRazorpayPaymentID()
		return nil
	case paymentorder.FieldRazorpaySignature:
		m.ResetRazorpaySignature()
		return nil
	case paymentorder.FieldAmount:
		m.ResetAmount()
		return nil
	case paymentorder.FieldCurrency:
		m.ResetCurrency()
		return nil
	case paymentorder.FieldCreditsToAdd:
		m.ResetCreditsToAdd()
		return nil
	case paymentorder.FieldOrderStatus:
		m.ResetOrderStatus()
		return nil
	case paymentorder.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	case paymentorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case paymentorder.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case paymentorder.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, paymentorder.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case paymentorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, paymentorder.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case paymentorder.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentOrderMutation) ClearEdge(name string) error {
	switch name {
	case paymentorder.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentOrderMutation) ResetEdge(name string) error {
	switch name {
	case paymentorder.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PaymentOrder edge %s", name)
}

// PhotoMutation represents an operation that mutates the Photo nodes in the graph.
type PhotoMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	storage_key          *string
	display_order        *int
	adddisplay_order     *int
	is_face_photo        *bool
	ai_validated_at      *time.Time
	ai_validation_passed *bool
	is_verified          *bool
	is_flagged           *bool
	flag_reason          *string
	created_at           *time.Time
	deleted_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Photo, error)
	predicates           []predicate.Photo
}

var _ ent.Mutation = (*PhotoMutation)(nil)

// photoOption allows management of the mutation configuration using functional options.
type photoOption func(*PhotoMutation)

// newPhotoMutation creates new mutation for the Photo entity.
func newPhotoMutation(c config, op Op, opts ...photoOption) *PhotoMutation {
	m := &PhotoMutation{
		config:        c,
		op:            op,
		typ:           TypePhoto,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhotoID sets the ID field of the mutation.
func withPhotoID(id string) photoOption {
	return func(m *PhotoMutation) {
		var (
			err   error
			once  sync.Once
			value *Photo
		)
		m.oldValue = func(ctx context.Context) (*Photo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Photo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhoto sets the old Photo of the mutation.
func withPhoto(node *Photo) photoOption {
	return func(m *PhotoMutation) {
		m.oldValue = func(context.Context) (*Photo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhotoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhotoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Photo entities.
func (m *PhotoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PhotoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PhotoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Photo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PhotoMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PhotoMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PhotoMutation) ResetUserID() {
	m.user = nil
}

// SetStorageKey sets the "storage_key" field.
func (m *PhotoMutation) SetStorageKey(s string) {
	m.storage_key = &s
}

// StorageKey returns the value of the "storage_key" field in the mutation.
func (m *PhotoMutation) StorageKey() (r string, exists bool) {
	v := m.storage_key
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageKey returns the old "storage_key" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldStorageKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageKey: %w", err)
	}
	return oldValue.StorageKey, nil
}

// ResetStorageKey resets all changes to the "storage_key" field.
func (m *PhotoMutation) ResetStorageKey() {
	m.storage_key = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *PhotoMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *PhotoMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *PhotoMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *PhotoMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *PhotoMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetIsFacePhoto sets the "is_face_photo" field.
func (m *PhotoMutation) SetIsFacePhoto(b bool) {
	m.is_face_photo = &b
}

// IsFacePhoto returns the value of the "is_face_photo" field in the mutation.
func (m *PhotoMutation) IsFacePhoto() (r bool, exists bool) {
	v := m.is_face_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFacePhoto returns the old "is_face_photo" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldIsFacePhoto(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFacePhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFacePhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFacePhoto: %w", err)
	}
	return oldValue.IsFacePhoto, nil
}

// ResetIsFacePhoto resets all changes to the "is_face_photo" field.
func (m *PhotoMutation) ResetIsFacePhoto() {
	m.is_face_photo = nil
}

// SetAiValidatedAt sets the "ai_validated_at" field.
func (m *PhotoMutation) SetAiValidatedAt(t time.Time) {
	m.ai_validated_at = &t
}

// AiValidatedAt returns the value of the "ai_validated_at" field in the mutation.
func (m *PhotoMutation) AiValidatedAt() (r time.Time, exists bool) {
	v := m.ai_validated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAiValidatedAt returns the old "ai_validated_at" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldAiValidatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiValidatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiValidatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiValidatedAt: %w", err)
	}
	return oldValue.AiValidatedAt, nil
}

// ClearAiValidatedAt clears the value of the "ai_validated_at" field.
func (m *PhotoMutation) ClearAiValidatedAt() {
	m.ai_validated_at = nil
	m.clearedFields[photo.FieldAiValidatedAt] = struct{}{}
}

// AiValidatedAtCleared returns if the "ai_validated_at" field was cleared in this mutation.
func (m *PhotoMutation) AiValidatedAtCleared() bool {
	_, ok := m.clearedFields[photo.FieldAiValidatedAt]
	return ok
}

// ResetAiValidatedAt resets all changes to the "ai_validated_at" field.
func (m *PhotoMutation) ResetAiValidatedAt() {
	m.ai_validated_at = nil
	delete(m.clearedFields, photo.FieldAiValidatedAt)
}

// SetAiValidationPassed sets the "ai_validation_passed" field.
func (m *PhotoMutation) SetAiValidationPassed(b bool) {
	m.ai_validation_passed = &b
}

// AiValidationPassed returns the value of the "ai_validation_passed" field in the mutation.
func (m *PhotoMutation) AiValidationPassed() (r bool, exists bool) {
	v := m.ai_validation_passed
	if v == nil {
		return
	}
	return *v, true
}

// OldAiValidationPassed returns the old "ai_validation_passed" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldAiValidationPassed(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiValidationPassed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiValidationPassed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiValidationPassed: %w", err)
	}
	return oldValue.AiValidationPassed, nil
}

// ClearAiValidationPassed clears the value of the "ai_validation_passed" field.
func (m *PhotoMutation) ClearAiValidationPassed() {
	m.ai_validation_passed = nil
	m.clearedFields[photo.FieldAiValidationPassed] = struct{}{}
}

// AiValidationPassedCleared returns if the "ai_validation_passed" field was cleared in this mutation.
func (m *PhotoMutation) AiValidationPassedCleared() bool {
	_, ok := m.clearedFields[photo.FieldAiValidationPassed]
	return ok
}

// ResetAiValidationPassed resets all changes to the "ai_validation_passed" field.
func (m *PhotoMutation) ResetAiValidationPassed() {
	m.ai_validation_passed = nil
	delete(m.clearedFields, photo.FieldAiValidationPassed)
}

// SetIsVerified sets the "is_verified" field.
func (m *PhotoMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *PhotoMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *PhotoMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetIsFlagged sets the "is_flagged" field.
func (m *PhotoMutation) SetIsFlagged(b bool) {
	m.is_flagged = &b
}

// IsFlagged returns the value of the "is_flagged" field in the mutation.
func (m *PhotoMutation) IsFlagged() (r bool, exists bool) {
	v := m.is_flagged
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFlagged returns the old "is_flagged" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldIsFlagged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFlagged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFlagged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFlagged: %w", err)
	}
	return oldValue.IsFlagged, nil
}

// ResetIsFlagged resets all changes to the "is_flagged" field.
func (m *PhotoMutation) ResetIsFlagged() {
	m.is_flagged = nil
}

// SetFlagReason sets the "flag_reason" field.
func (m *PhotoMutation) SetFlagReason(s string) {
	m.flag_reason = &s
}

// FlagReason returns the value of the "flag_reason" field in the mutation.
func (m *PhotoMutation) FlagReason() (r string, exists bool) {
	v := m.flag_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFlagReason returns the old "flag_reason" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldFlagReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlagReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlagReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlagReason: %w", err)
	}
	return oldValue.FlagReason, nil
}

// ClearFlagReason clears the value of the "flag_reason" field.
func (m *PhotoMutation) ClearFlagReason() {
	m.flag_reason = nil
	m.clearedFields[photo.FieldFlagReason] = struct{}{}
}

// FlagReasonCleared returns if the "flag_reason" field was cleared in this mutation.
func (m *PhotoMutation) FlagReasonCleared() bool {
	_, ok := m.clearedFields[photo.FieldFlagReason]
	return ok
}

// ResetFlagReason resets all changes to the "flag_reason" field.
func (m *PhotoMutation) ResetFlagReason() {
	m.flag_reason = nil
	delete(m.clearedFields, photo.FieldFlagReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *PhotoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PhotoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PhotoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PhotoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PhotoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Photo entity.
// If the Photo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PhotoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PhotoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[photo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PhotoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[photo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PhotoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, photo.FieldDeletedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PhotoMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[photo.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PhotoMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PhotoMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PhotoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PhotoMutation builder.
func (m *PhotoMutation) Where(ps ...predicate.Photo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PhotoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PhotoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Photo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PhotoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PhotoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Photo).
func (m *PhotoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PhotoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, photo.FieldUserID)
	}
	if m.storage_key != nil {
		fields = append(fields, photo.FieldStorageKey)
	}
	if m.display_order != nil {
		fields = append(fields, photo.FieldDisplayOrder)
	}
	if m.is_face_photo != nil {
		fields = append(fields, photo.FieldIsFacePhoto)
	}
	if m.ai_validated_at != nil {
		fields = append(fields, photo.FieldAiValidatedAt)
	}
	if m.ai_validation_passed != nil {
		fields = append(fields, photo.FieldAiValidationPassed)
	}
	if m.is_verified != nil {
		fields = append(fields, photo.FieldIsVerified)
	}
	if m.is_flagged != nil {
		fields = append(fields, photo.FieldIsFlagged)
	}
	if m.flag_reason != nil {
		fields = append(fields, photo.FieldFlagReason)
	}
	if m.created_at != nil {
		fields = append(fields, photo.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, photo.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PhotoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case photo.FieldUserID:
		return m.UserID()
	case photo.FieldStorageKey:
		return m.StorageKey()
	case photo.FieldDisplayOrder:
		return m.DisplayOrder()
	case photo.FieldIsFacePhoto:
		return m.IsFacePhoto()
	case photo.FieldAiValidatedAt:
		return m.AiValidatedAt()
	case photo.FieldAiValidationPassed:
		return m.AiValidationPassed()
	case photo.FieldIsVerified:
		return m.IsVerified()
	case photo.FieldIsFlagged:
		return m.IsFlagged()
	case photo.FieldFlagReason:
		return m.FlagReason()
	case photo.FieldCreatedAt:
		return m.CreatedAt()
	case photo.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PhotoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case photo.FieldUserID:
		return m.OldUserID(ctx)
	case photo.FieldStorageKey:
		return m.OldStorageKey(ctx)
	case photo.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case photo.FieldIsFacePhoto:
		return m.OldIsFacePhoto(ctx)
	case photo.FieldAiValidatedAt:
		return m.OldAiValidatedAt(ctx)
	case photo.FieldAiValidationPassed:
		return m.OldAiValidationPassed(ctx)
	case photo.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case photo.FieldIsFlagged:
		return m.OldIsFlagged(ctx)
	case photo.FieldFlagReason:
		return m.OldFlagReason(ctx)
	case photo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case photo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Photo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhotoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case photo.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case photo.FieldStorageKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageKey(v)
		return nil
	case photo.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case photo.FieldIsFacePhoto:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFacePhoto(v)
		return nil
	case photo.FieldAiValidatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiValidatedAt(v)
		return nil
	case photo.FieldAiValidationPassed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiValidationPassed(v)
		return nil
	case photo.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case photo.FieldIsFlagged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFlagged(v)
		return nil
	case photo.FieldFlagReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlagReason(v)
		return nil
	case photo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case photo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Photo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PhotoMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, photo.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PhotoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case photo.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PhotoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case photo.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Photo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PhotoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(photo.FieldAiValidatedAt) {
		fields = append(fields, photo.FieldAiValidatedAt)
	}
	if m.FieldCleared(photo.FieldAiValidationPassed) {
		fields = append(fields, photo.FieldAiValidationPassed)
	}
	if m.FieldCleared(photo.FieldFlagReason) {
		fields = append(fields, photo.FieldFlagReason)
	}
	if m.FieldCleared(photo.FieldDeletedAt) {
		fields = append(fields, photo.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PhotoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhotoMutation) ClearField(name string) error {
	switch name {
	case photo.FieldAiValidatedAt:
		m.ClearAiValidatedAt()
		return nil
	case photo.FieldAiValidationPassed:
		m.ClearAiValidationPassed()
		return nil
	case photo.FieldFlagReason:
		m.ClearFlagReason()
		return nil
	case photo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Photo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PhotoMutation) ResetField(name string) error {
	switch name {
	case photo.FieldUserID:
		m.ResetUserID()
		return nil
	case photo.FieldStorageKey:
		m.ResetStorageKey()
		return nil
	case photo.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case photo.FieldIsFacePhoto:
		m.ResetIsFacePhoto()
		return nil
	case photo.FieldAiValidatedAt:
		m.ResetAiValidatedAt()
		return nil
	case photo.FieldAiValidationPassed:
		m.ResetAiValidationPassed()
		return nil
	case photo.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case photo.FieldIsFlagged:
		m.ResetIsFlagged()
		return nil
	case photo.FieldFlagReason:
		m.ResetFlagReason()
		return nil
	case photo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case photo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Photo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PhotoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, photo.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PhotoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case photo.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PhotoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PhotoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PhotoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, photo.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PhotoMutation) EdgeCleared(name string) bool {
	switch name {
	case photo.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PhotoMutation) ClearEdge(name string) error {
	switch name {
	case photo.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Photo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PhotoMutation) ResetEdge(name string) error {
	switch name {
	case photo.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Photo edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op               Op
	typ              string
	id               *string
	first_name       *string
	last_name        *string
	date_of_birth    *time.Time
	gender           *string
	city             *string
	bio              *string
	intent_statement *string
	optional_fields  *map[string]interface{}
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	clearedFields    map[string]struct{}
	user             *string
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Profile, error)
	predicates       []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id string) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *ProfileMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProfileMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProfileMutation) ResetUserID() {
	m.user = nil
}

// SetFirstName sets the "first_name" field.
func (m *ProfileMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *ProfileMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFirstName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *ProfileMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[profile.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *ProfileMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *ProfileMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, profile.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *ProfileMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *ProfileMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldLastName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *ProfileMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[profile.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *ProfileMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *ProfileMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, profile.FieldLastName)
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *ProfileMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *ProfileMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldDateOfBirth(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *ProfileMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[profile.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *ProfileMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[profile.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *ProfileMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, profile.FieldDateOfBirth)
}

// SetGender sets the "gender" field.
func (m *ProfileMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *ProfileMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldGender(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *ProfileMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[profile.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *ProfileMutation) GenderCleared() bool {
	_, ok := m.clearedFields[profile.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *ProfileMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, profile.FieldGender)
}

// SetCity sets the "city" field.
func (m *ProfileMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *ProfileMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *ProfileMutation) ClearCity() {
	m.city = nil
	m.clearedFields[profile.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *ProfileMutation) CityCleared() bool {
	_, ok := m.clearedFields[profile.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *ProfileMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, profile.FieldCity)
}

// SetBio sets the "bio" field.
func (m *ProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *ProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldBio(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *ProfileMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[profile.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *ProfileMutation) BioCleared() bool {
	_, ok := m.clearedFields[profile.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *ProfileMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, profile.FieldBio)
}

// SetIntentStatement sets the "intent_statement" field.
func (m *ProfileMutation) SetIntentStatement(s string) {
	m.intent_statement = &s
}

// IntentStatement returns the value of the "intent_statement" field in the mutation.
func (m *ProfileMutation) IntentStatement() (r string, exists bool) {
	v := m.intent_statement
	if v == nil {
		return
	}
	return *v, true
}

// OldIntentStatement returns the old "intent_statement" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldIntentStatement(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntentStatement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntentStatement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntentStatement: %w", err)
	}
	return oldValue.IntentStatement, nil
}

// ClearIntentStatement clears the value of the "intent_statement" field.
func (m *ProfileMutation) ClearIntentStatement() {
	m.intent_statement = nil
	m.clearedFields[profile.FieldIntentStatement] = struct{}{}
}

// IntentStatementCleared returns if the "intent_statement" field was cleared in this mutation.
func (m *ProfileMutation) IntentStatementCleared() bool {
	_, ok := m.clearedFields[profile.FieldIntentStatement]
	return ok
}

// ResetIntentStatement resets all changes to the "intent_statement" field.
func (m *ProfileMutation) ResetIntentStatement() {
	m.intent_statement = nil
	delete(m.clearedFields, profile.FieldIntentStatement)
}

// SetOptionalFields sets the "optional_fields" field.
func (m *ProfileMutation) SetOptionalFields(value map[string]interface{}) {
	m.optional_fields = &value
}

// OptionalFields returns the value of the "optional_fields" field in the mutation.
func (m *ProfileMutation) OptionalFields() (r map[string]interface{}, exists bool) {
	v := m.optional_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionalFields returns the old "optional_fields" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldOptionalFields(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionalFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionalFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionalFields: %w", err)
	}
	return oldValue.OptionalFields, nil
}

// ClearOptionalFields clears the value of the "optional_fields" field.
func (m *ProfileMutation) ClearOptionalFields() {
	m.optional_fields = nil
	m.clearedFields[profile.FieldOptionalFields] = struct{}{}
}

// OptionalFieldsCleared returns if the "optional_fields" field was cleared in this mutation.
func (m *ProfileMutation) OptionalFieldsCleared() bool {
	_, ok := m.clearedFields[profile.FieldOptionalFields]
	return ok
}

// ResetOptionalFields resets all changes to the "optional_fields" field.
func (m *ProfileMutation) ResetOptionalFields() {
	m.optional_fields = nil
	delete(m.clearedFields, profile.FieldOptionalFields)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProfileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProfileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProfileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[profile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProfileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[profile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProfileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, profile.FieldDeletedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfileMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[profile.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user != nil {
		fields = append(fields, profile.FieldUserID)
	}
	if m.first_name != nil {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, profile.FieldLastName)
	}
	if m.date_of_birth != nil {
		fields = append(fields, profile.FieldDateOfBirth)
	}
	if m.gender != nil {
		fields = append(fields, profile.FieldGender)
	}
	if m.city != nil {
		fields = append(fields, profile.FieldCity)
	}
	if m.bio != nil {
		fields = append(fields, profile.FieldBio)
	}
	if m.intent_statement != nil {
		fields = append(fields, profile.FieldIntentStatement)
	}
	if m.optional_fields != nil {
		fields = append(fields, profile.FieldOptionalFields)
	}
	if m.created_at != nil {
		fields = append(fields, profile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profile.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, profile.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldUserID:
		return m.UserID()
	case profile.FieldFirstName:
		return m.FirstName()
	case profile.FieldLastName:
		return m.LastName()
	case profile.FieldDateOfBirth:
		return m.DateOfBirth()
	case profile.FieldGender:
		return m.Gender()
	case profile.FieldCity:
		return m.City()
	case profile.FieldBio:
		return m.Bio()
	case profile.FieldIntentStatement:
		return m.IntentStatement()
	case profile.FieldOptionalFields:
		return m.OptionalFields()
	case profile.FieldCreatedAt:
		return m.CreatedAt()
	case profile.FieldUpdatedAt:
		return m.UpdatedAt()
	case profile.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldUserID:
		return m.OldUserID(ctx)
	case profile.FieldFirstName:
		return m.OldFirstName(ctx)
	case profile.FieldLastName:
		return m.OldLastName(ctx)
	case profile.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case profile.FieldGender:
		return m.OldGender(ctx)
	case profile.FieldCity:
		return m.OldCity(ctx)
	case profile.FieldBio:
		return m.OldBio(ctx)
	case profile.FieldIntentStatement:
		return m.OldIntentStatement(ctx)
	case profile.FieldOptionalFields:
		return m.OldOptionalFields(ctx)
	case profile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case profile.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case profile.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case profile.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case profile.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case profile.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case profile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case profile.FieldIntentStatement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntentStatement(v)
		return nil
	case profile.FieldOptionalFields:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionalFields(v)
		return nil
	case profile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldFirstName) {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.FieldCleared(profile.FieldLastName) {
		fields = append(fields, profile.FieldLastName)
	}
	if m.FieldCleared(profile.FieldDateOfBirth) {
		fields = append(fields, profile.FieldDateOfBirth)
	}
	if m.FieldCleared(profile.FieldGender) {
		fields = append(fields, profile.FieldGender)
	}
	if m.FieldCleared(profile.FieldCity) {
		fields = append(fields, profile.FieldCity)
	}
	if m.FieldCleared(profile.FieldBio) {
		fields = append(fields, profile.FieldBio)
	}
	if m.FieldCleared(profile.FieldIntentStatement) {
		fields = append(fields, profile.FieldIntentStatement)
	}
	if m.FieldCleared(profile.FieldOptionalFields) {
		fields = append(fields, profile.FieldOptionalFields)
	}
	if m.FieldCleared(profile.FieldDeletedAt) {
		fields = append(fields, profile.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldFirstName:
		m.ClearFirstName()
		return nil
	case profile.FieldLastName:
		m.ClearLastName()
		return nil
	case profile.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case profile.FieldGender:
		m.ClearGender()
		return nil
	case profile.FieldCity:
		m.ClearCity()
		return nil
	case profile.FieldBio:
		m.ClearBio()
		return nil
	case profile.FieldIntentStatement:
		m.ClearIntentStatement()
		return nil
	case profile.FieldOptionalFields:
		m.ClearOptionalFields()
		return nil
	case profile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldUserID:
		m.ResetUserID()
		return nil
	case profile.FieldFirstName:
		m.ResetFirstName()
		return nil
	case profile.FieldLastName:
		m.ResetLastName()
		return nil
	case profile.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case profile.FieldGender:
		m.ResetGender()
		return nil
	case profile.FieldCity:
		m.ResetCity()
		return nil
	case profile.FieldBio:
		m.ResetBio()
		return nil
	case profile.FieldIntentStatement:
		m.ResetIntentStatement()
		return nil
	case profile.FieldOptionalFields:
		m.ResetOptionalFields()
		return nil
	case profile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// RevealMutation represents an operation that mutates the Reveal nodes in the graph.
type RevealMutation struct {
	config
	op                Op
	typ               string
	id                *string
	unlock_method     *reveal.UnlockMethod
	reveal_status     *reveal.RevealStatus
	created_at        *time.Time
	unlocked_at       *time.Time
	viewed_at         *time.Time
	clearedFields     map[string]struct{}
	connection        *string
	clearedconnection bool
	milestone         *string
	clearedmilestone  bool
	content           *string
	clearedcontent    bool
	done              bool
	oldValue          func(context.Context) (*Reveal, error)
	predicates        []predicate.Reveal
}

var _ ent.Mutation = (*RevealMutation)(nil)

// revealOption allows management of the mutation configuration using functional options.
type revealOption func(*RevealMutation)

// newRevealMutation creates new mutation for the Reveal entity.
func newRevealMutation(c config, op Op, opts ...revealOption) *RevealMutation {
	m := &RevealMutation{
		config:        c,
		op:            op,
		typ:           TypeReveal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevealID sets the ID field of the mutation.
func withRevealID(id string) revealOption {
	return func(m *RevealMutation) {
		var (
			err   error
			once  sync.Once
			value *Reveal
		)
		m.oldValue = func(ctx context.Context) (*Reveal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reveal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReveal sets the old Reveal of the mutation.
func withReveal(node *Reveal) revealOption {
	return func(m *RevealMutation) {
		m.oldValue = func(context.Context) (*Reveal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevealMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevealMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reveal entities.
func (m *RevealMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevealMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevealMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reveal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConnectionID sets the "connection_id" field.
func (m *RevealMutation) SetConnectionID(s string) {
	m.connection = &s
}

// ConnectionID returns the value of the "connection_id" field in the mutation.
func (m *RevealMutation) ConnectionID() (r string, exists bool) {
	v := m.connection
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionID returns the old "connection_id" field's value of the Reveal entity.
// If the Reveal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMutation) OldConnectionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionID: %w", err)
	}
	return oldValue.ConnectionID, nil
}

// ResetConnectionID resets all changes to the "connection_id" field.
func (m *RevealMutation) ResetConnectionID() {
	m.connection = nil
}

// SetMilestoneID sets the "milestone_id" field.
func (m *RevealMutation) SetMilestoneID(s string) {
	m.milestone = &s
}

// MilestoneID returns the value of the "milestone_id" field in the mutation.
func (m *RevealMutation) MilestoneID() (r string, exists bool) {
	v := m.milestone
	if v == nil {
		return
	}
	return *v, true
}

// OldMilestoneID returns the old "milestone_id" field's value of the Reveal entity.
// If the Reveal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMutation) OldMilestoneID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMilestoneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMilestoneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMilestoneID: %w", err)
	}
	return oldValue.MilestoneID, nil
}

// ResetMilestoneID resets all changes to the "milestone_id" field.
func (m *RevealMutation) ResetMilestoneID() {
	m.milestone = nil
}

// SetUnlockMethod sets the "unlock_method" field.
func (m *RevealMutation) SetUnlockMethod(rm reveal.UnlockMethod) {
	m.unlock_method = &rm
}

// UnlockMethod returns the value of the "unlock_method" field in the mutation.
func (m *RevealMutation) UnlockMethod() (r reveal.UnlockMethod, exists bool) {
	v := m.unlock_method
	if v == nil {
		return
	}
	return *v, true
}

// OldUnlockMethod returns the old "unlock_method" field's value of the Reveal entity.
// If the Reveal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMutation) OldUnlockMethod(ctx context.Context) (v reveal.UnlockMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnlockMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnlockMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnlockMethod: %w", err)
	}
	return oldValue.UnlockMethod, nil
}

// ResetUnlockMethod resets all changes to the "unlock_method" field.
func (m *RevealMutation) ResetUnlockMethod() {
	m.unlock_method = nil
}

// SetRevealStatus sets the "reveal_status" field.
func (m *RevealMutation) SetRevealStatus(rs reveal.RevealStatus) {
	m.reveal_status = &rs
}

// RevealStatus returns the value of the "reveal_status" field in the mutation.
func (m *RevealMutation) RevealStatus() (r reveal.RevealStatus, exists bool) {
	v := m.reveal_status
	if v == nil {
		return
	}
	return *v, true
}

// OldRevealStatus returns the old "reveal_status" field's value of the Reveal entity.
// If the Reveal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMutation) OldRevealStatus(ctx context.Context) (v reveal.RevealStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevealStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevealStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevealStatus: %w", err)
	}
	return oldValue.RevealStatus, nil
}

// ResetRevealStatus resets all changes to the "reveal_status" field.
func (m *RevealMutation) ResetRevealStatus() {
	m.reveal_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RevealMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevealMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reveal entity.
// If the Reveal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevealMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUnlockedAt sets the "unlocked_at" field.
func (m *RevealMutation) SetUnlockedAt(t time.Time) {
	m.unlocked_at = &t
}

// UnlockedAt returns the value of the "unlocked_at" field in the mutation.
func (m *RevealMutation) UnlockedAt() (r time.Time, exists bool) {
	v := m.unlocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnlockedAt returns the old "unlocked_at" field's value of the Reveal entity.
// If the Reveal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMutation) OldUnlockedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnlockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnlockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnlockedAt: %w", err)
	}
	return oldValue.UnlockedAt, nil
}

// ClearUnlockedAt clears the value of the "unlocked_at" field.
func (m *RevealMutation) ClearUnlockedAt() {
	m.unlocked_at = nil
	m.clearedFields[reveal.FieldUnlockedAt] = struct{}{}
}

// UnlockedAtCleared returns if the "unlocked_at" field was cleared in this mutation.
func (m *RevealMutation) UnlockedAtCleared() bool {
	_, ok := m.clearedFields[reveal.FieldUnlockedAt]
	return ok
}

// ResetUnlockedAt resets all changes to the "unlocked_at" field.
func (m *RevealMutation) ResetUnlockedAt() {
	m.unlocked_at = nil
	delete(m.clearedFields, reveal.FieldUnlockedAt)
}

// SetViewedAt sets the "viewed_at" field.
func (m *RevealMutation) SetViewedAt(t time.Time) {
	m.viewed_at = &t
}

// ViewedAt returns the value of the "viewed_at" field in the mutation.
func (m *RevealMutation) ViewedAt() (r time.Time, exists bool) {
	v := m.viewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldViewedAt returns the old "viewed_at" field's value of the Reveal entity.
// If the Reveal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMutation) OldViewedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldViewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldViewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldViewedAt: %w", err)
	}
	return oldValue.ViewedAt, nil
}

// ClearViewedAt clears the value of the "viewed_at" field.
func (m *RevealMutation) ClearViewedAt() {
	m.viewed_at = nil
	m.clearedFields[reveal.FieldViewedAt] = struct{}{}
}

// ViewedAtCleared returns if the "viewed_at" field was cleared in this mutation.
func (m *RevealMutation) ViewedAtCleared() bool {
	_, ok := m.clearedFields[reveal.FieldViewedAt]
	return ok
}

// ResetViewedAt resets all changes to the "viewed_at" field.
func (m *RevealMutation) ResetViewedAt() {
	m.viewed_at = nil
	delete(m.clearedFields, reveal.FieldViewedAt)
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *RevealMutation) ClearConnection() {
	m.clearedconnection = true
	m.clearedFields[reveal.FieldConnectionID] = struct{}{}
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *RevealMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *RevealMutation) ConnectionIDs() (ids []string) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *RevealMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// ClearMilestone clears the "milestone" edge to the RevealMilestone entity.
func (m *RevealMutation) ClearMilestone() {
	m.clearedmilestone = true
	m.clearedFields[reveal.FieldMilestoneID] = struct{}{}
}

// MilestoneCleared reports if the "milestone" edge to the RevealMilestone entity was cleared.
func (m *RevealMutation) MilestoneCleared() bool {
	return m.clearedmilestone
}

// MilestoneIDs returns the "milestone" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MilestoneID instead. It exists only for internal usage by the builders.
func (m *RevealMutation) MilestoneIDs() (ids []string) {
	if id := m.milestone; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMilestone resets all changes to the "milestone" edge.
func (m *RevealMutation) ResetMilestone() {
	m.milestone = nil
	m.clearedmilestone = false
}

// SetContentID sets the "content" edge to the RevealContent entity by id.
func (m *RevealMutation) SetContentID(id string) {
	m.content = &id
}

// ClearContent clears the "content" edge to the RevealContent entity.
func (m *RevealMutation) ClearContent() {
	m.clearedcontent = true
}

// ContentCleared reports if the "content" edge to the RevealContent entity was cleared.
func (m *RevealMutation) ContentCleared() bool {
	return m.clearedcontent
}

// ContentID returns the "content" edge ID in the mutation.
func (m *RevealMutation) ContentID() (id string, exists bool) {
	if m.content != nil {
		return *m.content, true
	}
	return
}

// ContentIDs returns the "content" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContentID instead. It exists only for internal usage by the builders.
func (m *RevealMutation) ContentIDs() (ids []string) {
	if id := m.content; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *RevealMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
}

// Where appends a list predicates to the RevealMutation builder.
func (m *RevealMutation) Where(ps ...predicate.Reveal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevealMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevealMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reveal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevealMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevealMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reveal).
func (m *RevealMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevealMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.connection != nil {
		fields = append(fields, reveal.FieldConnectionID)
	}
	if m.milestone != nil {
		fields = append(fields, reveal.FieldMilestoneID)
	}
	if m.unlock_method != nil {
		fields = append(fields, reveal.FieldUnlockMethod)
	}
	if m.reveal_status != nil {
		fields = append(fields, reveal.FieldRevealStatus)
	}
	if m.created_at != nil {
		fields = append(fields, reveal.FieldCreatedAt)
	}
	if m.unlocked_at != nil {
		fields = append(fields, reveal.FieldUnlockedAt)
	}
	if m.viewed_at != nil {
		fields = append(fields, reveal.FieldViewedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevealMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reveal.FieldConnectionID:
		return m.ConnectionID()
	case reveal.FieldMilestoneID:
		return m.MilestoneID()
	case reveal.FieldUnlockMethod:
		return m.UnlockMethod()
	case reveal.FieldRevealStatus:
		return m.RevealStatus()
	case reveal.FieldCreatedAt:
		return m.CreatedAt()
	case reveal.FieldUnlockedAt:
		return m.UnlockedAt()
	case reveal.FieldViewedAt:
		return m.ViewedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevealMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reveal.FieldConnectionID:
		return m.OldConnectionID(ctx)
	case reveal.FieldMilestoneID:
		return m.OldMilestoneID(ctx)
	case reveal.FieldUnlockMethod:
		return m.OldUnlockMethod(ctx)
	case reveal.FieldRevealStatus:
		return m.OldRevealStatus(ctx)
	case reveal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reveal.FieldUnlockedAt:
		return m.OldUnlockedAt(ctx)
	case reveal.FieldViewedAt:
		return m.OldViewedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Reveal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevealMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reveal.FieldConnectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionID(v)
		return nil
	case reveal.FieldMilestoneID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMilestoneID(v)
		return nil
	case reveal.FieldUnlockMethod:
		v, ok := value.(reveal.UnlockMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnlockMethod(v)
		return nil
	case reveal.FieldRevealStatus:
		v, ok := value.(reveal.RevealStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevealStatus(v)
		return nil
	case reveal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reveal.FieldUnlockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnlockedAt(v)
		return nil
	case reveal.FieldViewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetViewedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Reveal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevealMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevealMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevealMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Reveal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevealMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reveal.FieldUnlockedAt) {
		fields = append(fields, reveal.FieldUnlockedAt)
	}
	if m.FieldCleared(reveal.FieldViewedAt) {
		fields = append(fields, reveal.FieldViewedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevealMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevealMutation) ClearField(name string) error {
	switch name {
	case reveal.FieldUnlockedAt:
		m.ClearUnlockedAt()
		return nil
	case reveal.FieldViewedAt:
		m.ClearViewedAt()
		return nil
	}
	return fmt.Errorf("unknown Reveal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevealMutation) ResetField(name string) error {
	switch name {
	case reveal.FieldConnectionID:
		m.ResetConnectionID()
		return nil
	case reveal.FieldMilestoneID:
		m.ResetMilestoneID()
		return nil
	case reveal.FieldUnlockMethod:
		m.ResetUnlockMethod()
		return nil
	case reveal.FieldRevealStatus:
		m.ResetRevealStatus()
		return nil
	case reveal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reveal.FieldUnlockedAt:
		m.ResetUnlockedAt()
		return nil
	case reveal.FieldViewedAt:
		m.ResetViewedAt()
		return nil
	}
	return fmt.Errorf("unknown Reveal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevealMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.connection != nil {
		edges = append(edges, reveal.EdgeConnection)
	}
	if m.milestone != nil {
		edges = append(edges, reveal.EdgeMilestone)
	}
	if m.content != nil {
		edges = append(edges, reveal.EdgeContent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevealMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reveal.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	case reveal.EdgeMilestone:
		if id := m.milestone; id != nil {
			return []ent.Value{*id}
		}
	case reveal.EdgeContent:
		if id := m.content; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevealMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevealMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevealMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedconnection {
		edges = append(edges, reveal.EdgeConnection)
	}
	if m.clearedmilestone {
		edges = append(edges, reveal.EdgeMilestone)
	}
	if m.clearedcontent {
		edges = append(edges, reveal.EdgeContent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevealMutation) EdgeCleared(name string) bool {
	switch name {
	case reveal.EdgeConnection:
		return m.clearedconnection
	case reveal.EdgeMilestone:
		return m.clearedmilestone
	case reveal.EdgeContent:
		return m.clearedcontent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevealMutation) ClearEdge(name string) error {
	switch name {
	case reveal.EdgeConnection:
		m.ClearConnection()
		return nil
	case reveal.EdgeMilestone:
		m.ClearMilestone()
		return nil
	case reveal.EdgeContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Reveal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevealMutation) ResetEdge(name string) error {
	switch name {
	case reveal.EdgeConnection:
		m.ResetConnection()
		return nil
	case reveal.EdgeMilestone:
		m.ResetMilestone()
		return nil
	case reveal.EdgeContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Reveal edge %s", name)
}

// RevealContentMutation represents an operation that mutates the RevealContent nodes in the graph.
type RevealContentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	ai_summary            *string
	compatibility_insight *string
	conversation_starters *string
	dimension_scores      *map[string]interface{}
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	reveal                *string
	clearedreveal         bool
	done                  bool
	oldValue              func(context.Context) (*RevealContent, error)
	predicates            []predicate.RevealContent
}

var _ ent.Mutation = (*RevealContentMutation)(nil)

// revealcontentOption allows management of the mutation configuration using functional options.
type revealcontentOption func(*RevealContentMutation)

// newRevealContentMutation creates new mutation for the RevealContent entity.
func newRevealContentMutation(c config, op Op, opts ...revealcontentOption) *RevealContentMutation {
	m := &RevealContentMutation{
		config:        c,
		op:            op,
		typ:           TypeRevealContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevealContentID sets the ID field of the mutation.
func withRevealContentID(id string) revealcontentOption {
	return func(m *RevealContentMutation) {
		var (
			err   error
			once  sync.Once
			value *RevealContent
		)
		m.oldValue = func(ctx context.Context) (*RevealContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RevealContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevealContent sets the old RevealContent of the mutation.
func withRevealContent(node *RevealContent) revealcontentOption {
	return func(m *RevealContentMutation) {
		m.oldValue = func(context.Context) (*RevealContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevealContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevealContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RevealContent entities.
func (m *RevealContentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevealContentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevealContentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RevealContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevealID sets the "reveal_id" field.
func (m *RevealContentMutation) SetRevealID(s string) {
	m.reveal = &s
}

// RevealID returns the value of the "reveal_id" field in the mutation.
func (m *RevealContentMutation) RevealID() (r string, exists bool) {
	v := m.reveal
	if v == nil {
		return
	}
	return *v, true
}

// OldRevealID returns the old "reveal_id" field's value of the RevealContent entity.
// If the RevealContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealContentMutation) OldRevealID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevealID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevealID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevealID: %w", err)
	}
	return oldValue.RevealID, nil
}

// ResetRevealID resets all changes to the "reveal_id" field.
func (m *RevealContentMutation) ResetRevealID() {
	m.reveal = nil
}

// SetAiSummary sets the "ai_summary" field.
func (m *RevealContentMutation) SetAiSummary(s string) {
	m.ai_summary = &s
}

// AiSummary returns the value of the "ai_summary" field in the mutation.
func (m *RevealContentMutation) AiSummary() (r string, exists bool) {
	v := m.ai_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldAiSummary returns the old "ai_summary" field's value of the RevealContent entity.
// If the RevealContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealContentMutation) OldAiSummary(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiSummary: %w", err)
	}
	return oldValue.AiSummary, nil
}

// ClearAiSummary clears the value of the "ai_summary" field.
func (m *RevealContentMutation) ClearAiSummary() {
	m.ai_summary = nil
	m.clearedFields[revealcontent.FieldAiSummary] = struct{}{}
}

// AiSummaryCleared returns if the "ai_summary" field was cleared in this mutation.
func (m *RevealContentMutation) AiSummaryCleared() bool {
	_, ok := m.clearedFields[revealcontent.FieldAiSummary]
	return ok
}

// ResetAiSummary resets all changes to the "ai_summary" field.
func (m *RevealContentMutation) ResetAiSummary() {
	m.ai_summary = nil
	delete(m.clearedFields, revealcontent.FieldAiSummary)
}

// SetCompatibilityInsight sets the "compatibility_insight" field.
func (m *RevealContentMutation) SetCompatibilityInsight(s string) {
	m.compatibility_insight = &s
}

// CompatibilityInsight returns the value of the "compatibility_insight" field in the mutation.
func (m *RevealContentMutation) CompatibilityInsight() (r string, exists bool) {
	v := m.compatibility_insight
	if v == nil {
		return
	}
	return *v, true
}

// OldCompatibilityInsight returns the old "compatibility_insight" field's value of the RevealContent entity.
// If the RevealContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealContentMutation) OldCompatibilityInsight(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompatibilityInsight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompatibilityInsight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompatibilityInsight: %w", err)
	}
	return oldValue.CompatibilityInsight, nil
}

// ClearCompatibilityInsight clears the value of the "compatibility_insight" field.
func (m *RevealContentMutation) ClearCompatibilityInsight() {
	m.compatibility_insight = nil
	m.clearedFields[revealcontent.FieldCompatibilityInsight] = struct{}{}
}

// CompatibilityInsightCleared returns if the "compatibility_insight" field was cleared in this mutation.
func (m *RevealContentMutation) CompatibilityInsightCleared() bool {
	_, ok := m.clearedFields[revealcontent.FieldCompatibilityInsight]
	return ok
}

// ResetCompatibilityInsight resets all changes to the "compatibility_insight" field.
func (m *RevealContentMutation) ResetCompatibilityInsight() {
	m.compatibility_insight = nil
	delete(m.clearedFields, revealcontent.FieldCompatibilityInsight)
}

// SetConversationStarters sets the "conversation_starters" field.
func (m *RevealContentMutation) SetConversationStarters(s string) {
	m.conversation_starters = &s
}

// ConversationStarters returns the value of the "conversation_starters" field in the mutation.
func (m *RevealContentMutation) ConversationStarters() (r string, exists bool) {
	v := m.conversation_starters
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationStarters returns the old "conversation_starters" field's value of the RevealContent entity.
// If the RevealContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealContentMutation) OldConversationStarters(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationStarters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationStarters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationStarters: %w", err)
	}
	return oldValue.ConversationStarters, nil
}

// ClearConversationStarters clears the value of the "conversation_starters" field.
func (m *RevealContentMutation) ClearConversationStarters() {
	m.conversation_starters = nil
	m.clearedFields[revealcontent.FieldConversationStarters] = struct{}{}
}

// ConversationStartersCleared returns if the "conversation_starters" field was cleared in this mutation.
func (m *RevealContentMutation) ConversationStartersCleared() bool {
	_, ok := m.clearedFields[revealcontent.FieldConversationStarters]
	return ok
}

// ResetConversationStarters resets all changes to the "conversation_starters" field.
func (m *RevealContentMutation) ResetConversationStarters() {
	m.conversation_starters = nil
	delete(m.clearedFields, revealcontent.FieldConversationStarters)
}

// SetDimensionScores sets the "dimension_scores" field.
func (m *RevealContentMutation) SetDimensionScores(value map[string]interface{}) {
	m.dimension_scores = &value
}

// DimensionScores returns the value of the "dimension_scores" field in the mutation.
func (m *RevealContentMutation) DimensionScores() (r map[string]interface{}, exists bool) {
	v := m.dimension_scores
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensionScores returns the old "dimension_scores" field's value of the RevealContent entity.
// If the RevealContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealContentMutation) OldDimensionScores(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensionScores is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensionScores requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensionScores: %w", err)
	}
	return oldValue.DimensionScores, nil
}

// ClearDimensionScores clears the value of the "dimension_scores" field.
func (m *RevealContentMutation) ClearDimensionScores() {
	m.dimension_scores = nil
	m.clearedFields[revealcontent.FieldDimensionScores] = struct{}{}
}

// DimensionScoresCleared returns if the "dimension_scores" field was cleared in this mutation.
func (m *RevealContentMutation) DimensionScoresCleared() bool {
	_, ok := m.clearedFields[revealcontent.FieldDimensionScores]
	return ok
}

// ResetDimensionScores resets all changes to the "dimension_scores" field.
func (m *RevealContentMutation) ResetDimensionScores() {
	m.dimension_scores = nil
	delete(m.clearedFields, revealcontent.FieldDimensionScores)
}

// SetCreatedAt sets the "created_at" field.
func (m *RevealContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevealContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RevealContent entity.
// If the RevealContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevealContentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RevealContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RevealContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RevealContent entity.
// If the RevealContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RevealContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearReveal clears the "reveal" edge to the Reveal entity.
func (m *RevealContentMutation) ClearReveal() {
	m.clearedreveal = true
	m.clearedFields[revealcontent.FieldRevealID] = struct{}{}
}

// RevealCleared reports if the "reveal" edge to the Reveal entity was cleared.
func (m *RevealContentMutation) RevealCleared() bool {
	return m.clearedreveal
}

// RevealIDs returns the "reveal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevealID instead. It exists only for internal usage by the builders.
func (m *RevealContentMutation) RevealIDs() (ids []string) {
	if id := m.reveal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReveal resets all changes to the "reveal" edge.
func (m *RevealContentMutation) ResetReveal() {
	m.reveal = nil
	m.clearedreveal = false
}

// Where appends a list predicates to the RevealContentMutation builder.
func (m *RevealContentMutation) Where(ps ...predicate.RevealContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevealContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevealContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RevealContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevealContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevealContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RevealContent).
func (m *RevealContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevealContentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.reveal != nil {
		fields = append(fields, revealcontent.FieldRevealID)
	}
	if m.ai_summary != nil {
		fields = append(fields, revealcontent.FieldAiSummary)
	}
	if m.compatibility_insight != nil {
		fields = append(fields, revealcontent.FieldCompatibilityInsight)
	}
	if m.conversation_starters != nil {
		fields = append(fields, revealcontent.FieldConversationStarters)
	}
	if m.dimension_scores != nil {
		fields = append(fields, revealcontent.FieldDimensionScores)
	}
	if m.created_at != nil {
		fields = append(fields, revealcontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, revealcontent.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevealContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revealcontent.FieldRevealID:
		return m.RevealID()
	case revealcontent.FieldAiSummary:
		return m.AiSummary()
	case revealcontent.FieldCompatibilityInsight:
		return m.CompatibilityInsight()
	case revealcontent.FieldConversationStarters:
		return m.ConversationStarters()
	case revealcontent.FieldDimensionScores:
		return m.DimensionScores()
	case revealcontent.FieldCreatedAt:
		return m.CreatedAt()
	case revealcontent.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevealContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revealcontent.FieldRevealID:
		return m.OldRevealID(ctx)
	case revealcontent.FieldAiSummary:
		return m.OldAiSummary(ctx)
	case revealcontent.FieldCompatibilityInsight:
		return m.OldCompatibilityInsight(ctx)
	case revealcontent.FieldConversationStarters:
		return m.OldConversationStarters(ctx)
	case revealcontent.FieldDimensionScores:
		return m.OldDimensionScores(ctx)
	case revealcontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case revealcontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RevealContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevealContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revealcontent.FieldRevealID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevealID(v)
		return nil
	case revealcontent.FieldAiSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiSummary(v)
		return nil
	case revealcontent.FieldCompatibilityInsight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompatibilityInsight(v)
		return nil
	case revealcontent.FieldConversationStarters:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationStarters(v)
		return nil
	case revealcontent.FieldDimensionScores:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensionScores(v)
		return nil
	case revealcontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case revealcontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RevealContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevealContentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevealContentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevealContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RevealContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevealContentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revealcontent.FieldAiSummary) {
		fields = append(fields, revealcontent.FieldAiSummary)
	}
	if m.FieldCleared(revealcontent.FieldCompatibilityInsight) {
		fields = append(fields, revealcontent.FieldCompatibilityInsight)
	}
	if m.FieldCleared(revealcontent.FieldConversationStarters) {
		fields = append(fields, revealcontent.FieldConversationStarters)
	}
	if m.FieldCleared(revealcontent.FieldDimensionScores) {
		fields = append(fields, revealcontent.FieldDimensionScores)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevealContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevealContentMutation) ClearField(name string) error {
	switch name {
	case revealcontent.FieldAiSummary:
		m.ClearAiSummary()
		return nil
	case revealcontent.FieldCompatibilityInsight:
		m.ClearCompatibilityInsight()
		return nil
	case revealcontent.FieldConversationStarters:
		m.ClearConversationStarters()
		return nil
	case revealcontent.FieldDimensionScores:
		m.ClearDimensionScores()
		return nil
	}
	return fmt.Errorf("unknown RevealContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevealContentMutation) ResetField(name string) error {
	switch name {
	case revealcontent.FieldRevealID:
		m.ResetRevealID()
		return nil
	case revealcontent.FieldAiSummary:
		m.ResetAiSummary()
		return nil
	case revealcontent.FieldCompatibilityInsight:
		m.ResetCompatibilityInsight()
		return nil
	case revealcontent.FieldConversationStarters:
		m.ResetConversationStarters()
		return nil
	case revealcontent.FieldDimensionScores:
		m.ResetDimensionScores()
		return nil
	case revealcontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case revealcontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown RevealContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevealContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.reveal != nil {
		edges = append(edges, revealcontent.EdgeReveal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevealContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revealcontent.EdgeReveal:
		if id := m.reveal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevealContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevealContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevealContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreveal {
		edges = append(edges, revealcontent.EdgeReveal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevealContentMutation) EdgeCleared(name string) bool {
	switch name {
	case revealcontent.EdgeReveal:
		return m.clearedreveal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevealContentMutation) ClearEdge(name string) error {
	switch name {
	case revealcontent.EdgeReveal:
		m.ClearReveal()
		return nil
	}
	return fmt.Errorf("unknown RevealContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevealContentMutation) ResetEdge(name string) error {
	switch name {
	case revealcontent.EdgeReveal:
		m.ResetReveal()
		return nil
	}
	return fmt.Errorf("unknown RevealContent edge %s", name)
}

// RevealMilestoneMutation represents an operation that mutates the RevealMilestone nodes in the graph.
type RevealMilestoneMutation struct {
	config
	op               Op
	typ              string
	id               *string
	reveal_number    *int
	addreveal_number *int
	day_required     *int
	addday_required  *int
	reveal_type      *revealmilestone.RevealType
	title            *string
	description      *string
	icon_name        *string
	credit_cost      *int
	addcredit_cost   *int
	is_active        *bool
	clearedFields    map[string]struct{}
	reveals          map[string]struct{}
	removedreveals   map[string]struct{}
	clearedreveals   bool
	done             bool
	oldValue         func(context.Context) (*RevealMilestone, error)
	predicates       []predicate.RevealMilestone
}

var _ ent.Mutation = (*RevealMilestoneMutation)(nil)

// revealmilestoneOption allows management of the mutation configuration using functional options.
type revealmilestoneOption func(*RevealMilestoneMutation)

// newRevealMilestoneMutation creates new mutation for the RevealMilestone entity.
func newRevealMilestoneMutation(c config, op Op, opts ...revealmilestoneOption) *RevealMilestoneMutation {
	m := &RevealMilestoneMutation{
		config:        c,
		op:            op,
		typ:           TypeRevealMilestone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevealMilestoneID sets the ID field of the mutation.
func withRevealMilestoneID(id string) revealmilestoneOption {
	return func(m *RevealMilestoneMutation) {
		var (
			err   error
			once  sync.Once
			value *RevealMilestone
		)
		m.oldValue = func(ctx context.Context) (*RevealMilestone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RevealMilestone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevealMilestone sets the old RevealMilestone of the mutation.
func withRevealMilestone(node *RevealMilestone) revealmilestoneOption {
	return func(m *RevealMilestoneMutation) {
		m.oldValue = func(context.Context) (*RevealMilestone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevealMilestoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevealMilestoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RevealMilestone entities.
func (m *RevealMilestoneMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevealMilestoneMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevealMilestoneMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RevealMilestone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRevealNumber sets the "reveal_number" field.
func (m *RevealMilestoneMutation) SetRevealNumber(i int) {
	m.reveal_number = &i
	m.addreveal_number = nil
}

// RevealNumber returns the value of the "reveal_number" field in the mutation.
func (m *RevealMilestoneMutation) RevealNumber() (r int, exists bool) {
	v := m.reveal_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRevealNumber returns the old "reveal_number" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldRevealNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevealNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevealNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevealNumber: %w", err)
	}
	return oldValue.RevealNumber, nil
}

// AddRevealNumber adds i to the "reveal_number" field.
func (m *RevealMilestoneMutation) AddRevealNumber(i int) {
	if m.addreveal_number != nil {
		*m.addreveal_number += i
	} else {
		m.addreveal_number = &i
	}
}

// AddedRevealNumber returns the value that was added to the "reveal_number" field in this mutation.
func (m *RevealMilestoneMutation) AddedRevealNumber() (r int, exists bool) {
	v := m.addreveal_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevealNumber resets all changes to the "reveal_number" field.
func (m *RevealMilestoneMutation) ResetRevealNumber() {
	m.reveal_number = nil
	m.addreveal_number = nil
}

// SetDayRequired sets the "day_required" field.
func (m *RevealMilestoneMutation) SetDayRequired(i int) {
	m.day_required = &i
	m.addday_required = nil
}

// DayRequired returns the value of the "day_required" field in the mutation.
func (m *RevealMilestoneMutation) DayRequired() (r int, exists bool) {
	v := m.day_required
	if v == nil {
		return
	}
	return *v, true
}

// OldDayRequired returns the old "day_required" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldDayRequired(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayRequired: %w", err)
	}
	return oldValue.DayRequired, nil
}

// AddDayRequired adds i to the "day_required" field.
func (m *RevealMilestoneMutation) AddDayRequired(i int) {
	if m.addday_required != nil {
		*m.addday_required += i
	} else {
		m.addday_required = &i
	}
}

// AddedDayRequired returns the value that was added to the "day_required" field in this mutation.
func (m *RevealMilestoneMutation) AddedDayRequired() (r int, exists bool) {
	v := m.addday_required
	if v == nil {
		return
	}
	return *v, true
}

// ResetDayRequired resets all changes to the "day_required" field.
func (m *RevealMilestoneMutation) ResetDayRequired() {
	m.day_required = nil
	m.addday_required = nil
}

// SetRevealType sets the "reveal_type" field.
func (m *RevealMilestoneMutation) SetRevealType(rt revealmilestone.RevealType) {
	m.reveal_type = &rt
}

// RevealType returns the value of the "reveal_type" field in the mutation.
func (m *RevealMilestoneMutation) RevealType() (r revealmilestone.RevealType, exists bool) {
	v := m.reveal_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRevealType returns the old "reveal_type" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldRevealType(ctx context.Context) (v revealmilestone.RevealType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevealType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevealType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevealType: %w", err)
	}
	return oldValue.RevealType, nil
}

// ResetRevealType resets all changes to the "reveal_type" field.
func (m *RevealMilestoneMutation) ResetRevealType() {
	m.reveal_type = nil
}

// SetTitle sets the "title" field.
func (m *RevealMilestoneMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *RevealMilestoneMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *RevealMilestoneMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *RevealMilestoneMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RevealMilestoneMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RevealMilestoneMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[revealmilestone.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RevealMilestoneMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[revealmilestone.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RevealMilestoneMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, revealmilestone.FieldDescription)
}

// SetIconName sets the "icon_name" field.
func (m *RevealMilestoneMutation) SetIconName(s string) {
	m.icon_name = &s
}

// IconName returns the value of the "icon_name" field in the mutation.
func (m *RevealMilestoneMutation) IconName() (r string, exists bool) {
	v := m.icon_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIconName returns the old "icon_name" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldIconName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconName: %w", err)
	}
	return oldValue.IconName, nil
}

// ClearIconName clears the value of the "icon_name" field.
func (m *RevealMilestoneMutation) ClearIconName() {
	m.icon_name = nil
	m.clearedFields[revealmilestone.FieldIconName] = struct{}{}
}

// IconNameCleared returns if the "icon_name" field was cleared in this mutation.
func (m *RevealMilestoneMutation) IconNameCleared() bool {
	_, ok := m.clearedFields[revealmilestone.FieldIconName]
	return ok
}

// ResetIconName resets all changes to the "icon_name" field.
func (m *RevealMilestoneMutation) ResetIconName() {
	m.icon_name = nil
	delete(m.clearedFields, revealmilestone.FieldIconName)
}

// SetCreditCost sets the "credit_cost" field.
func (m *RevealMilestoneMutation) SetCreditCost(i int) {
	m.credit_cost = &i
	m.addcredit_cost = nil
}

// CreditCost returns the value of the "credit_cost" field in the mutation.
func (m *RevealMilestoneMutation) CreditCost() (r int, exists bool) {
	v := m.credit_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditCost returns the old "credit_cost" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldCreditCost(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditCost: %w", err)
	}
	return oldValue.CreditCost, nil
}

// AddCreditCost adds i to the "credit_cost" field.
func (m *RevealMilestoneMutation) AddCreditCost(i int) {
	if m.addcredit_cost != nil {
		*m.addcredit_cost += i
	} else {
		m.addcredit_cost = &i
	}
}

// AddedCreditCost returns the value that was added to the "credit_cost" field in this mutation.
func (m *RevealMilestoneMutation) AddedCreditCost() (r int, exists bool) {
	v := m.addcredit_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditCost resets all changes to the "credit_cost" field.
func (m *RevealMilestoneMutation) ResetCreditCost() {
	m.credit_cost = nil
	m.addcredit_cost = nil
}

// SetIsActive sets the "is_active" field.
func (m *RevealMilestoneMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *RevealMilestoneMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the RevealMilestone entity.
// If the RevealMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevealMilestoneMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *RevealMilestoneMutation) ResetIsActive() {
	m.is_active = nil
}

// AddRevealIDs adds the "reveals" edge to the Reveal entity by ids.
func (m *RevealMilestoneMutation) AddRevealIDs(ids ...string) {
	if m.reveals == nil {
		m.reveals = make(map[string]struct{})
	}
	for i := range ids {
		m.reveals[ids[i]] = struct{}{}
	}
}

// ClearReveals clears the "reveals" edge to the Reveal entity.
func (m *RevealMilestoneMutation) ClearReveals() {
	m.clearedreveals = true
}

// RevealsCleared reports if the "reveals" edge to the Reveal entity was cleared.
func (m *RevealMilestoneMutation) RevealsCleared() bool {
	return m.clearedreveals
}

// RemoveRevealIDs removes the "reveals" edge to the Reveal entity by IDs.
func (m *RevealMilestoneMutation) RemoveRevealIDs(ids ...string) {
	if m.removedreveals == nil {
		m.removedreveals = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reveals, ids[i])
		m.removedreveals[ids[i]] = struct{}{}
	}
}

// RemovedReveals returns the removed IDs of the "reveals" edge to the Reveal entity.
func (m *RevealMilestoneMutation) RemovedRevealsIDs() (ids []string) {
	for id := range m.removedreveals {
		ids = append(ids, id)
	}
	return
}

// RevealsIDs returns the "reveals" edge IDs in the mutation.
func (m *RevealMilestoneMutation) RevealsIDs() (ids []string) {
	for id := range m.reveals {
		ids = append(ids, id)
	}
	return
}

// ResetReveals resets all changes to the "reveals" edge.
func (m *RevealMilestoneMutation) ResetReveals() {
	m.reveals = nil
	m.clearedreveals = false
	m.removedreveals = nil
}

// Where appends a list predicates to the RevealMilestoneMutation builder.
func (m *RevealMilestoneMutation) Where(ps ...predicate.RevealMilestone) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevealMilestoneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevealMilestoneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RevealMilestone, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevealMilestoneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevealMilestoneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RevealMilestone).
func (m *RevealMilestoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevealMilestoneMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.reveal_number != nil {
		fields = append(fields, revealmilestone.FieldRevealNumber)
	}
	if m.day_required != nil {
		fields = append(fields, revealmilestone.FieldDayRequired)
	}
	if m.reveal_type != nil {
		fields = append(fields, revealmilestone.FieldRevealType)
	}
	if m.title != nil {
		fields = append(fields, revealmilestone.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, revealmilestone.FieldDescription)
	}
	if m.icon_name != nil {
		fields = append(fields, revealmilestone.FieldIconName)
	}
	if m.credit_cost != nil {
		fields = append(fields, revealmilestone.FieldCreditCost)
	}
	if m.is_active != nil {
		fields = append(fields, revealmilestone.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevealMilestoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revealmilestone.FieldRevealNumber:
		return m.RevealNumber()
	case revealmilestone.FieldDayRequired:
		return m.DayRequired()
	case revealmilestone.FieldRevealType:
		return m.RevealType()
	case revealmilestone.FieldTitle:
		return m.Title()
	case revealmilestone.FieldDescription:
		return m.Description()
	case revealmilestone.FieldIconName:
		return m.IconName()
	case revealmilestone.FieldCreditCost:
		return m.CreditCost()
	case revealmilestone.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevealMilestoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revealmilestone.FieldRevealNumber:
		return m.OldRevealNumber(ctx)
	case revealmilestone.FieldDayRequired:
		return m.OldDayRequired(ctx)
	case revealmilestone.FieldRevealType:
		return m.OldRevealType(ctx)
	case revealmilestone.FieldTitle:
		return m.OldTitle(ctx)
	case revealmilestone.FieldDescription:
		return m.OldDescription(ctx)
	case revealmilestone.FieldIconName:
		return m.OldIconName(ctx)
	case revealmilestone.FieldCreditCost:
		return m.OldCreditCost(ctx)
	case revealmilestone.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown RevealMilestone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevealMilestoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revealmilestone.FieldRevealNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevealNumber(v)
		return nil
	case revealmilestone.FieldDayRequired:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayRequired(v)
		return nil
	case revealmilestone.FieldRevealType:
		v, ok := value.(revealmilestone.RevealType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevealType(v)
		return nil
	case revealmilestone.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case revealmilestone.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case revealmilestone.FieldIconName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconName(v)
		return nil
	case revealmilestone.FieldCreditCost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditCost(v)
		return nil
	case revealmilestone.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown RevealMilestone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevealMilestoneMutation) AddedFields() []string {
	var fields []string
	if m.addreveal_number != nil {
		fields = append(fields, revealmilestone.FieldRevealNumber)
	}
	if m.addday_required != nil {
		fields = append(fields, revealmilestone.FieldDayRequired)
	}
	if m.addcredit_cost != nil {
		fields = append(fields, revealmilestone.FieldCreditCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevealMilestoneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case revealmilestone.FieldRevealNumber:
		return m.AddedRevealNumber()
	case revealmilestone.FieldDayRequired:
		return m.AddedDayRequired()
	case revealmilestone.FieldCreditCost:
		return m.AddedCreditCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevealMilestoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case revealmilestone.FieldRevealNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevealNumber(v)
		return nil
	case revealmilestone.FieldDayRequired:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDayRequired(v)
		return nil
	case revealmilestone.FieldCreditCost:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditCost(v)
		return nil
	}
	return fmt.Errorf("unknown RevealMilestone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevealMilestoneMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revealmilestone.FieldDescription) {
		fields = append(fields, revealmilestone.FieldDescription)
	}
	if m.FieldCleared(revealmilestone.FieldIconName) {
		fields = append(fields, revealmilestone.FieldIconName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevealMilestoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevealMilestoneMutation) ClearField(name string) error {
	switch name {
	case revealmilestone.FieldDescription:
		m.ClearDescription()
		return nil
	case revealmilestone.FieldIconName:
		m.ClearIconName()
		return nil
	}
	return fmt.Errorf("unknown RevealMilestone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevealMilestoneMutation) ResetField(name string) error {
	switch name {
	case revealmilestone.FieldRevealNumber:
		m.ResetRevealNumber()
		return nil
	case revealmilestone.FieldDayRequired:
		m.ResetDayRequired()
		return nil
	case revealmilestone.FieldRevealType:
		m.ResetRevealType()
		return nil
	case revealmilestone.FieldTitle:
		m.ResetTitle()
		return nil
	case revealmilestone.FieldDescription:
		m.ResetDescription()
		return nil
	case revealmilestone.FieldIconName:
		m.ResetIconName()
		return nil
	case revealmilestone.FieldCreditCost:
		m.ResetCreditCost()
		return nil
	case revealmilestone.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown RevealMilestone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevealMilestoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.reveals != nil {
		edges = append(edges, revealmilestone.EdgeReveals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevealMilestoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revealmilestone.EdgeReveals:
		ids := make([]ent.Value, 0, len(m.reveals))
		for id := range m.reveals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevealMilestoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedreveals != nil {
		edges = append(edges, revealmilestone.EdgeReveals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevealMilestoneMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case revealmilestone.EdgeReveals:
		ids := make([]ent.Value, 0, len(m.removedreveals))
		for id := range m.removedreveals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevealMilestoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreveals {
		edges = append(edges, revealmilestone.EdgeReveals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevealMilestoneMutation) EdgeCleared(name string) bool {
	switch name {
	case revealmilestone.EdgeReveals:
		return m.clearedreveals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevealMilestoneMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RevealMilestone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevealMilestoneMutation) ResetEdge(name string) error {
	switch name {
	case revealmilestone.EdgeReveals:
		m.ResetReveals()
		return nil
	}
	return fmt.Errorf("unknown RevealMilestone edge %s", name)
}

// ServerMutation represents an operation that mutates the Server nodes in the graph.
type ServerMutation struct {
	config
	op            Op
	typ           string
	id            *string
	server_type   *server.ServerType
	display_name  *string
	icon_name     *string
	sort_order    *int
	addsort_order *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Server, error)
	predicates    []predicate.Server
}

var _ ent.Mutation = (*ServerMutation)(nil)

// serverOption allows management of the mutation configuration using functional options.
type serverOption func(*ServerMutation)

// newServerMutation creates new mutation for the Server entity.
func newServerMutation(c config, op Op, opts ...serverOption) *ServerMutation {
	m := &ServerMutation{
		config:        c,
		op:            op,
		typ:           TypeServer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServerID sets the ID field of the mutation.
func withServerID(id string) serverOption {
	return func(m *ServerMutation) {
		var (
			err   error
			once  sync.Once
			value *Server
		)
		m.oldValue = func(ctx context.Context) (*Server, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Server.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServer sets the old Server of the mutation.
func withServer(node *Server) serverOption {
	return func(m *ServerMutation) {
		m.oldValue = func(context.Context) (*Server, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Server entities.
func (m *ServerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Server.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetServerType sets the "server_type" field.
func (m *ServerMutation) SetServerType(st server.ServerType) {
	m.server_type = &st
}

// ServerType returns the value of the "server_type" field in the mutation.
func (m *ServerMutation) ServerType() (r server.ServerType, exists bool) {
	v := m.server_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServerType returns the old "server_type" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldServerType(ctx context.Context) (v server.ServerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerType: %w", err)
	}
	return oldValue.ServerType, nil
}

// ResetServerType resets all changes to the "server_type" field.
func (m *ServerMutation) ResetServerType() {
	m.server_type = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ServerMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ServerMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ServerMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetIconName sets the "icon_name" field.
func (m *ServerMutation) SetIconName(s string) {
	m.icon_name = &s
}

// IconName returns the value of the "icon_name" field in the mutation.
func (m *ServerMutation) IconName() (r string, exists bool) {
	v := m.icon_name
	if v == nil {
		return
	}
	return *v, true
}

// OldIconName returns the old "icon_name" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldIconName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconName: %w", err)
	}
	return oldValue.IconName, nil
}

// ResetIconName resets all changes to the "icon_name" field.
func (m *ServerMutation) ResetIconName() {
	m.icon_name = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *ServerMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *ServerMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Server entity.
// If the Server object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServerMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *ServerMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *ServerMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *ServerMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// Where appends a list predicates to the ServerMutation builder.
func (m *ServerMutation) Where(ps ...predicate.Server) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Server, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Server).
func (m *ServerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.server_type != nil {
		fields = append(fields, server.FieldServerType)
	}
	if m.display_name != nil {
		fields = append(fields, server.FieldDisplayName)
	}
	if m.icon_name != nil {
		fields = append(fields, server.FieldIconName)
	}
	if m.sort_order != nil {
		fields = append(fields, server.FieldSortOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case server.FieldServerType:
		return m.ServerType()
	case server.FieldDisplayName:
		return m.DisplayName()
	case server.FieldIconName:
		return m.IconName()
	case server.FieldSortOrder:
		return m.SortOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case server.FieldServerType:
		return m.OldServerType(ctx)
	case server.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case server.FieldIconName:
		return m.OldIconName(ctx)
	case server.FieldSortOrder:
		return m.OldSortOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Server field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case server.FieldServerType:
		v, ok := value.(server.ServerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerType(v)
		return nil
	case server.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case server.FieldIconName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconName(v)
		return nil
	case server.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServerMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, server.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case server.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case server.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Server numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Server nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServerMutation) ResetField(name string) error {
	switch name {
	case server.FieldServerType:
		m.ResetServerType()
		return nil
	case server.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case server.FieldIconName:
		m.ResetIconName()
		return nil
	case server.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	}
	return fmt.Errorf("unknown Server field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Server unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Server edge %s", name)
}

// StreakMutation represents an operation that mutates the Streak nodes in the graph.
type StreakMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	streak_state           *streak.StreakState
	current_day            *int
	addcurrent_day         *int
	reset_count            *int
	addreset_count         *int
	recovery_deadline_at   *time.Time
	recovery_payment_id    *string
	streak_health_score    *float64
	addstreak_health_score *float64
	created_at             *time.Time
	updated_at             *time.Time
	completed_at           *time.Time
	deleted_at             *time.Time
	clearedFields          map[string]struct{}
	connection             *string
	clearedconnection      bool
	breaker                *string
	clearedbreaker         bool
	check_ins              map[string]struct{}
	removedcheck_ins       map[string]struct{}
	clearedcheck_ins       bool
	nudges                 map[string]struct{}
	removednudges          map[string]struct{}
	clearednudges          bool
	done                   bool
	oldValue               func(context.Context) (*Streak, error)
	predicates             []predicate.Streak
}

var _ ent.Mutation = (*StreakMutation)(nil)

// streakOption allows management of the mutation configuration using functional options.
type streakOption func(*StreakMutation)

// newStreakMutation creates new mutation for the Streak entity.
func newStreakMutation(c config, op Op, opts ...streakOption) *StreakMutation {
	m := &StreakMutation{
		config:        c,
		op:            op,
		typ:           TypeStreak,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStreakID sets the ID field of the mutation.
func withStreakID(id string) streakOption {
	return func(m *StreakMutation) {
		var (
			err   error
			once  sync.Once
			value *Streak
		)
		m.oldValue = func(ctx context.Context) (*Streak, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Streak.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStreak sets the old Streak of the mutation.
func withStreak(node *Streak) streakOption {
	return func(m *StreakMutation) {
		m.oldValue = func(context.Context) (*Streak, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StreakMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StreakMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Streak entities.
func (m *StreakMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StreakMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StreakMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Streak.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConnectionID sets the "connection_id" field.
func (m *StreakMutation) SetConnectionID(s string) {
	m.connection = &s
}

// ConnectionID returns the value of the "connection_id" field in the mutation.
func (m *StreakMutation) ConnectionID() (r string, exists bool) {
	v := m.connection
	if v == nil {
		return
	}
	return *v, true
}

// OldConnectionID returns the old "connection_id" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldConnectionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConnectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConnectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConnectionID: %w", err)
	}
	return oldValue.ConnectionID, nil
}

// ResetConnectionID resets all changes to the "connection_id" field.
func (m *StreakMutation) ResetConnectionID() {
	m.connection = nil
}

// SetStreakState sets the "streak_state" field.
func (m *StreakMutation) SetStreakState(ss streak.StreakState) {
	m.streak_state = &ss
}

// StreakState returns the value of the "streak_state" field in the mutation.
func (m *StreakMutation) StreakState() (r streak.StreakState, exists bool) {
	v := m.streak_state
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakState returns the old "streak_state" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldStreakState(ctx context.Context) (v streak.StreakState, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakState: %w", err)
	}
	return oldValue.StreakState, nil
}

// ResetStreakState resets all changes to the "streak_state" field.
func (m *StreakMutation) ResetStreakState() {
	m.streak_state = nil
}

// SetCurrentDay sets the "current_day" field.
func (m *StreakMutation) SetCurrentDay(i int) {
	m.current_day = &i
	m.addcurrent_day = nil
}

// CurrentDay returns the value of the "current_day" field in the mutation.
func (m *StreakMutation) CurrentDay() (r int, exists bool) {
	v := m.current_day
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentDay returns the old "current_day" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldCurrentDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentDay: %w", err)
	}
	return oldValue.CurrentDay, nil
}

// AddCurrentDay adds i to the "current_day" field.
func (m *StreakMutation) AddCurrentDay(i int) {
	if m.addcurrent_day != nil {
		*m.addcurrent_day += i
	} else {
		m.addcurrent_day = &i
	}
}

// AddedCurrentDay returns the value that was added to the "current_day" field in this mutation.
func (m *StreakMutation) AddedCurrentDay() (r int, exists bool) {
	v := m.addcurrent_day
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentDay resets all changes to the "current_day" field.
func (m *StreakMutation) ResetCurrentDay() {
	m.current_day = nil
	m.addcurrent_day = nil
}

// SetResetCount sets the "reset_count" field.
func (m *StreakMutation) SetResetCount(i int) {
	m.reset_count = &i
	m.addreset_count = nil
}

// ResetCount returns the value of the "reset_count" field in the mutation.
func (m *StreakMutation) ResetCount() (r int, exists bool) {
	v := m.reset_count
	if v == nil {
		return
	}
	return *v, true
}

// OldResetCount returns the old "reset_count" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldResetCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResetCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResetCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResetCount: %w", err)
	}
	return oldValue.ResetCount, nil
}

// AddResetCount adds i to the "reset_count" field.
func (m *StreakMutation) AddResetCount(i int) {
	if m.addreset_count != nil {
		*m.addreset_count += i
	} else {
		m.addreset_count = &i
	}
}

// AddedResetCount returns the value that was added to the "reset_count" field in this mutation.
func (m *StreakMutation) AddedResetCount() (r int, exists bool) {
	v := m.addreset_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetResetCount resets all changes to the "reset_count" field.
func (m *StreakMutation) ResetResetCount() {
	m.reset_count = nil
	m.addreset_count = nil
}

// SetBreakerUserID sets the "breaker_user_id" field.
func (m *StreakMutation) SetBreakerUserID(s string) {
	m.breaker = &s
}

// BreakerUserID returns the value of the "breaker_user_id" field in the mutation.
func (m *StreakMutation) BreakerUserID() (r string, exists bool) {
	v := m.breaker
	if v == nil {
		return
	}
	return *v, true
}

// OldBreakerUserID returns the old "breaker_user_id" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldBreakerUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreakerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreakerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreakerUserID: %w", err)
	}
	return oldValue.BreakerUserID, nil
}

// ClearBreakerUserID clears the value of the "breaker_user_id" field.
func (m *StreakMutation) ClearBreakerUserID() {
	m.breaker = nil
	m.clearedFields[streak.FieldBreakerUserID] = struct{}{}
}

// BreakerUserIDCleared returns if the "breaker_user_id" field was cleared in this mutation.
func (m *StreakMutation) BreakerUserIDCleared() bool {
	_, ok := m.clearedFields[streak.FieldBreakerUserID]
	return ok
}

// ResetBreakerUserID resets all changes to the "breaker_user_id" field.
func (m *StreakMutation) ResetBreakerUserID() {
	m.breaker = nil
	delete(m.clearedFields, streak.FieldBreakerUserID)
}

// SetRecoveryDeadlineAt sets the "recovery_deadline_at" field.
func (m *StreakMutation) SetRecoveryDeadlineAt(t time.Time) {
	m.recovery_deadline_at = &t
}

// RecoveryDeadlineAt returns the value of the "recovery_deadline_at" field in the mutation.
func (m *StreakMutation) RecoveryDeadlineAt() (r time.Time, exists bool) {
	v := m.recovery_deadline_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRecoveryDeadlineAt returns the old "recovery_deadline_at" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldRecoveryDeadlineAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecoveryDeadlineAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecoveryDeadlineAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecoveryDeadlineAt: %w", err)
	}
	return oldValue.RecoveryDeadlineAt, nil
}

// ClearRecoveryDeadlineAt clears the value of the "recovery_deadline_at" field.
func (m *StreakMutation) ClearRecoveryDeadlineAt() {
	m.recovery_deadline_at = nil
	m.clearedFields[streak.FieldRecoveryDeadlineAt] = struct{}{}
}

// RecoveryDeadlineAtCleared returns if the "recovery_deadline_at" field was cleared in this mutation.
func (m *StreakMutation) RecoveryDeadlineAtCleared() bool {
	_, ok := m.clearedFields[streak.FieldRecoveryDeadlineAt]
	return ok
}

// ResetRecoveryDeadlineAt resets all changes to the "recovery_deadline_at" field.
func (m *StreakMutation) ResetRecoveryDeadlineAt() {
	m.recovery_deadline_at = nil
	delete(m.clearedFields, streak.FieldRecoveryDeadlineAt)
}

// SetRecoveryPaymentID sets the "recovery_payment_id" field.
func (m *StreakMutation) SetRecoveryPaymentID(s string) {
	m.recovery_payment_id = &s
}

// RecoveryPaymentID returns the value of the "recovery_payment_id" field in the mutation.
func (m *StreakMutation) RecoveryPaymentID() (r string, exists bool) {
	v := m.recovery_payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecoveryPaymentID returns the old "recovery_payment_id" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldRecoveryPaymentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecoveryPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecoveryPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecoveryPaymentID: %w", err)
	}
	return oldValue.RecoveryPaymentID, nil
}

// ClearRecoveryPaymentID clears the value of the "recovery_payment_id" field.
func (m *StreakMutation) ClearRecoveryPaymentID() {
	m.recovery_payment_id = nil
	m.clearedFields[streak.FieldRecoveryPaymentID] = struct{}{}
}

// RecoveryPaymentIDCleared returns if the "recovery_payment_id" field was cleared in this mutation.
func (m *StreakMutation) RecoveryPaymentIDCleared() bool {
	_, ok := m.clearedFields[streak.FieldRecoveryPaymentID]
	return ok
}

// ResetRecoveryPaymentID resets all changes to the "recovery_payment_id" field.
func (m *StreakMutation) ResetRecoveryPaymentID() {
	m.recovery_payment_id = nil
	delete(m.clearedFields, streak.FieldRecoveryPaymentID)
}

// SetStreakHealthScore sets the "streak_health_score" field.
func (m *StreakMutation) SetStreakHealthScore(f float64) {
	m.streak_health_score = &f
	m.addstreak_health_score = nil
}

// StreakHealthScore returns the value of the "streak_health_score" field in the mutation.
func (m *StreakMutation) StreakHealthScore() (r float64, exists bool) {
	v := m.streak_health_score
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakHealthScore returns the old "streak_health_score" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldStreakHealthScore(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakHealthScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakHealthScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakHealthScore: %w", err)
	}
	return oldValue.StreakHealthScore, nil
}

// AddStreakHealthScore adds f to the "streak_health_score" field.
func (m *StreakMutation) AddStreakHealthScore(f float64) {
	if m.addstreak_health_score != nil {
		*m.addstreak_health_score += f
	} else {
		m.addstreak_health_score = &f
	}
}

// AddedStreakHealthScore returns the value that was added to the "streak_health_score" field in this mutation.
func (m *StreakMutation) AddedStreakHealthScore() (r float64, exists bool) {
	v := m.addstreak_health_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearStreakHealthScore clears the value of the "streak_health_score" field.
func (m *StreakMutation) ClearStreakHealthScore() {
	m.streak_health_score = nil
	m.addstreak_health_score = nil
	m.clearedFields[streak.FieldStreakHealthScore] = struct{}{}
}

// StreakHealthScoreCleared returns if the "streak_health_score" field was cleared in this mutation.
func (m *StreakMutation) StreakHealthScoreCleared() bool {
	_, ok := m.clearedFields[streak.FieldStreakHealthScore]
	return ok
}

// ResetStreakHealthScore resets all changes to the "streak_health_score" field.
func (m *StreakMutation) ResetStreakHealthScore() {
	m.streak_health_score = nil
	m.addstreak_health_score = nil
	delete(m.clearedFields, streak.FieldStreakHealthScore)
}

// SetCreatedAt sets the "created_at" field.
func (m *StreakMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StreakMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StreakMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StreakMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StreakMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StreakMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCompletedAt sets the "completed_at" field.
func (m *StreakMutation) SetCompletedAt(t time.Time) {
	m.completed_at = &t
}

// CompletedAt returns the value of the "completed_at" field in the mutation.
func (m *StreakMutation) CompletedAt() (r time.Time, exists bool) {
	v := m.completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletedAt returns the old "completed_at" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletedAt: %w", err)
	}
	return oldValue.CompletedAt, nil
}

// ClearCompletedAt clears the value of the "completed_at" field.
func (m *StreakMutation) ClearCompletedAt() {
	m.completed_at = nil
	m.clearedFields[streak.FieldCompletedAt] = struct{}{}
}

// CompletedAtCleared returns if the "completed_at" field was cleared in this mutation.
func (m *StreakMutation) CompletedAtCleared() bool {
	_, ok := m.clearedFields[streak.FieldCompletedAt]
	return ok
}

// ResetCompletedAt resets all changes to the "completed_at" field.
func (m *StreakMutation) ResetCompletedAt() {
	m.completed_at = nil
	delete(m.clearedFields, streak.FieldCompletedAt)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StreakMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StreakMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Streak entity.
// If the Streak object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreakMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StreakMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[streak.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StreakMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[streak.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StreakMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, streak.FieldDeletedAt)
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *StreakMutation) ClearConnection() {
	m.clearedconnection = true
	m.clearedFields[streak.FieldConnectionID] = struct{}{}
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *StreakMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *StreakMutation) ConnectionIDs() (ids []string) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *StreakMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// SetBreakerID sets the "breaker" edge to the User entity by id.
func (m *StreakMutation) SetBreakerID(id string) {
	m.breaker = &id
}

// ClearBreaker clears the "breaker" edge to the User entity.
func (m *StreakMutation) ClearBreaker() {
	m.clearedbreaker = true
	m.clearedFields[streak.FieldBreakerUserID] = struct{}{}
}

// BreakerCleared reports if the "breaker" edge to the User entity was cleared.
func (m *StreakMutation) BreakerCleared() bool {
	return m.BreakerUserIDCleared() || m.clearedbreaker
}

// BreakerID returns the "breaker" edge ID in the mutation.
func (m *StreakMutation) BreakerID() (id string, exists bool) {
	if m.breaker != nil {
		return *m.breaker, true
	}
	return
}

// BreakerIDs returns the "breaker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BreakerID instead. It exists only for internal usage by the builders.
func (m *StreakMutation) BreakerIDs() (ids []string) {
	if id := m.breaker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBreaker resets all changes to the "breaker" edge.
func (m *StreakMutation) ResetBreaker() {
	m.breaker = nil
	m.clearedbreaker = false
}

// AddCheckInIDs adds the "check_ins" edge to the CheckIn entity by ids.
func (m *StreakMutation) AddCheckInIDs(ids ...string) {
	if m.check_ins == nil {
		m.check_ins = make(map[string]struct{})
	}
	for i := range ids {
		m.check_ins[ids[i]] = struct{}{}
	}
}

// ClearCheckIns clears the "check_ins" edge to the CheckIn entity.
func (m *StreakMutation) ClearCheckIns() {
	m.clearedcheck_ins = true
}

// CheckInsCleared reports if the "check_ins" edge to the CheckIn entity was cleared.
func (m *StreakMutation) CheckInsCleared() bool {
	return m.clearedcheck_ins
}

// RemoveCheckInIDs removes the "check_ins" edge to the CheckIn entity by IDs.
func (m *StreakMutation) RemoveCheckInIDs(ids ...string) {
	if m.removedcheck_ins == nil {
		m.removedcheck_ins = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.check_ins, ids[i])
		m.removedcheck_ins[ids[i]] = struct{}{}
	}
}

// RemovedCheckIns returns the removed IDs of the "check_ins" edge to the CheckIn entity.
func (m *StreakMutation) RemovedCheckInsIDs() (ids []string) {
	for id := range m.removedcheck_ins {
		ids = append(ids, id)
	}
	return
}

// CheckInsIDs returns the "check_ins" edge IDs in the mutation.
func (m *StreakMutation) CheckInsIDs() (ids []string) {
	for id := range m.check_ins {
		ids = append(ids, id)
	}
	return
}

// ResetCheckIns resets all changes to the "check_ins" edge.
func (m *StreakMutation) ResetCheckIns() {
	m.check_ins = nil
	m.clearedcheck_ins = false
	m.removedcheck_ins = nil
}

// AddNudgeIDs adds the "nudges" edge to the Nudge entity by ids.
func (m *StreakMutation) AddNudgeIDs(ids ...string) {
	if m.nudges == nil {
		m.nudges = make(map[string]struct{})
	}
	for i := range ids {
		m.nudges[ids[i]] = struct{}{}
	}
}

// ClearNudges clears the "nudges" edge to the Nudge entity.
func (m *StreakMutation) ClearNudges() {
	m.clearednudges = true
}

// NudgesCleared reports if the "nudges" edge to the Nudge entity was cleared.
func (m *StreakMutation) NudgesCleared() bool {
	return m.clearednudges
}

// RemoveNudgeIDs removes the "nudges" edge to the Nudge entity by IDs.
func (m *StreakMutation) RemoveNudgeIDs(ids ...string) {
	if m.removednudges == nil {
		m.removednudges = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.nudges, ids[i])
		m.removednudges[ids[i]] = struct{}{}
	}
}

// RemovedNudges returns the removed IDs of the "nudges" edge to the Nudge entity.
func (m *StreakMutation) RemovedNudgesIDs() (ids []string) {
	for id := range m.removednudges {
		ids = append(ids, id)
	}
	return
}

// NudgesIDs returns the "nudges" edge IDs in the mutation.
func (m *StreakMutation) NudgesIDs() (ids []string) {
	for id := range m.nudges {
		ids = append(ids, id)
	}
	return
}

// ResetNudges resets all changes to the "nudges" edge.
func (m *StreakMutation) ResetNudges() {
	m.nudges = nil
	m.clearednudges = false
	m.removednudges = nil
}

// Where appends a list predicates to the StreakMutation builder.
func (m *StreakMutation) Where(ps ...predicate.Streak) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StreakMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StreakMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Streak, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StreakMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StreakMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Streak).
func (m *StreakMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StreakMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.connection != nil {
		fields = append(fields, streak.FieldConnectionID)
	}
	if m.streak_state != nil {
		fields = append(fields, streak.FieldStreakState)
	}
	if m.current_day != nil {
		fields = append(fields, streak.FieldCurrentDay)
	}
	if m.reset_count != nil {
		fields = append(fields, streak.FieldResetCount)
	}
	if m.breaker != nil {
		fields = append(fields, streak.FieldBreakerUserID)
	}
	if m.recovery_deadline_at != nil {
		fields = append(fields, streak.FieldRecoveryDeadlineAt)
	}
	if m.recovery_payment_id != nil {
		fields = append(fields, streak.FieldRecoveryPaymentID)
	}
	if m.streak_health_score != nil {
		fields = append(fields, streak.FieldStreakHealthScore)
	}
	if m.created_at != nil {
		fields = append(fields, streak.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, streak.FieldUpdatedAt)
	}
	if m.completed_at != nil {
		fields = append(fields, streak.FieldCompletedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, streak.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StreakMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case streak.FieldConnectionID:
		return m.ConnectionID()
	case streak.FieldStreakState:
		return m.StreakState()
	case streak.FieldCurrentDay:
		return m.CurrentDay()
	case streak.FieldResetCount:
		return m.ResetCount()
	case streak.FieldBreakerUserID:
		return m.BreakerUserID()
	case streak.FieldRecoveryDeadlineAt:
		return m.RecoveryDeadlineAt()
	case streak.FieldRecoveryPaymentID:
		return m.RecoveryPaymentID()
	case streak.FieldStreakHealthScore:
		return m.StreakHealthScore()
	case streak.FieldCreatedAt:
		return m.CreatedAt()
	case streak.FieldUpdatedAt:
		return m.UpdatedAt()
	case streak.FieldCompletedAt:
		return m.CompletedAt()
	case streak.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StreakMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case streak.FieldConnectionID:
		return m.OldConnectionID(ctx)
	case streak.FieldStreakState:
		return m.OldStreakState(ctx)
	case streak.FieldCurrentDay:
		return m.OldCurrentDay(ctx)
	case streak.FieldResetCount:
		return m.OldResetCount(ctx)
	case streak.FieldBreakerUserID:
		return m.OldBreakerUserID(ctx)
	case streak.FieldRecoveryDeadlineAt:
		return m.OldRecoveryDeadlineAt(ctx)
	case streak.FieldRecoveryPaymentID:
		return m.OldRecoveryPaymentID(ctx)
	case streak.FieldStreakHealthScore:
		return m.OldStreakHealthScore(ctx)
	case streak.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case streak.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case streak.FieldCompletedAt:
		return m.OldCompletedAt(ctx)
	case streak.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Streak field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreakMutation) SetField(name string, value ent.Value) error {
	switch name {
	case streak.FieldConnectionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConnectionID(v)
		return nil
	case streak.FieldStreakState:
		v, ok := value.(streak.StreakState)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakState(v)
		return nil
	case streak.FieldCurrentDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentDay(v)
		return nil
	case streak.FieldResetCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResetCount(v)
		return nil
	case streak.FieldBreakerUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreakerUserID(v)
		return nil
	case streak.FieldRecoveryDeadlineAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecoveryDeadlineAt(v)
		return nil
	case streak.FieldRecoveryPaymentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecoveryPaymentID(v)
		return nil
	case streak.FieldStreakHealthScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakHealthScore(v)
		return nil
	case streak.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case streak.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case streak.FieldCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletedAt(v)
		return nil
	case streak.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Streak field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StreakMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_day != nil {
		fields = append(fields, streak.FieldCurrentDay)
	}
	if m.addreset_count != nil {
		fields = append(fields, streak.FieldResetCount)
	}
	if m.addstreak_health_score != nil {
		fields = append(fields, streak.FieldStreakHealthScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StreakMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case streak.FieldCurrentDay:
		return m.AddedCurrentDay()
	case streak.FieldResetCount:
		return m.AddedResetCount()
	case streak.FieldStreakHealthScore:
		return m.AddedStreakHealthScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreakMutation) AddField(name string, value ent.Value) error {
	switch name {
	case streak.FieldCurrentDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentDay(v)
		return nil
	case streak.FieldResetCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResetCount(v)
		return nil
	case streak.FieldStreakHealthScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreakHealthScore(v)
		return nil
	}
	return fmt.Errorf("unknown Streak numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StreakMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(streak.FieldBreakerUserID) {
		fields = append(fields, streak.FieldBreakerUserID)
	}
	if m.FieldCleared(streak.FieldRecoveryDeadlineAt) {
		fields = append(fields, streak.FieldRecoveryDeadlineAt)
	}
	if m.FieldCleared(streak.FieldRecoveryPaymentID) {
		fields = append(fields, streak.FieldRecoveryPaymentID)
	}
	if m.FieldCleared(streak.FieldStreakHealthScore) {
		fields = append(fields, streak.FieldStreakHealthScore)
	}
	if m.FieldCleared(streak.FieldCompletedAt) {
		fields = append(fields, streak.FieldCompletedAt)
	}
	if m.FieldCleared(streak.FieldDeletedAt) {
		fields = append(fields, streak.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StreakMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StreakMutation) ClearField(name string) error {
	switch name {
	case streak.FieldBreakerUserID:
		m.ClearBreakerUserID()
		return nil
	case streak.FieldRecoveryDeadlineAt:
		m.ClearRecoveryDeadlineAt()
		return nil
	case streak.FieldRecoveryPaymentID:
		m.ClearRecoveryPaymentID()
		return nil
	case streak.FieldStreakHealthScore:
		m.ClearStreakHealthScore()
		return nil
	case streak.FieldCompletedAt:
		m.ClearCompletedAt()
		return nil
	case streak.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Streak nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StreakMutation) ResetField(name string) error {
	switch name {
	case streak.FieldConnectionID:
		m.ResetConnectionID()
		return nil
	case streak.FieldStreakState:
		m.ResetStreakState()
		return nil
	case streak.FieldCurrentDay:
		m.ResetCurrentDay()
		return nil
	case streak.FieldResetCount:
		m.ResetResetCount()
		return nil
	case streak.FieldBreakerUserID:
		m.ResetBreakerUserID()
		return nil
	case streak.FieldRecoveryDeadlineAt:
		m.ResetRecoveryDeadlineAt()
		return nil
	case streak.FieldRecoveryPaymentID:
		m.ResetRecoveryPaymentID()
		return nil
	case streak.FieldStreakHealthScore:
		m.ResetStreakHealthScore()
		return nil
	case streak.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case streak.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case streak.FieldCompletedAt:
		m.ResetCompletedAt()
		return nil
	case streak.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Streak field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StreakMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.connection != nil {
		edges = append(edges, streak.EdgeConnection)
	}
	if m.breaker != nil {
		edges = append(edges, streak.EdgeBreaker)
	}
	if m.check_ins != nil {
		edges = append(edges, streak.EdgeCheckIns)
	}
	if m.nudges != nil {
		edges = append(edges, streak.EdgeNudges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StreakMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case streak.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	case streak.EdgeBreaker:
		if id := m.breaker; id != nil {
			return []ent.Value{*id}
		}
	case streak.EdgeCheckIns:
		ids := make([]ent.Value, 0, len(m.check_ins))
		for id := range m.check_ins {
			ids = append(ids, id)
		}
		return ids
	case streak.EdgeNudges:
		ids := make([]ent.Value, 0, len(m.nudges))
		for id := range m.nudges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StreakMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcheck_ins != nil {
		edges = append(edges, streak.EdgeCheckIns)
	}
	if m.removednudges != nil {
		edges = append(edges, streak.EdgeNudges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StreakMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case streak.EdgeCheckIns:
		ids := make([]ent.Value, 0, len(m.removedcheck_ins))
		for id := range m.removedcheck_ins {
			ids = append(ids, id)
		}
		return ids
	case streak.EdgeNudges:
		ids := make([]ent.Value, 0, len(m.removednudges))
		for id := range m.removednudges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StreakMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedconnection {
		edges = append(edges, streak.EdgeConnection)
	}
	if m.clearedbreaker {
		edges = append(edges, streak.EdgeBreaker)
	}
	if m.clearedcheck_ins {
		edges = append(edges, streak.EdgeCheckIns)
	}
	if m.clearednudges {
		edges = append(edges, streak.EdgeNudges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StreakMutation) EdgeCleared(name string) bool {
	switch name {
	case streak.EdgeConnection:
		return m.clearedconnection
	case streak.EdgeBreaker:
		return m.clearedbreaker
	case streak.EdgeCheckIns:
		return m.clearedcheck_ins
	case streak.EdgeNudges:
		return m.clearednudges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StreakMutation) ClearEdge(name string) error {
	switch name {
	case streak.EdgeConnection:
		m.ClearConnection()
		return nil
	case streak.EdgeBreaker:
		m.ClearBreaker()
		return nil
	}
	return fmt.Errorf("unknown Streak unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StreakMutation) ResetEdge(name string) error {
	switch name {
	case streak.EdgeConnection:
		m.ResetConnection()
		return nil
	case streak.EdgeBreaker:
		m.ResetBreaker()
		return nil
	case streak.EdgeCheckIns:
		m.ResetCheckIns()
		return nil
	case streak.EdgeNudges:
		m.ResetNudges()
		return nil
	}
	return fmt.Errorf("unknown Streak edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	email                        *string
	phone_number                 *string
	phone_country_code           *string
	provider                     *string
	provider_user_id             *string
	name                         *string
	first_name                   *string
	last_name                    *string
	picture                      *string
	date_of_birth                *time.Time
	gender                       *user.Gender
	city                         *string
	education                    *string
	profession                   *string
	religion                     *string
	bio                          *string
	verification_status          *user.VerificationStatus
	subscription_tier            *user.SubscriptionTier
	free_recoveries_used         *int
	addfree_recoveries_used      *int
	nudges_sent_today            *int
	addnudges_sent_today         *int
	nudges_reset_at              *time.Time
	active_connection_count      *int
	addactive_connection_count   *int
	last_global_refresh_at       *time.Time
	refresh_available_at         *time.Time
	credit_balance               *int
	addcredit_balance            *int
	behavioral_trust_score       *float64
	addbehavioral_trust_score    *float64
	account_status               *user.AccountStatus
	onboarding_status            *user.OnboardingStatus
	last_active_at               *time.Time
	suspended_at                 *time.Time
	suspension_reason            *string
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	clearedFields                map[string]struct{}
	profile                      *string
	clearedprofile               bool
	photos                       map[string]struct{}
	removedphotos                map[string]struct{}
	clearedphotos                bool
	hobbies                      map[string]struct{}
	removedhobbies               map[string]struct{}
	clearedhobbies               bool
	filters                      map[string]struct{}
	removedfilters               map[string]struct{}
	clearedfilters               bool
	discovery_batches            map[string]struct{}
	removeddiscovery_batches     map[string]struct{}
	cleareddiscovery_batches     bool
	discovery_appearances        map[string]struct{}
	removeddiscovery_appearances map[string]struct{}
	cleareddiscovery_appearances bool
	sent_interests               map[string]struct{}
	removedsent_interests        map[string]struct{}
	clearedsent_interests        bool
	received_interests           map[string]struct{}
	removedreceived_interests    map[string]struct{}
	clearedreceived_interests    bool
	connections_as_a             map[string]struct{}
	removedconnections_as_a      map[string]struct{}
	clearedconnections_as_a      bool
	connections_as_b             map[string]struct{}
	removedconnections_as_b      map[string]struct{}
	clearedconnections_as_b      bool
	broken_streaks               map[string]struct{}
	removedbroken_streaks        map[string]struct{}
	clearedbroken_streaks        bool
	check_ins                    map[string]struct{}
	removedcheck_ins             map[string]struct{}
	clearedcheck_ins             bool
	sent_nudges                  map[string]struct{}
	removedsent_nudges           map[string]struct{}
	clearedsent_nudges           bool
	received_nudges              map[string]struct{}
	removedreceived_nudges       map[string]struct{}
	clearedreceived_nudges       bool
	credit_transactions          map[string]struct{}
	removedcredit_transactions   map[string]struct{}
	clearedcredit_transactions   bool
	payment_orders               map[string]struct{}
	removedpayment_orders        map[string]struct{}
	clearedpayment_orders        bool
	blocks_given                 map[string]struct{}
	removedblocks_given          map[string]struct{}
	clearedblocks_given          bool
	blocks_received              map[string]struct{}
	removedblocks_received       map[string]struct{}
	clearedblocks_received       bool
	reports_given                map[string]struct{}
	removedreports_given         map[string]struct{}
	clearedreports_given         bool
	reports_received             map[string]struct{}
	removedreports_received      map[string]struct{}
	clearedreports_received      bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetPhoneCountryCode sets the "phone_country_code" field.
func (m *UserMutation) SetPhoneCountryCode(s string) {
	m.phone_country_code = &s
}

// PhoneCountryCode returns the value of the "phone_country_code" field in the mutation.
func (m *UserMutation) PhoneCountryCode() (r string, exists bool) {
	v := m.phone_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneCountryCode returns the old "phone_country_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneCountryCode: %w", err)
	}
	return oldValue.PhoneCountryCode, nil
}

// ClearPhoneCountryCode clears the value of the "phone_country_code" field.
func (m *UserMutation) ClearPhoneCountryCode() {
	m.phone_country_code = nil
	m.clearedFields[user.FieldPhoneCountryCode] = struct{}{}
}

// PhoneCountryCodeCleared returns if the "phone_country_code" field was cleared in this mutation.
func (m *UserMutation) PhoneCountryCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneCountryCode]
	return ok
}

// ResetPhoneCountryCode resets all changes to the "phone_country_code" field.
func (m *UserMutation) ResetPhoneCountryCode() {
	m.phone_country_code = nil
	delete(m.clearedFields, user.FieldPhoneCountryCode)
}

// SetProvider sets the "provider" field.
func (m *UserMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *UserMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProvider(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *UserMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[user.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *UserMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[user.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *UserMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, user.FieldProvider)
}

// SetProviderUserID sets the "provider_user_id" field.
func (m *UserMutation) SetProviderUserID(s string) {
	m.provider_user_id = &s
}

// ProviderUserID returns the value of the "provider_user_id" field in the mutation.
func (m *UserMutation) ProviderUserID() (r string, exists bool) {
	v := m.provider_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderUserID returns the old "provider_user_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProviderUserID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderUserID: %w", err)
	}
	return oldValue.ProviderUserID, nil
}

// ClearProviderUserID clears the value of the "provider_user_id" field.
func (m *UserMutation) ClearProviderUserID() {
	m.provider_user_id = nil
	m.clearedFields[user.FieldProviderUserID] = struct{}{}
}

// ProviderUserIDCleared returns if the "provider_user_id" field was cleared in this mutation.
func (m *UserMutation) ProviderUserIDCleared() bool {
	_, ok := m.clearedFields[user.FieldProviderUserID]
	return ok
}

// ResetProviderUserID resets all changes to the "provider_user_id" field.
func (m *UserMutation) ResetProviderUserID() {
	m.provider_user_id = nil
	delete(m.clearedFields, user.FieldProviderUserID)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetPicture sets the "picture" field.
func (m *UserMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *UserMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPicture(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *UserMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[user.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *UserMutation) PictureCleared() bool {
	_, ok := m.clearedFields[user.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *UserMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, user.FieldPicture)
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *UserMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *UserMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDateOfBirth(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *UserMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[user.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *UserMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[user.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *UserMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, user.FieldDateOfBirth)
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(u user.Gender) {
	m.gender = &u
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r user.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v *user.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *UserMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[user.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *UserMutation) GenderCleared() bool {
	_, ok := m.clearedFields[user.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, user.FieldGender)
}

// SetCity sets the "city" field.
func (m *UserMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *UserMutation) ClearCity() {
	m.city = nil
	m.clearedFields[user.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *UserMutation) CityCleared() bool {
	_, ok := m.clearedFields[user.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *UserMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, user.FieldCity)
}

// SetEducation sets the "education" field.
func (m *UserMutation) SetEducation(s string) {
	m.education = &s
}

// Education returns the value of the "education" field in the mutation.
func (m *UserMutation) Education() (r string, exists bool) {
	v := m.education
	if v == nil {
		return
	}
	return *v, true
}

// OldEducation returns the old "education" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEducation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEducation: %w", err)
	}
	return oldValue.Education, nil
}

// ClearEducation clears the value of the "education" field.
func (m *UserMutation) ClearEducation() {
	m.education = nil
	m.clearedFields[user.FieldEducation] = struct{}{}
}

// EducationCleared returns if the "education" field was cleared in this mutation.
func (m *UserMutation) EducationCleared() bool {
	_, ok := m.clearedFields[user.FieldEducation]
	return ok
}

// ResetEducation resets all changes to the "education" field.
func (m *UserMutation) ResetEducation() {
	m.education = nil
	delete(m.clearedFields, user.FieldEducation)
}

// SetProfession sets the "profession" field.
func (m *UserMutation) SetProfession(s string) {
	m.profession = &s
}

// Profession returns the value of the "profession" field in the mutation.
func (m *UserMutation) Profession() (r string, exists bool) {
	v := m.profession
	if v == nil {
		return
	}
	return *v, true
}

// OldProfession returns the old "profession" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfession(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfession: %w", err)
	}
	return oldValue.Profession, nil
}

// ClearProfession clears the value of the "profession" field.
func (m *UserMutation) ClearProfession() {
	m.profession = nil
	m.clearedFields[user.FieldProfession] = struct{}{}
}

// ProfessionCleared returns if the "profession" field was cleared in this mutation.
func (m *UserMutation) ProfessionCleared() bool {
	_, ok := m.clearedFields[user.FieldProfession]
	return ok
}

// ResetProfession resets all changes to the "profession" field.
func (m *UserMutation) ResetProfession() {
	m.profession = nil
	delete(m.clearedFields, user.FieldProfession)
}

// SetReligion sets the "religion" field.
func (m *UserMutation) SetReligion(s string) {
	m.religion = &s
}

// Religion returns the value of the "religion" field in the mutation.
func (m *UserMutation) Religion() (r string, exists bool) {
	v := m.religion
	if v == nil {
		return
	}
	return *v, true
}

// OldReligion returns the old "religion" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReligion(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReligion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReligion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReligion: %w", err)
	}
	return oldValue.Religion, nil
}

// ClearReligion clears the value of the "religion" field.
func (m *UserMutation) ClearReligion() {
	m.religion = nil
	m.clearedFields[user.FieldReligion] = struct{}{}
}

// ReligionCleared returns if the "religion" field was cleared in this mutation.
func (m *UserMutation) ReligionCleared() bool {
	_, ok := m.clearedFields[user.FieldReligion]
	return ok
}

// ResetReligion resets all changes to the "religion" field.
func (m *UserMutation) ResetReligion() {
	m.religion = nil
	delete(m.clearedFields, user.FieldReligion)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetVerificationStatus sets the "verification_status" field.
func (m *UserMutation) SetVerificationStatus(us user.VerificationStatus) {
	m.verification_status = &us
}

// VerificationStatus returns the value of the "verification_status" field in the mutation.
func (m *UserMutation) VerificationStatus() (r user.VerificationStatus, exists bool) {
	v := m.verification_status
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationStatus returns the old "verification_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVerificationStatus(ctx context.Context) (v user.VerificationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationStatus: %w", err)
	}
	return oldValue.VerificationStatus, nil
}

// ResetVerificationStatus resets all changes to the "verification_status" field.
func (m *UserMutation) ResetVerificationStatus() {
	m.verification_status = nil
}

// SetSubscriptionTier sets the "subscription_tier" field.
func (m *UserMutation) SetSubscriptionTier(ut user.SubscriptionTier) {
	m.subscription_tier = &ut
}

// SubscriptionTier returns the value of the "subscription_tier" field in the mutation.
func (m *UserMutation) SubscriptionTier() (r user.SubscriptionTier, exists bool) {
	v := m.subscription_tier
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionTier returns the old "subscription_tier" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSubscriptionTier(ctx context.Context) (v user.SubscriptionTier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionTier: %w", err)
	}
	return oldValue.SubscriptionTier, nil
}

// ResetSubscriptionTier resets all changes to the "subscription_tier" field.
func (m *UserMutation) ResetSubscriptionTier() {
	m.subscription_tier = nil
}

// SetFreeRecoveriesUsed sets the "free_recoveries_used" field.
func (m *UserMutation) SetFreeRecoveriesUsed(i int) {
	m.free_recoveries_used = &i
	m.addfree_recoveries_used = nil
}

// FreeRecoveriesUsed returns the value of the "free_recoveries_used" field in the mutation.
func (m *UserMutation) FreeRecoveriesUsed() (r int, exists bool) {
	v := m.free_recoveries_used
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeRecoveriesUsed returns the old "free_recoveries_used" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFreeRecoveriesUsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeRecoveriesUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeRecoveriesUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeRecoveriesUsed: %w", err)
	}
	return oldValue.FreeRecoveriesUsed, nil
}

// AddFreeRecoveriesUsed adds i to the "free_recoveries_used" field.
func (m *UserMutation) AddFreeRecoveriesUsed(i int) {
	if m.addfree_recoveries_used != nil {
		*m.addfree_recoveries_used += i
	} else {
		m.addfree_recoveries_used = &i
	}
}

// AddedFreeRecoveriesUsed returns the value that was added to the "free_recoveries_used" field in this mutation.
func (m *UserMutation) AddedFreeRecoveriesUsed() (r int, exists bool) {
	v := m.addfree_recoveries_used
	if v == nil {
		return
	}
	return *v, true
}

// ResetFreeRecoveriesUsed resets all changes to the "free_recoveries_used" field.
func (m *UserMutation) ResetFreeRecoveriesUsed() {
	m.free_recoveries_used = nil
	m.addfree_recoveries_used = nil
}

// SetNudgesSentToday sets the "nudges_sent_today" field.
func (m *UserMutation) SetNudgesSentToday(i int) {
	m.nudges_sent_today = &i
	m.addnudges_sent_today = nil
}

// NudgesSentToday returns the value of the "nudges_sent_today" field in the mutation.
func (m *UserMutation) NudgesSentToday() (r int, exists bool) {
	v := m.nudges_sent_today
	if v == nil {
		return
	}
	return *v, true
}

// OldNudgesSentToday returns the old "nudges_sent_today" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNudgesSentToday(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNudgesSentToday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNudgesSentToday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNudgesSentToday: %w", err)
	}
	return oldValue.NudgesSentToday, nil
}

// AddNudgesSentToday adds i to the "nudges_sent_today" field.
func (m *UserMutation) AddNudgesSentToday(i int) {
	if m.addnudges_sent_today != nil {
		*m.addnudges_sent_today += i
	} else {
		m.addnudges_sent_today = &i
	}
}

// AddedNudgesSentToday returns the value that was added to the "nudges_sent_today" field in this mutation.
func (m *UserMutation) AddedNudgesSentToday() (r int, exists bool) {
	v := m.addnudges_sent_today
	if v == nil {
		return
	}
	return *v, true
}

// ResetNudgesSentToday resets all changes to the "nudges_sent_today" field.
func (m *UserMutation) ResetNudgesSentToday() {
	m.nudges_sent_today = nil
	m.addnudges_sent_today = nil
}

// SetNudgesResetAt sets the "nudges_reset_at" field.
func (m *UserMutation) SetNudgesResetAt(t time.Time) {
	m.nudges_reset_at = &t
}

// NudgesResetAt returns the value of the "nudges_reset_at" field in the mutation.
func (m *UserMutation) NudgesResetAt() (r time.Time, exists bool) {
	v := m.nudges_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNudgesResetAt returns the old "nudges_reset_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNudgesResetAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNudgesResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNudgesResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNudgesResetAt: %w", err)
	}
	return oldValue.NudgesResetAt, nil
}

// ClearNudgesResetAt clears the value of the "nudges_reset_at" field.
func (m *UserMutation) ClearNudgesResetAt() {
	m.nudges_reset_at = nil
	m.clearedFields[user.FieldNudgesResetAt] = struct{}{}
}

// NudgesResetAtCleared returns if the "nudges_reset_at" field was cleared in this mutation.
func (m *UserMutation) NudgesResetAtCleared() bool {
	_, ok := m.clearedFields[user.FieldNudgesResetAt]
	return ok
}

// ResetNudgesResetAt resets all changes to the "nudges_reset_at" field.
func (m *UserMutation) ResetNudgesResetAt() {
	m.nudges_reset_at = nil
	delete(m.clearedFields, user.FieldNudgesResetAt)
}

// SetActiveConnectionCount sets the "active_connection_count" field.
func (m *UserMutation) SetActiveConnectionCount(i int) {
	m.active_connection_count = &i
	m.addactive_connection_count = nil
}

// ActiveConnectionCount returns the value of the "active_connection_count" field in the mutation.
func (m *UserMutation) ActiveConnectionCount() (r int, exists bool) {
	v := m.active_connection_count
	if v == nil {
		return
	}
	return *v, true
}

// OldActiveConnectionCount returns the old "active_connection_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActiveConnectionCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActiveConnectionCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActiveConnectionCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActiveConnectionCount: %w", err)
	}
	return oldValue.ActiveConnectionCount, nil
}

// AddActiveConnectionCount adds i to the "active_connection_count" field.
func (m *UserMutation) AddActiveConnectionCount(i int) {
	if m.addactive_connection_count != nil {
		*m.addactive_connection_count += i
	} else {
		m.addactive_connection_count = &i
	}
}

// AddedActiveConnectionCount returns the value that was added to the "active_connection_count" field in this mutation.
func (m *UserMutation) AddedActiveConnectionCount() (r int, exists bool) {
	v := m.addactive_connection_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetActiveConnectionCount resets all changes to the "active_connection_count" field.
func (m *UserMutation) ResetActiveConnectionCount() {
	m.active_connection_count = nil
	m.addactive_connection_count = nil
}

// SetLastGlobalRefreshAt sets the "last_global_refresh_at" field.
func (m *UserMutation) SetLastGlobalRefreshAt(t time.Time) {
	m.last_global_refresh_at = &t
}

// LastGlobalRefreshAt returns the value of the "last_global_refresh_at" field in the mutation.
func (m *UserMutation) LastGlobalRefreshAt() (r time.Time, exists bool) {
	v := m.last_global_refresh_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastGlobalRefreshAt returns the old "last_global_refresh_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastGlobalRefreshAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastGlobalRefreshAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastGlobalRefreshAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastGlobalRefreshAt: %w", err)
	}
	return oldValue.LastGlobalRefreshAt, nil
}

// ClearLastGlobalRefreshAt clears the value of the "last_global_refresh_at" field.
func (m *UserMutation) ClearLastGlobalRefreshAt() {
	m.last_global_refresh_at = nil
	m.clearedFields[user.FieldLastGlobalRefreshAt] = struct{}{}
}

// LastGlobalRefreshAtCleared returns if the "last_global_refresh_at" field was cleared in this mutation.
func (m *UserMutation) LastGlobalRefreshAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastGlobalRefreshAt]
	return ok
}

// ResetLastGlobalRefreshAt resets all changes to the "last_global_refresh_at" field.
func (m *UserMutation) ResetLastGlobalRefreshAt() {
	m.last_global_refresh_at = nil
	delete(m.clearedFields, user.FieldLastGlobalRefreshAt)
}

// SetRefreshAvailableAt sets the "refresh_available_at" field.
func (m *UserMutation) SetRefreshAvailableAt(t time.Time) {
	m.refresh_available_at = &t
}

// RefreshAvailableAt returns the value of the "refresh_available_at" field in the mutation.
func (m *UserMutation) RefreshAvailableAt() (r time.Time, exists bool) {
	v := m.refresh_available_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshAvailableAt returns the old "refresh_available_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRefreshAvailableAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshAvailableAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshAvailableAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshAvailableAt: %w", err)
	}
	return oldValue.RefreshAvailableAt, nil
}

// ClearRefreshAvailableAt clears the value of the "refresh_available_at" field.
func (m *UserMutation) ClearRefreshAvailableAt() {
	m.refresh_available_at = nil
	m.clearedFields[user.FieldRefreshAvailableAt] = struct{}{}
}

// RefreshAvailableAtCleared returns if the "refresh_available_at" field was cleared in this mutation.
func (m *UserMutation) RefreshAvailableAtCleared() bool {
	_, ok := m.clearedFields[user.FieldRefreshAvailableAt]
	return ok
}

// ResetRefreshAvailableAt resets all changes to the "refresh_available_at" field.
func (m *UserMutation) ResetRefreshAvailableAt() {
	m.refresh_available_at = nil
	delete(m.clearedFields, user.FieldRefreshAvailableAt)
}

// SetCreditBalance sets the "credit_balance" field.
func (m *UserMutation) SetCreditBalance(i int) {
	m.credit_balance = &i
	m.addcredit_balance = nil
}

// CreditBalance returns the value of the "credit_balance" field in the mutation.
func (m *UserMutation) CreditBalance() (r int, exists bool) {
	v := m.credit_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditBalance returns the old "credit_balance" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreditBalance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditBalance: %w", err)
	}
	return oldValue.CreditBalance, nil
}

// AddCreditBalance adds i to the "credit_balance" field.
func (m *UserMutation) AddCreditBalance(i int) {
	if m.addcredit_balance != nil {
		*m.addcredit_balance += i
	} else {
		m.addcredit_balance = &i
	}
}

// AddedCreditBalance returns the value that was added to the "credit_balance" field in this mutation.
func (m *UserMutation) AddedCreditBalance() (r int, exists bool) {
	v := m.addcredit_balance
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditBalance resets all changes to the "credit_balance" field.
func (m *UserMutation) ResetCreditBalance() {
	m.credit_balance = nil
	m.addcredit_balance = nil
}

// SetBehavioralTrustScore sets the "behavioral_trust_score" field.
func (m *UserMutation) SetBehavioralTrustScore(f float64) {
	m.behavioral_trust_score = &f
	m.addbehavioral_trust_score = nil
}

// BehavioralTrustScore returns the value of the "behavioral_trust_score" field in the mutation.
func (m *UserMutation) BehavioralTrustScore() (r float64, exists bool) {
	v := m.behavioral_trust_score
	if v == nil {
		return
	}
	return *v, true
}

// OldBehavioralTrustScore returns the old "behavioral_trust_score" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBehavioralTrustScore(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBehavioralTrustScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBehavioralTrustScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBehavioralTrustScore: %w", err)
	}
	return oldValue.BehavioralTrustScore, nil
}

// AddBehavioralTrustScore adds f to the "behavioral_trust_score" field.
func (m *UserMutation) AddBehavioralTrustScore(f float64) {
	if m.addbehavioral_trust_score != nil {
		*m.addbehavioral_trust_score += f
	} else {
		m.addbehavioral_trust_score = &f
	}
}

// AddedBehavioralTrustScore returns the value that was added to the "behavioral_trust_score" field in this mutation.
func (m *UserMutation) AddedBehavioralTrustScore() (r float64, exists bool) {
	v := m.addbehavioral_trust_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearBehavioralTrustScore clears the value of the "behavioral_trust_score" field.
func (m *UserMutation) ClearBehavioralTrustScore() {
	m.behavioral_trust_score = nil
	m.addbehavioral_trust_score = nil
	m.clearedFields[user.FieldBehavioralTrustScore] = struct{}{}
}

// BehavioralTrustScoreCleared returns if the "behavioral_trust_score" field was cleared in this mutation.
func (m *UserMutation) BehavioralTrustScoreCleared() bool {
	_, ok := m.clearedFields[user.FieldBehavioralTrustScore]
	return ok
}

// ResetBehavioralTrustScore resets all changes to the "behavioral_trust_score" field.
func (m *UserMutation) ResetBehavioralTrustScore() {
	m.behavioral_trust_score = nil
	m.addbehavioral_trust_score = nil
	delete(m.clearedFields, user.FieldBehavioralTrustScore)
}

// SetAccountStatus sets the "account_status" field.
func (m *UserMutation) SetAccountStatus(us user.AccountStatus) {
	m.account_status = &us
}

// AccountStatus returns the value of the "account_status" field in the mutation.
func (m *UserMutation) AccountStatus() (r user.AccountStatus, exists bool) {
	v := m.account_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountStatus returns the old "account_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountStatus(ctx context.Context) (v user.AccountStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountStatus: %w", err)
	}
	return oldValue.AccountStatus, nil
}

// ResetAccountStatus resets all changes to the "account_status" field.
func (m *UserMutation) ResetAccountStatus() {
	m.account_status = nil
}

// SetOnboardingStatus sets the "onboarding_status" field.
func (m *UserMutation) SetOnboardingStatus(us user.OnboardingStatus) {
	m.onboarding_status = &us
}

// OnboardingStatus returns the value of the "onboarding_status" field in the mutation.
func (m *UserMutation) OnboardingStatus() (r user.OnboardingStatus, exists bool) {
	v := m.onboarding_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOnboardingStatus returns the old "onboarding_status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOnboardingStatus(ctx context.Context) (v user.OnboardingStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOnboardingStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOnboardingStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnboardingStatus: %w", err)
	}
	return oldValue.OnboardingStatus, nil
}

// ResetOnboardingStatus resets all changes to the "onboarding_status" field.
func (m *UserMutation) ResetOnboardingStatus() {
	m.onboarding_status = nil
}

// SetLastActiveAt sets the "last_active_at" field.
func (m *UserMutation) SetLastActiveAt(t time.Time) {
	m.last_active_at = &t
}

// LastActiveAt returns the value of the "last_active_at" field in the mutation.
func (m *UserMutation) LastActiveAt() (r time.Time, exists bool) {
	v := m.last_active_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastActiveAt returns the old "last_active_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastActiveAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastActiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastActiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastActiveAt: %w", err)
	}
	return oldValue.LastActiveAt, nil
}

// ClearLastActiveAt clears the value of the "last_active_at" field.
func (m *UserMutation) ClearLastActiveAt() {
	m.last_active_at = nil
	m.clearedFields[user.FieldLastActiveAt] = struct{}{}
}

// LastActiveAtCleared returns if the "last_active_at" field was cleared in this mutation.
func (m *UserMutation) LastActiveAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastActiveAt]
	return ok
}

// ResetLastActiveAt resets all changes to the "last_active_at" field.
func (m *UserMutation) ResetLastActiveAt() {
	m.last_active_at = nil
	delete(m.clearedFields, user.FieldLastActiveAt)
}

// SetSuspendedAt sets the "suspended_at" field.
func (m *UserMutation) SetSuspendedAt(t time.Time) {
	m.suspended_at = &t
}

// SuspendedAt returns the value of the "suspended_at" field in the mutation.
func (m *UserMutation) SuspendedAt() (r time.Time, exists bool) {
	v := m.suspended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendedAt returns the old "suspended_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSuspendedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendedAt: %w", err)
	}
	return oldValue.SuspendedAt, nil
}

// ClearSuspendedAt clears the value of the "suspended_at" field.
func (m *UserMutation) ClearSuspendedAt() {
	m.suspended_at = nil
	m.clearedFields[user.FieldSuspendedAt] = struct{}{}
}

// SuspendedAtCleared returns if the "suspended_at" field was cleared in this mutation.
func (m *UserMutation) SuspendedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldSuspendedAt]
	return ok
}

// ResetSuspendedAt resets all changes to the "suspended_at" field.
func (m *UserMutation) ResetSuspendedAt() {
	m.suspended_at = nil
	delete(m.clearedFields, user.FieldSuspendedAt)
}

// SetSuspensionReason sets the "suspension_reason" field.
func (m *UserMutation) SetSuspensionReason(s string) {
	m.suspension_reason = &s
}

// SuspensionReason returns the value of the "suspension_reason" field in the mutation.
func (m *UserMutation) SuspensionReason() (r string, exists bool) {
	v := m.suspension_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspensionReason returns the old "suspension_reason" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSuspensionReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspensionReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspensionReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspensionReason: %w", err)
	}
	return oldValue.SuspensionReason, nil
}

// ClearSuspensionReason clears the value of the "suspension_reason" field.
func (m *UserMutation) ClearSuspensionReason() {
	m.suspension_reason = nil
	m.clearedFields[user.FieldSuspensionReason] = struct{}{}
}

// SuspensionReasonCleared returns if the "suspension_reason" field was cleared in this mutation.
func (m *UserMutation) SuspensionReasonCleared() bool {
	_, ok := m.clearedFields[user.FieldSuspensionReason]
	return ok
}

// ResetSuspensionReason resets all changes to the "suspension_reason" field.
func (m *UserMutation) ResetSuspensionReason() {
	m.suspension_reason = nil
	delete(m.clearedFields, user.FieldSuspensionReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *UserMutation) SetProfileID(id string) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserMutation) ProfileID() (id string, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []string) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddPhotoIDs adds the "photos" edge to the Photo entity by ids.
func (m *UserMutation) AddPhotoIDs(ids ...string) {
	if m.photos == nil {
		m.photos = make(map[string]struct{})
	}
	for i := range ids {
		m.photos[ids[i]] = struct{}{}
	}
}

// ClearPhotos clears the "photos" edge to the Photo entity.
func (m *UserMutation) ClearPhotos() {
	m.clearedphotos = true
}

// PhotosCleared reports if the "photos" edge to the Photo entity was cleared.
func (m *UserMutation) PhotosCleared() bool {
	return m.clearedphotos
}

// RemovePhotoIDs removes the "photos" edge to the Photo entity by IDs.
func (m *UserMutation) RemovePhotoIDs(ids ...string) {
	if m.removedphotos == nil {
		m.removedphotos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.photos, ids[i])
		m.removedphotos[ids[i]] = struct{}{}
	}
}

// RemovedPhotos returns the removed IDs of the "photos" edge to the Photo entity.
func (m *UserMutation) RemovedPhotosIDs() (ids []string) {
	for id := range m.removedphotos {
		ids = append(ids, id)
	}
	return
}

// PhotosIDs returns the "photos" edge IDs in the mutation.
func (m *UserMutation) PhotosIDs() (ids []string) {
	for id := range m.photos {
		ids = append(ids, id)
	}
	return
}

// ResetPhotos resets all changes to the "photos" edge.
func (m *UserMutation) ResetPhotos() {
	m.photos = nil
	m.clearedphotos = false
	m.removedphotos = nil
}

// AddHobbyIDs adds the "hobbies" edge to the Hobby entity by ids.
func (m *UserMutation) AddHobbyIDs(ids ...string) {
	if m.hobbies == nil {
		m.hobbies = make(map[string]struct{})
	}
	for i := range ids {
		m.hobbies[ids[i]] = struct{}{}
	}
}

// ClearHobbies clears the "hobbies" edge to the Hobby entity.
func (m *UserMutation) ClearHobbies() {
	m.clearedhobbies = true
}

// HobbiesCleared reports if the "hobbies" edge to the Hobby entity was cleared.
func (m *UserMutation) HobbiesCleared() bool {
	return m.clearedhobbies
}

// RemoveHobbyIDs removes the "hobbies" edge to the Hobby entity by IDs.
func (m *UserMutation) RemoveHobbyIDs(ids ...string) {
	if m.removedhobbies == nil {
		m.removedhobbies = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.hobbies, ids[i])
		m.removedhobbies[ids[i]] = struct{}{}
	}
}

// RemovedHobbies returns the removed IDs of the "hobbies" edge to the Hobby entity.
func (m *UserMutation) RemovedHobbiesIDs() (ids []string) {
	for id := range m.removedhobbies {
		ids = append(ids, id)
	}
	return
}

// HobbiesIDs returns the "hobbies" edge IDs in the mutation.
func (m *UserMutation) HobbiesIDs() (ids []string) {
	for id := range m.hobbies {
		ids = append(ids, id)
	}
	return
}

// ResetHobbies resets all changes to the "hobbies" edge.
func (m *UserMutation) ResetHobbies() {
	m.hobbies = nil
	m.clearedhobbies = false
	m.removedhobbies = nil
}

// AddFilterIDs adds the "filters" edge to the Filter entity by ids.
func (m *UserMutation) AddFilterIDs(ids ...string) {
	if m.filters == nil {
		m.filters = make(map[string]struct{})
	}
	for i := range ids {
		m.filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "filters" edge to the Filter entity.
func (m *UserMutation) ClearFilters() {
	m.clearedfilters = true
}

// FiltersCleared reports if the "filters" edge to the Filter entity was cleared.
func (m *UserMutation) FiltersCleared() bool {
	return m.clearedfilters
}

// RemoveFilterIDs removes the "filters" edge to the Filter entity by IDs.
func (m *UserMutation) RemoveFilterIDs(ids ...string) {
	if m.removedfilters == nil {
		m.removedfilters = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.filters, ids[i])
		m.removedfilters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "filters" edge to the Filter entity.
func (m *UserMutation) RemovedFiltersIDs() (ids []string) {
	for id := range m.removedfilters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "filters" edge IDs in the mutation.
func (m *UserMutation) FiltersIDs() (ids []string) {
	for id := range m.filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "filters" edge.
func (m *UserMutation) ResetFilters() {
	m.filters = nil
	m.clearedfilters = false
	m.removedfilters = nil
}

// AddDiscoveryBatchIDs adds the "discovery_batches" edge to the DiscoveryBatch entity by ids.
func (m *UserMutation) AddDiscoveryBatchIDs(ids ...string) {
	if m.discovery_batches == nil {
		m.discovery_batches = make(map[string]struct{})
	}
	for i := range ids {
		m.discovery_batches[ids[i]] = struct{}{}
	}
}

// ClearDiscoveryBatches clears the "discovery_batches" edge to the DiscoveryBatch entity.
func (m *UserMutation) ClearDiscoveryBatches() {
	m.cleareddiscovery_batches = true
}

// DiscoveryBatchesCleared reports if the "discovery_batches" edge to the DiscoveryBatch entity was cleared.
func (m *UserMutation) DiscoveryBatchesCleared() bool {
	return m.cleareddiscovery_batches
}

// RemoveDiscoveryBatchIDs removes the "discovery_batches" edge to the DiscoveryBatch entity by IDs.
func (m *UserMutation) RemoveDiscoveryBatchIDs(ids ...string) {
	if m.removeddiscovery_batches == nil {
		m.removeddiscovery_batches = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.discovery_batches, ids[i])
		m.removeddiscovery_batches[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveryBatches returns the removed IDs of the "discovery_batches" edge to the DiscoveryBatch entity.
func (m *UserMutation) RemovedDiscoveryBatchesIDs() (ids []string) {
	for id := range m.removeddiscovery_batches {
		ids = append(ids, id)
	}
	return
}

// DiscoveryBatchesIDs returns the "discovery_batches" edge IDs in the mutation.
func (m *UserMutation) DiscoveryBatchesIDs() (ids []string) {
	for id := range m.discovery_batches {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveryBatches resets all changes to the "discovery_batches" edge.
func (m *UserMutation) ResetDiscoveryBatches() {
	m.discovery_batches = nil
	m.cleareddiscovery_batches = false
	m.removeddiscovery_batches = nil
}

// AddDiscoveryAppearanceIDs adds the "discovery_appearances" edge to the DiscoveryCard entity by ids.
func (m *UserMutation) AddDiscoveryAppearanceIDs(ids ...string) {
	if m.discovery_appearances == nil {
		m.discovery_appearances = make(map[string]struct{})
	}
	for i := range ids {
		m.discovery_appearances[ids[i]] = struct{}{}
	}
}

// ClearDiscoveryAppearances clears the "discovery_appearances" edge to the DiscoveryCard entity.
func (m *UserMutation) ClearDiscoveryAppearances() {
	m.cleareddiscovery_appearances = true
}

// DiscoveryAppearancesCleared reports if the "discovery_appearances" edge to the DiscoveryCard entity was cleared.
func (m *UserMutation) DiscoveryAppearancesCleared() bool {
	return m.cleareddiscovery_appearances
}

// RemoveDiscoveryAppearanceIDs removes the "discovery_appearances" edge to the DiscoveryCard entity by IDs.
func (m *UserMutation) RemoveDiscoveryAppearanceIDs(ids ...string) {
	if m.removeddiscovery_appearances == nil {
		m.removeddiscovery_appearances = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.discovery_appearances, ids[i])
		m.removeddiscovery_appearances[ids[i]] = struct{}{}
	}
}

// RemovedDiscoveryAppearances returns the removed IDs of the "discovery_appearances" edge to the DiscoveryCard entity.
func (m *UserMutation) RemovedDiscoveryAppearancesIDs() (ids []string) {
	for id := range m.removeddiscovery_appearances {
		ids = append(ids, id)
	}
	return
}

// DiscoveryAppearancesIDs returns the "discovery_appearances" edge IDs in the mutation.
func (m *UserMutation) DiscoveryAppearancesIDs() (ids []string) {
	for id := range m.discovery_appearances {
		ids = append(ids, id)
	}
	return
}

// ResetDiscoveryAppearances resets all changes to the "discovery_appearances" edge.
func (m *UserMutation) ResetDiscoveryAppearances() {
	m.discovery_appearances = nil
	m.cleareddiscovery_appearances = false
	m.removeddiscovery_appearances = nil
}

// AddSentInterestIDs adds the "sent_interests" edge to the Interest entity by ids.
func (m *UserMutation) AddSentInterestIDs(ids ...string) {
	if m.sent_interests == nil {
		m.sent_interests = make(map[string]struct{})
	}
	for i := range ids {
		m.sent_interests[ids[i]] = struct{}{}
	}
}

// ClearSentInterests clears the "sent_interests" edge to the Interest entity.
func (m *UserMutation) ClearSentInterests() {
	m.clearedsent_interests = true
}

// SentInterestsCleared reports if the "sent_interests" edge to the Interest entity was cleared.
func (m *UserMutation) SentInterestsCleared() bool {
	return m.clearedsent_interests
}

// RemoveSentInterestIDs removes the "sent_interests" edge to the Interest entity by IDs.
func (m *UserMutation) RemoveSentInterestIDs(ids ...string) {
	if m.removedsent_interests == nil {
		m.removedsent_interests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sent_interests, ids[i])
		m.removedsent_interests[ids[i]] = struct{}{}
	}
}

// RemovedSentInterests returns the removed IDs of the "sent_interests" edge to the Interest entity.
func (m *UserMutation) RemovedSentInterestsIDs() (ids []string) {
	for id := range m.removedsent_interests {
		ids = append(ids, id)
	}
	return
}

// SentInterestsIDs returns the "sent_interests" edge IDs in the mutation.
func (m *UserMutation) SentInterestsIDs() (ids []string) {
	for id := range m.sent_interests {
		ids = append(ids, id)
	}
	return
}

// ResetSentInterests resets all changes to the "sent_interests" edge.
func (m *UserMutation) ResetSentInterests() {
	m.sent_interests = nil
	m.clearedsent_interests = false
	m.removedsent_interests = nil
}

// AddReceivedInterestIDs adds the "received_interests" edge to the Interest entity by ids.
func (m *UserMutation) AddReceivedInterestIDs(ids ...string) {
	if m.received_interests == nil {
		m.received_interests = make(map[string]struct{})
	}
	for i := range ids {
		m.received_interests[ids[i]] = struct{}{}
	}
}

// ClearReceivedInterests clears the "received_interests" edge to the Interest entity.
func (m *UserMutation) ClearReceivedInterests() {
	m.clearedreceived_interests = true
}

// ReceivedInterestsCleared reports if the "received_interests" edge to the Interest entity was cleared.
func (m *UserMutation) ReceivedInterestsCleared() bool {
	return m.clearedreceived_interests
}

// RemoveReceivedInterestIDs removes the "received_interests" edge to the Interest entity by IDs.
func (m *UserMutation) RemoveReceivedInterestIDs(ids ...string) {
	if m.removedreceived_interests == nil {
		m.removedreceived_interests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.received_interests, ids[i])
		m.removedreceived_interests[ids[i]] = struct{}{}
	}
}

// RemovedReceivedInterests returns the removed IDs of the "received_interests" edge to the Interest entity.
func (m *UserMutation) RemovedReceivedInterestsIDs() (ids []string) {
	for id := range m.removedreceived_interests {
		ids = append(ids, id)
	}
	return
}

// ReceivedInterestsIDs returns the "received_interests" edge IDs in the mutation.
func (m *UserMutation) ReceivedInterestsIDs() (ids []string) {
	for id := range m.received_interests {
		ids = append(ids, id)
	}
	return
}

// ResetReceivedInterests resets all changes to the "received_interests" edge.
func (m *UserMutation) ResetReceivedInterests() {
	m.received_interests = nil
	m.clearedreceived_interests = false
	m.removedreceived_interests = nil
}

// AddConnectionsAsAIDs adds the "connections_as_a" edge to the Connection entity by ids.
func (m *UserMutation) AddConnectionsAsAIDs(ids ...string) {
	if m.connections_as_a == nil {
		m.connections_as_a = make(map[string]struct{})
	}
	for i := range ids {
		m.connections_as_a[ids[i]] = struct{}{}
	}
}

// ClearConnectionsAsA clears the "connections_as_a" edge to the Connection entity.
func (m *UserMutation) ClearConnectionsAsA() {
	m.clearedconnections_as_a = true
}

// ConnectionsAsACleared reports if the "connections_as_a" edge to the Connection entity was cleared.
func (m *UserMutation) ConnectionsAsACleared() bool {
	return m.clearedconnections_as_a
}

// RemoveConnectionsAsAIDs removes the "connections_as_a" edge to the Connection entity by IDs.
func (m *UserMutation) RemoveConnectionsAsAIDs(ids ...string) {
	if m.removedconnections_as_a == nil {
		m.removedconnections_as_a = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.connections_as_a, ids[i])
		m.removedconnections_as_a[ids[i]] = struct{}{}
	}
}

// RemovedConnectionsAsA returns the removed IDs of the "connections_as_a" edge to the Connection entity.
func (m *UserMutation) RemovedConnectionsAsAIDs() (ids []string) {
	for id := range m.removedconnections_as_a {
		ids = append(ids, id)
	}
	return
}

// ConnectionsAsAIDs returns the "connections_as_a" edge IDs in the mutation.
func (m *UserMutation) ConnectionsAsAIDs() (ids []string) {
	for id := range m.connections_as_a {
		ids = append(ids, id)
	}
	return
}

// ResetConnectionsAsA resets all changes to the "connections_as_a" edge.
func (m *UserMutation) ResetConnectionsAsA() {
	m.connections_as_a = nil
	m.clearedconnections_as_a = false
	m.removedconnections_as_a = nil
}

// AddConnectionsAsBIDs adds the "connections_as_b" edge to the Connection entity by ids.
func (m *UserMutation) AddConnectionsAsBIDs(ids ...string) {
	if m.connections_as_b == nil {
		m.connections_as_b = make(map[string]struct{})
	}
	for i := range ids {
		m.connections_as_b[ids[i]] = struct{}{}
	}
}

// ClearConnectionsAsB clears the "connections_as_b" edge to the Connection entity.
func (m *UserMutation) ClearConnectionsAsB() {
	m.clearedconnections_as_b = true
}

// ConnectionsAsBCleared reports if the "connections_as_b" edge to the Connection entity was cleared.
func (m *UserMutation) ConnectionsAsBCleared() bool {
	return m.clearedconnections_as_b
}

// RemoveConnectionsAsBIDs removes the "connections_as_b" edge to the Connection entity by IDs.
func (m *UserMutation) RemoveConnectionsAsBIDs(ids ...string) {
	if m.removedconnections_as_b == nil {
		m.removedconnections_as_b = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.connections_as_b, ids[i])
		m.removedconnections_as_b[ids[i]] = struct{}{}
	}
}

// RemovedConnectionsAsB returns the removed IDs of the "connections_as_b" edge to the Connection entity.
func (m *UserMutation) RemovedConnectionsAsBIDs() (ids []string) {
	for id := range m.removedconnections_as_b {
		ids = append(ids, id)
	}
	return
}

// ConnectionsAsBIDs returns the "connections_as_b" edge IDs in the mutation.
func (m *UserMutation) ConnectionsAsBIDs() (ids []string) {
	for id := range m.connections_as_b {
		ids = append(ids, id)
	}
	return
}

// ResetConnectionsAsB resets all changes to the "connections_as_b" edge.
func (m *UserMutation) ResetConnectionsAsB() {
	m.connections_as_b = nil
	m.clearedconnections_as_b = false
	m.removedconnections_as_b = nil
}

// AddBrokenStreakIDs adds the "broken_streaks" edge to the Streak entity by ids.
func (m *UserMutation) AddBrokenStreakIDs(ids ...string) {
	if m.broken_streaks == nil {
		m.broken_streaks = make(map[string]struct{})
	}
	for i := range ids {
		m.broken_streaks[ids[i]] = struct{}{}
	}
}

// ClearBrokenStreaks clears the "broken_streaks" edge to the Streak entity.
func (m *UserMutation) ClearBrokenStreaks() {
	m.clearedbroken_streaks = true
}

// BrokenStreaksCleared reports if the "broken_streaks" edge to the Streak entity was cleared.
func (m *UserMutation) BrokenStreaksCleared() bool {
	return m.clearedbroken_streaks
}

// RemoveBrokenStreakIDs removes the "broken_streaks" edge to the Streak entity by IDs.
func (m *UserMutation) RemoveBrokenStreakIDs(ids ...string) {
	if m.removedbroken_streaks == nil {
		m.removedbroken_streaks = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.broken_streaks, ids[i])
		m.removedbroken_streaks[ids[i]] = struct{}{}
	}
}

// RemovedBrokenStreaks returns the removed IDs of the "broken_streaks" edge to the Streak entity.
func (m *UserMutation) RemovedBrokenStreaksIDs() (ids []string) {
	for id := range m.removedbroken_streaks {
		ids = append(ids, id)
	}
	return
}

// BrokenStreaksIDs returns the "broken_streaks" edge IDs in the mutation.
func (m *UserMutation) BrokenStreaksIDs() (ids []string) {
	for id := range m.broken_streaks {
		ids = append(ids, id)
	}
	return
}

// ResetBrokenStreaks resets all changes to the "broken_streaks" edge.
func (m *UserMutation) ResetBrokenStreaks() {
	m.broken_streaks = nil
	m.clearedbroken_streaks = false
	m.removedbroken_streaks = nil
}

// AddCheckInIDs adds the "check_ins" edge to the CheckIn entity by ids.
func (m *UserMutation) AddCheckInIDs(ids ...string) {
	if m.check_ins == nil {
		m.check_ins = make(map[string]struct{})
	}
	for i := range ids {
		m.check_ins[ids[i]] = struct{}{}
	}
}

// ClearCheckIns clears the "check_ins" edge to the CheckIn entity.
func (m *UserMutation) ClearCheckIns() {
	m.clearedcheck_ins = true
}

// CheckInsCleared reports if the "check_ins" edge to the CheckIn entity was cleared.
func (m *UserMutation) CheckInsCleared() bool {
	return m.clearedcheck_ins
}

// RemoveCheckInIDs removes the "check_ins" edge to the CheckIn entity by IDs.
func (m *UserMutation) RemoveCheckInIDs(ids ...string) {
	if m.removedcheck_ins == nil {
		m.removedcheck_ins = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.check_ins, ids[i])
		m.removedcheck_ins[ids[i]] = struct{}{}
	}
}

// RemovedCheckIns returns the removed IDs of the "check_ins" edge to the CheckIn entity.
func (m *UserMutation) RemovedCheckInsIDs() (ids []string) {
	for id := range m.removedcheck_ins {
		ids = append(ids, id)
	}
	return
}

// CheckInsIDs returns the "check_ins" edge IDs in the mutation.
func (m *UserMutation) CheckInsIDs() (ids []string) {
	for id := range m.check_ins {
		ids = append(ids, id)
	}
	return
}

// ResetCheckIns resets all changes to the "check_ins" edge.
func (m *UserMutation) ResetCheckIns() {
	m.check_ins = nil
	m.clearedcheck_ins = false
	m.removedcheck_ins = nil
}

// AddSentNudgeIDs adds the "sent_nudges" edge to the Nudge entity by ids.
func (m *UserMutation) AddSentNudgeIDs(ids ...string) {
	if m.sent_nudges == nil {
		m.sent_nudges = make(map[string]struct{})
	}
	for i := range ids {
		m.sent_nudges[ids[i]] = struct{}{}
	}
}

// ClearSentNudges clears the "sent_nudges" edge to the Nudge entity.
func (m *UserMutation) ClearSentNudges() {
	m.clearedsent_nudges = true
}

// SentNudgesCleared reports if the "sent_nudges" edge to the Nudge entity was cleared.
func (m *UserMutation) SentNudgesCleared() bool {
	return m.clearedsent_nudges
}

// RemoveSentNudgeIDs removes the "sent_nudges" edge to the Nudge entity by IDs.
func (m *UserMutation) RemoveSentNudgeIDs(ids ...string) {
	if m.removedsent_nudges == nil {
		m.removedsent_nudges = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sent_nudges, ids[i])
		m.removedsent_nudges[ids[i]] = struct{}{}
	}
}

// RemovedSentNudges returns the removed IDs of the "sent_nudges" edge to the Nudge entity.
func (m *UserMutation) RemovedSentNudgesIDs() (ids []string) {
	for id := range m.removedsent_nudges {
		ids = append(ids, id)
	}
	return
}

// SentNudgesIDs returns the "sent_nudges" edge IDs in the mutation.
func (m *UserMutation) SentNudgesIDs() (ids []string) {
	for id := range m.sent_nudges {
		ids = append(ids, id)
	}
	return
}

// ResetSentNudges resets all changes to the "sent_nudges" edge.
func (m *UserMutation) ResetSentNudges() {
	m.sent_nudges = nil
	m.clearedsent_nudges = false
	m.removedsent_nudges = nil
}

// AddReceivedNudgeIDs adds the "received_nudges" edge to the Nudge entity by ids.
func (m *UserMutation) AddReceivedNudgeIDs(ids ...string) {
	if m.received_nudges == nil {
		m.received_nudges = make(map[string]struct{})
	}
	for i := range ids {
		m.received_nudges[ids[i]] = struct{}{}
	}
}

// ClearReceivedNudges clears the "received_nudges" edge to the Nudge entity.
func (m *UserMutation) ClearReceivedNudges() {
	m.clearedreceived_nudges = true
}

// ReceivedNudgesCleared reports if the "received_nudges" edge to the Nudge entity was cleared.
func (m *UserMutation) ReceivedNudgesCleared() bool {
	return m.clearedreceived_nudges
}

// RemoveReceivedNudgeIDs removes the "received_nudges" edge to the Nudge entity by IDs.
func (m *UserMutation) RemoveReceivedNudgeIDs(ids ...string) {
	if m.removedreceived_nudges == nil {
		m.removedreceived_nudges = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.received_nudges, ids[i])
		m.removedreceived_nudges[ids[i]] = struct{}{}
	}
}

// RemovedReceivedNudges returns the removed IDs of the "received_nudges" edge to the Nudge entity.
func (m *UserMutation) RemovedReceivedNudgesIDs() (ids []string) {
	for id := range m.removedreceived_nudges {
		ids = append(ids, id)
	}
	return
}

// ReceivedNudgesIDs returns the "received_nudges" edge IDs in the mutation.
func (m *UserMutation) ReceivedNudgesIDs() (ids []string) {
	for id := range m.received_nudges {
		ids = append(ids, id)
	}
	return
}

// ResetReceivedNudges resets all changes to the "received_nudges" edge.
func (m *UserMutation) ResetReceivedNudges() {
	m.received_nudges = nil
	m.clearedreceived_nudges = false
	m.removedreceived_nudges = nil
}

// AddCreditTransactionIDs adds the "credit_transactions" edge to the CreditTransaction entity by ids.
func (m *UserMutation) AddCreditTransactionIDs(ids ...string) {
	if m.credit_transactions == nil {
		m.credit_transactions = make(map[string]struct{})
	}
	for i := range ids {
		m.credit_transactions[ids[i]] = struct{}{}
	}
}

// ClearCreditTransactions clears the "credit_transactions" edge to the CreditTransaction entity.
func (m *UserMutation) ClearCreditTransactions() {
	m.clearedcredit_transactions = true
}

// CreditTransactionsCleared reports if the "credit_transactions" edge to the CreditTransaction entity was cleared.
func (m *UserMutation) CreditTransactionsCleared() bool {
	return m.clearedcredit_transactions
}

// RemoveCreditTransactionIDs removes the "credit_transactions" edge to the CreditTransaction entity by IDs.
func (m *UserMutation) RemoveCreditTransactionIDs(ids ...string) {
	if m.removedcredit_transactions == nil {
		m.removedcredit_transactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.credit_transactions, ids[i])
		m.removedcredit_transactions[ids[i]] = struct{}{}
	}
}

// RemovedCreditTransactions returns the removed IDs of the "credit_transactions" edge to the CreditTransaction entity.
func (m *UserMutation) RemovedCreditTransactionsIDs() (ids []string) {
	for id := range m.removedcredit_transactions {
		ids = append(ids, id)
	}
	return
}

// CreditTransactionsIDs returns the "credit_transactions" edge IDs in the mutation.
func (m *UserMutation) CreditTransactionsIDs() (ids []string) {
	for id := range m.credit_transactions {
		ids = append(ids, id)
	}
	return
}

// ResetCreditTransactions resets all changes to the "credit_transactions" edge.
func (m *UserMutation) ResetCreditTransactions() {
	m.credit_transactions = nil
	m.clearedcredit_transactions = false
	m.removedcredit_transactions = nil
}

// AddPaymentOrderIDs adds the "payment_orders" edge to the PaymentOrder entity by ids.
func (m *UserMutation) AddPaymentOrderIDs(ids ...string) {
	if m.payment_orders == nil {
		m.payment_orders = make(map[string]struct{})
	}
	for i := range ids {
		m.payment_orders[ids[i]] = struct{}{}
	}
}

// ClearPaymentOrders clears the "payment_orders" edge to the PaymentOrder entity.
func (m *UserMutation) ClearPaymentOrders() {
	m.clearedpayment_orders = true
}

// PaymentOrdersCleared reports if the "payment_orders" edge to the PaymentOrder entity was cleared.
func (m *UserMutation) PaymentOrdersCleared() bool {
	return m.clearedpayment_orders
}

// RemovePaymentOrderIDs removes the "payment_orders" edge to the PaymentOrder entity by IDs.
func (m *UserMutation) RemovePaymentOrderIDs(ids ...string) {
	if m.removedpayment_orders == nil {
		m.removedpayment_orders = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.payment_orders, ids[i])
		m.removedpayment_orders[ids[i]] = struct{}{}
	}
}

// RemovedPaymentOrders returns the removed IDs of the "payment_orders" edge to the PaymentOrder entity.
func (m *UserMutation) RemovedPaymentOrdersIDs() (ids []string) {
	for id := range m.removedpayment_orders {
		ids = append(ids, id)
	}
	return
}

// PaymentOrdersIDs returns the "payment_orders" edge IDs in the mutation.
func (m *UserMutation) PaymentOrdersIDs() (ids []string) {
	for id := range m.payment_orders {
		ids = append(ids, id)
	}
	return
}

// ResetPaymentOrders resets all changes to the "payment_orders" edge.
func (m *UserMutation) ResetPaymentOrders() {
	m.payment_orders = nil
	m.clearedpayment_orders = false
	m.removedpayment_orders = nil
}

// AddBlocksGivenIDs adds the "blocks_given" edge to the UserBlock entity by ids.
func (m *UserMutation) AddBlocksGivenIDs(ids ...string) {
	if m.blocks_given == nil {
		m.blocks_given = make(map[string]struct{})
	}
	for i := range ids {
		m.blocks_given[ids[i]] = struct{}{}
	}
}

// ClearBlocksGiven clears the "blocks_given" edge to the UserBlock entity.
func (m *UserMutation) ClearBlocksGiven() {
	m.clearedblocks_given = true
}

// BlocksGivenCleared reports if the "blocks_given" edge to the UserBlock entity was cleared.
func (m *UserMutation) BlocksGivenCleared() bool {
	return m.clearedblocks_given
}

// RemoveBlocksGivenIDs removes the "blocks_given" edge to the UserBlock entity by IDs.
func (m *UserMutation) RemoveBlocksGivenIDs(ids ...string) {
	if m.removedblocks_given == nil {
		m.removedblocks_given = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.blocks_given, ids[i])
		m.removedblocks_given[ids[i]] = struct{}{}
	}
}

// RemovedBlocksGiven returns the removed IDs of the "blocks_given" edge to the UserBlock entity.
func (m *UserMutation) RemovedBlocksGivenIDs() (ids []string) {
	for id := range m.removedblocks_given {
		ids = append(ids, id)
	}
	return
}

// BlocksGivenIDs returns the "blocks_given" edge IDs in the mutation.
func (m *UserMutation) BlocksGivenIDs() (ids []string) {
	for id := range m.blocks_given {
		ids = append(ids, id)
	}
	return
}

// ResetBlocksGiven resets all changes to the "blocks_given" edge.
func (m *UserMutation) ResetBlocksGiven() {
	m.blocks_given = nil
	m.clearedblocks_given = false
	m.removedblocks_given = nil
}

// AddBlocksReceivedIDs adds the "blocks_received" edge to the UserBlock entity by ids.
func (m *UserMutation) AddBlocksReceivedIDs(ids ...string) {
	if m.blocks_received == nil {
		m.blocks_received = make(map[string]struct{})
	}
	for i := range ids {
		m.blocks_received[ids[i]] = struct{}{}
	}
}

// ClearBlocksReceived clears the "blocks_received" edge to the UserBlock entity.
func (m *UserMutation) ClearBlocksReceived() {
	m.clearedblocks_received = true
}

// BlocksReceivedCleared reports if the "blocks_received" edge to the UserBlock entity was cleared.
func (m *UserMutation) BlocksReceivedCleared() bool {
	return m.clearedblocks_received
}

// RemoveBlocksReceivedIDs removes the "blocks_received" edge to the UserBlock entity by IDs.
func (m *UserMutation) RemoveBlocksReceivedIDs(ids ...string) {
	if m.removedblocks_received == nil {
		m.removedblocks_received = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.blocks_received, ids[i])
		m.removedblocks_received[ids[i]] = struct{}{}
	}
}

// RemovedBlocksReceived returns the removed IDs of the "blocks_received" edge to the UserBlock entity.
func (m *UserMutation) RemovedBlocksReceivedIDs() (ids []string) {
	for id := range m.removedblocks_received {
		ids = append(ids, id)
	}
	return
}

// BlocksReceivedIDs returns the "blocks_received" edge IDs in the mutation.
func (m *UserMutation) BlocksReceivedIDs() (ids []string) {
	for id := range m.blocks_received {
		ids = append(ids, id)
	}
	return
}

// ResetBlocksReceived resets all changes to the "blocks_received" edge.
func (m *UserMutation) ResetBlocksReceived() {
	m.blocks_received = nil
	m.clearedblocks_received = false
	m.removedblocks_received = nil
}

// AddReportsGivenIDs adds the "reports_given" edge to the UserReport entity by ids.
func (m *UserMutation) AddReportsGivenIDs(ids ...string) {
	if m.reports_given == nil {
		m.reports_given = make(map[string]struct{})
	}
	for i := range ids {
		m.reports_given[ids[i]] = struct{}{}
	}
}

// ClearReportsGiven clears the "reports_given" edge to the UserReport entity.
func (m *UserMutation) ClearReportsGiven() {
	m.clearedreports_given = true
}

// ReportsGivenCleared reports if the "reports_given" edge to the UserReport entity was cleared.
func (m *UserMutation) ReportsGivenCleared() bool {
	return m.clearedreports_given
}

// RemoveReportsGivenIDs removes the "reports_given" edge to the UserReport entity by IDs.
func (m *UserMutation) RemoveReportsGivenIDs(ids ...string) {
	if m.removedreports_given == nil {
		m.removedreports_given = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reports_given, ids[i])
		m.removedreports_given[ids[i]] = struct{}{}
	}
}

// RemovedReportsGiven returns the removed IDs of the "reports_given" edge to the UserReport entity.
func (m *UserMutation) RemovedReportsGivenIDs() (ids []string) {
	for id := range m.removedreports_given {
		ids = append(ids, id)
	}
	return
}

// ReportsGivenIDs returns the "reports_given" edge IDs in the mutation.
func (m *UserMutation) ReportsGivenIDs() (ids []string) {
	for id := range m.reports_given {
		ids = append(ids, id)
	}
	return
}

// ResetReportsGiven resets all changes to the "reports_given" edge.
func (m *UserMutation) ResetReportsGiven() {
	m.reports_given = nil
	m.clearedreports_given = false
	m.removedreports_given = nil
}

// AddReportsReceivedIDs adds the "reports_received" edge to the UserReport entity by ids.
func (m *UserMutation) AddReportsReceivedIDs(ids ...string) {
	if m.reports_received == nil {
		m.reports_received = make(map[string]struct{})
	}
	for i := range ids {
		m.reports_received[ids[i]] = struct{}{}
	}
}

// ClearReportsReceived clears the "reports_received" edge to the UserReport entity.
func (m *UserMutation) ClearReportsReceived() {
	m.clearedreports_received = true
}

// ReportsReceivedCleared reports if the "reports_received" edge to the UserReport entity was cleared.
func (m *UserMutation) ReportsReceivedCleared() bool {
	return m.clearedreports_received
}

// RemoveReportsReceivedIDs removes the "reports_received" edge to the UserReport entity by IDs.
func (m *UserMutation) RemoveReportsReceivedIDs(ids ...string) {
	if m.removedreports_received == nil {
		m.removedreports_received = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reports_received, ids[i])
		m.removedreports_received[ids[i]] = struct{}{}
	}
}

// RemovedReportsReceived returns the removed IDs of the "reports_received" edge to the UserReport entity.
func (m *UserMutation) RemovedReportsReceivedIDs() (ids []string) {
	for id := range m.removedreports_received {
		ids = append(ids, id)
	}
	return
}

// ReportsReceivedIDs returns the "reports_received" edge IDs in the mutation.
func (m *UserMutation) ReportsReceivedIDs() (ids []string) {
	for id := range m.reports_received {
		ids = append(ids, id)
	}
	return
}

// ResetReportsReceived resets all changes to the "reports_received" edge.
func (m *UserMutation) ResetReportsReceived() {
	m.reports_received = nil
	m.clearedreports_received = false
	m.removedreports_received = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 34)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.phone_country_code != nil {
		fields = append(fields, user.FieldPhoneCountryCode)
	}
	if m.provider != nil {
		fields = append(fields, user.FieldProvider)
	}
	if m.provider_user_id != nil {
		fields = append(fields, user.FieldProviderUserID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.picture != nil {
		fields = append(fields, user.FieldPicture)
	}
	if m.date_of_birth != nil {
		fields = append(fields, user.FieldDateOfBirth)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.city != nil {
		fields = append(fields, user.FieldCity)
	}
	if m.education != nil {
		fields = append(fields, user.FieldEducation)
	}
	if m.profession != nil {
		fields = append(fields, user.FieldProfession)
	}
	if m.religion != nil {
		fields = append(fields, user.FieldReligion)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.verification_status != nil {
		fields = append(fields, user.FieldVerificationStatus)
	}
	if m.subscription_tier != nil {
		fields = append(fields, user.FieldSubscriptionTier)
	}
	if m.free_recoveries_used != nil {
		fields = append(fields, user.FieldFreeRecoveriesUsed)
	}
	if m.nudges_sent_today != nil {
		fields = append(fields, user.FieldNudgesSentToday)
	}
	if m.nudges_reset_at != nil {
		fields = append(fields, user.FieldNudgesResetAt)
	}
	if m.active_connection_count != nil {
		fields = append(fields, user.FieldActiveConnectionCount)
	}
	if m.last_global_refresh_at != nil {
		fields = append(fields, user.FieldLastGlobalRefreshAt)
	}
	if m.refresh_available_at != nil {
		fields = append(fields, user.FieldRefreshAvailableAt)
	}
	if m.credit_balance != nil {
		fields = append(fields, user.FieldCreditBalance)
	}
	if m.behavioral_trust_score != nil {
		fields = append(fields, user.FieldBehavioralTrustScore)
	}
	if m.account_status != nil {
		fields = append(fields, user.FieldAccountStatus)
	}
	if m.onboarding_status != nil {
		fields = append(fields, user.FieldOnboardingStatus)
	}
	if m.last_active_at != nil {
		fields = append(fields, user.FieldLastActiveAt)
	}
	if m.suspended_at != nil {
		fields = append(fields, user.FieldSuspendedAt)
	}
	if m.suspension_reason != nil {
		fields = append(fields, user.FieldSuspensionReason)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldPhoneCountryCode:
		return m.PhoneCountryCode()
	case user.FieldProvider:
		return m.Provider()
	case user.FieldProviderUserID:
		return m.ProviderUserID()
	case user.FieldName:
		return m.Name()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldPicture:
		return m.Picture()
	case user.FieldDateOfBirth:
		return m.DateOfBirth()
	case user.FieldGender:
		return m.Gender()
	case user.FieldCity:
		return m.City()
	case user.FieldEducation:
		return m.Education()
	case user.FieldProfession:
		return m.Profession()
	case user.FieldReligion:
		return m.Religion()
	case user.FieldBio:
		return m.Bio()
	case user.FieldVerificationStatus:
		return m.VerificationStatus()
	case user.FieldSubscriptionTier:
		return m.SubscriptionTier()
	case user.FieldFreeRecoveriesUsed:
		return m.FreeRecoveriesUsed()
	case user.FieldNudgesSentToday:
		return m.NudgesSentToday()
	case user.FieldNudgesResetAt:
		return m.NudgesResetAt()
	case user.FieldActiveConnectionCount:
		return m.ActiveConnectionCount()
	case user.FieldLastGlobalRefreshAt:
		return m.LastGlobalRefreshAt()
	case user.FieldRefreshAvailableAt:
		return m.RefreshAvailableAt()
	case user.FieldCreditBalance:
		return m.CreditBalance()
	case user.FieldBehavioralTrustScore:
		return m.BehavioralTrustScore()
	case user.FieldAccountStatus:
		return m.AccountStatus()
	case user.FieldOnboardingStatus:
		return m.OnboardingStatus()
	case user.FieldLastActiveAt:
		return m.LastActiveAt()
	case user.FieldSuspendedAt:
		return m.SuspendedAt()
	case user.FieldSuspensionReason:
		return m.SuspensionReason()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldPhoneCountryCode:
		return m.OldPhoneCountryCode(ctx)
	case user.FieldProvider:
		return m.OldProvider(ctx)
	case user.FieldProviderUserID:
		return m.OldProviderUserID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldPicture:
		return m.OldPicture(ctx)
	case user.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldCity:
		return m.OldCity(ctx)
	case user.FieldEducation:
		return m.OldEducation(ctx)
	case user.FieldProfession:
		return m.OldProfession(ctx)
	case user.FieldReligion:
		return m.OldReligion(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldVerificationStatus:
		return m.OldVerificationStatus(ctx)
	case user.FieldSubscriptionTier:
		return m.OldSubscriptionTier(ctx)
	case user.FieldFreeRecoveriesUsed:
		return m.OldFreeRecoveriesUsed(ctx)
	case user.FieldNudgesSentToday:
		return m.OldNudgesSentToday(ctx)
	case user.FieldNudgesResetAt:
		return m.OldNudgesResetAt(ctx)
	case user.FieldActiveConnectionCount:
		return m.OldActiveConnectionCount(ctx)
	case user.FieldLastGlobalRefreshAt:
		return m.OldLastGlobalRefreshAt(ctx)
	case user.FieldRefreshAvailableAt:
		return m.OldRefreshAvailableAt(ctx)
	case user.FieldCreditBalance:
		return m.OldCreditBalance(ctx)
	case user.FieldBehavioralTrustScore:
		return m.OldBehavioralTrustScore(ctx)
	case user.FieldAccountStatus:
		return m.OldAccountStatus(ctx)
	case user.FieldOnboardingStatus:
		return m.OldOnboardingStatus(ctx)
	case user.FieldLastActiveAt:
		return m.OldLastActiveAt(ctx)
	case user.FieldSuspendedAt:
		return m.OldSuspendedAt(ctx)
	case user.FieldSuspensionReason:
		return m.OldSuspensionReason(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldPhoneCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneCountryCode(v)
		return nil
	case user.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case user.FieldProviderUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderUserID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case user.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case user.FieldGender:
		v, ok := value.(user.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case user.FieldEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEducation(v)
		return nil
	case user.FieldProfession:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfession(v)
		return nil
	case user.FieldReligion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReligion(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldVerificationStatus:
		v, ok := value.(user.VerificationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationStatus(v)
		return nil
	case user.FieldSubscriptionTier:
		v, ok := value.(user.SubscriptionTier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionTier(v)
		return nil
	case user.FieldFreeRecoveriesUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeRecoveriesUsed(v)
		return nil
	case user.FieldNudgesSentToday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNudgesSentToday(v)
		return nil
	case user.FieldNudgesResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNudgesResetAt(v)
		return nil
	case user.FieldActiveConnectionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActiveConnectionCount(v)
		return nil
	case user.FieldLastGlobalRefreshAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastGlobalRefreshAt(v)
		return nil
	case user.FieldRefreshAvailableAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshAvailableAt(v)
		return nil
	case user.FieldCreditBalance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditBalance(v)
		return nil
	case user.FieldBehavioralTrustScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBehavioralTrustScore(v)
		return nil
	case user.FieldAccountStatus:
		v, ok := value.(user.AccountStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountStatus(v)
		return nil
	case user.FieldOnboardingStatus:
		v, ok := value.(user.OnboardingStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnboardingStatus(v)
		return nil
	case user.FieldLastActiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastActiveAt(v)
		return nil
	case user.FieldSuspendedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendedAt(v)
		return nil
	case user.FieldSuspensionReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspensionReason(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addfree_recoveries_used != nil {
		fields = append(fields, user.FieldFreeRecoveriesUsed)
	}
	if m.addnudges_sent_today != nil {
		fields = append(fields, user.FieldNudgesSentToday)
	}
	if m.addactive_connection_count != nil {
		fields = append(fields, user.FieldActiveConnectionCount)
	}
	if m.addcredit_balance != nil {
		fields = append(fields, user.FieldCreditBalance)
	}
	if m.addbehavioral_trust_score != nil {
		fields = append(fields, user.FieldBehavioralTrustScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFreeRecoveriesUsed:
		return m.AddedFreeRecoveriesUsed()
	case user.FieldNudgesSentToday:
		return m.AddedNudgesSentToday()
	case user.FieldActiveConnectionCount:
		return m.AddedActiveConnectionCount()
	case user.FieldCreditBalance:
		return m.AddedCreditBalance()
	case user.FieldBehavioralTrustScore:
		return m.AddedBehavioralTrustScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldFreeRecoveriesUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeRecoveriesUsed(v)
		return nil
	case user.FieldNudgesSentToday:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNudgesSentToday(v)
		return nil
	case user.FieldActiveConnectionCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActiveConnectionCount(v)
		return nil
	case user.FieldCreditBalance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditBalance(v)
		return nil
	case user.FieldBehavioralTrustScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBehavioralTrustScore(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldPhoneCountryCode) {
		fields = append(fields, user.FieldPhoneCountryCode)
	}
	if m.FieldCleared(user.FieldProvider) {
		fields = append(fields, user.FieldProvider)
	}
	if m.FieldCleared(user.FieldProviderUserID) {
		fields = append(fields, user.FieldProviderUserID)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldPicture) {
		fields = append(fields, user.FieldPicture)
	}
	if m.FieldCleared(user.FieldDateOfBirth) {
		fields = append(fields, user.FieldDateOfBirth)
	}
	if m.FieldCleared(user.FieldGender) {
		fields = append(fields, user.FieldGender)
	}
	if m.FieldCleared(user.FieldCity) {
		fields = append(fields, user.FieldCity)
	}
	if m.FieldCleared(user.FieldEducation) {
		fields = append(fields, user.FieldEducation)
	}
	if m.FieldCleared(user.FieldProfession) {
		fields = append(fields, user.FieldProfession)
	}
	if m.FieldCleared(user.FieldReligion) {
		fields = append(fields, user.FieldReligion)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldNudgesResetAt) {
		fields = append(fields, user.FieldNudgesResetAt)
	}
	if m.FieldCleared(user.FieldLastGlobalRefreshAt) {
		fields = append(fields, user.FieldLastGlobalRefreshAt)
	}
	if m.FieldCleared(user.FieldRefreshAvailableAt) {
		fields = append(fields, user.FieldRefreshAvailableAt)
	}
	if m.FieldCleared(user.FieldBehavioralTrustScore) {
		fields = append(fields, user.FieldBehavioralTrustScore)
	}
	if m.FieldCleared(user.FieldLastActiveAt) {
		fields = append(fields, user.FieldLastActiveAt)
	}
	if m.FieldCleared(user.FieldSuspendedAt) {
		fields = append(fields, user.FieldSuspendedAt)
	}
	if m.FieldCleared(user.FieldSuspensionReason) {
		fields = append(fields, user.FieldSuspensionReason)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldPhoneCountryCode:
		m.ClearPhoneCountryCode()
		return nil
	case user.FieldProvider:
		m.ClearProvider()
		return nil
	case user.FieldProviderUserID:
		m.ClearProviderUserID()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldPicture:
		m.ClearPicture()
		return nil
	case user.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case user.FieldGender:
		m.ClearGender()
		return nil
	case user.FieldCity:
		m.ClearCity()
		return nil
	case user.FieldEducation:
		m.ClearEducation()
		return nil
	case user.FieldProfession:
		m.ClearProfession()
		return nil
	case user.FieldReligion:
		m.ClearReligion()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldNudgesResetAt:
		m.ClearNudgesResetAt()
		return nil
	case user.FieldLastGlobalRefreshAt:
		m.ClearLastGlobalRefreshAt()
		return nil
	case user.FieldRefreshAvailableAt:
		m.ClearRefreshAvailableAt()
		return nil
	case user.FieldBehavioralTrustScore:
		m.ClearBehavioralTrustScore()
		return nil
	case user.FieldLastActiveAt:
		m.ClearLastActiveAt()
		return nil
	case user.FieldSuspendedAt:
		m.ClearSuspendedAt()
		return nil
	case user.FieldSuspensionReason:
		m.ClearSuspensionReason()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldPhoneCountryCode:
		m.ResetPhoneCountryCode()
		return nil
	case user.FieldProvider:
		m.ResetProvider()
		return nil
	case user.FieldProviderUserID:
		m.ResetProviderUserID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldPicture:
		m.ResetPicture()
		return nil
	case user.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldCity:
		m.ResetCity()
		return nil
	case user.FieldEducation:
		m.ResetEducation()
		return nil
	case user.FieldProfession:
		m.ResetProfession()
		return nil
	case user.FieldReligion:
		m.ResetReligion()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldVerificationStatus:
		m.ResetVerificationStatus()
		return nil
	case user.FieldSubscriptionTier:
		m.ResetSubscriptionTier()
		return nil
	case user.FieldFreeRecoveriesUsed:
		m.ResetFreeRecoveriesUsed()
		return nil
	case user.FieldNudgesSentToday:
		m.ResetNudgesSentToday()
		return nil
	case user.FieldNudgesResetAt:
		m.ResetNudgesResetAt()
		return nil
	case user.FieldActiveConnectionCount:
		m.ResetActiveConnectionCount()
		return nil
	case user.FieldLastGlobalRefreshAt:
		m.ResetLastGlobalRefreshAt()
		return nil
	case user.FieldRefreshAvailableAt:
		m.ResetRefreshAvailableAt()
		return nil
	case user.FieldCreditBalance:
		m.ResetCreditBalance()
		return nil
	case user.FieldBehavioralTrustScore:
		m.ResetBehavioralTrustScore()
		return nil
	case user.FieldAccountStatus:
		m.ResetAccountStatus()
		return nil
	case user.FieldOnboardingStatus:
		m.ResetOnboardingStatus()
		return nil
	case user.FieldLastActiveAt:
		m.ResetLastActiveAt()
		return nil
	case user.FieldSuspendedAt:
		m.ResetSuspendedAt()
		return nil
	case user.FieldSuspensionReason:
		m.ResetSuspensionReason()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 20)
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	if m.photos != nil {
		edges = append(edges, user.EdgePhotos)
	}
	if m.hobbies != nil {
		edges = append(edges, user.EdgeHobbies)
	}
	if m.filters != nil {
		edges = append(edges, user.EdgeFilters)
	}
	if m.discovery_batches != nil {
		edges = append(edges, user.EdgeDiscoveryBatches)
	}
	if m.discovery_appearances != nil {
		edges = append(edges, user.EdgeDiscoveryAppearances)
	}
	if m.sent_interests != nil {
		edges = append(edges, user.EdgeSentInterests)
	}
	if m.received_interests != nil {
		edges = append(edges, user.EdgeReceivedInterests)
	}
	if m.connections_as_a != nil {
		edges = append(edges, user.EdgeConnectionsAsA)
	}
	if m.connections_as_b != nil {
		edges = append(edges, user.EdgeConnectionsAsB)
	}
	if m.broken_streaks != nil {
		edges = append(edges, user.EdgeBrokenStreaks)
	}
	if m.check_ins != nil {
		edges = append(edges, user.EdgeCheckIns)
	}
	if m.sent_nudges != nil {
		edges = append(edges, user.EdgeSentNudges)
	}
	if m.received_nudges != nil {
		edges = append(edges, user.EdgeReceivedNudges)
	}
	if m.credit_transactions != nil {
		edges = append(edges, user.EdgeCreditTransactions)
	}
	if m.payment_orders != nil {
		edges = append(edges, user.EdgePaymentOrders)
	}
	if m.blocks_given != nil {
		edges = append(edges, user.EdgeBlocksGiven)
	}
	if m.blocks_received != nil {
		edges = append(edges, user.EdgeBlocksReceived)
	}
	if m.reports_given != nil {
		edges = append(edges, user.EdgeReportsGiven)
	}
	if m.reports_received != nil {
		edges = append(edges, user.EdgeReportsReceived)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePhotos:
		ids := make([]ent.Value, 0, len(m.photos))
		for id := range m.photos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHobbies:
		ids := make([]ent.Value, 0, len(m.hobbies))
		for id := range m.hobbies {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.filters))
		for id := range m.filters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDiscoveryBatches:
		ids := make([]ent.Value, 0, len(m.discovery_batches))
		for id := range m.discovery_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDiscoveryAppearances:
		ids := make([]ent.Value, 0, len(m.discovery_appearances))
		for id := range m.discovery_appearances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentInterests:
		ids := make([]ent.Value, 0, len(m.sent_interests))
		for id := range m.sent_interests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedInterests:
		ids := make([]ent.Value, 0, len(m.received_interests))
		for id := range m.received_interests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConnectionsAsA:
		ids := make([]ent.Value, 0, len(m.connections_as_a))
		for id := range m.connections_as_a {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConnectionsAsB:
		ids := make([]ent.Value, 0, len(m.connections_as_b))
		for id := range m.connections_as_b {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBrokenStreaks:
		ids := make([]ent.Value, 0, len(m.broken_streaks))
		for id := range m.broken_streaks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckIns:
		ids := make([]ent.Value, 0, len(m.check_ins))
		for id := range m.check_ins {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentNudges:
		ids := make([]ent.Value, 0, len(m.sent_nudges))
		for id := range m.sent_nudges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedNudges:
		ids := make([]ent.Value, 0, len(m.received_nudges))
		for id := range m.received_nudges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreditTransactions:
		ids := make([]ent.Value, 0, len(m.credit_transactions))
		for id := range m.credit_transactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePaymentOrders:
		ids := make([]ent.Value, 0, len(m.payment_orders))
		for id := range m.payment_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlocksGiven:
		ids := make([]ent.Value, 0, len(m.blocks_given))
		for id := range m.blocks_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlocksReceived:
		ids := make([]ent.Value, 0, len(m.blocks_received))
		for id := range m.blocks_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReportsGiven:
		ids := make([]ent.Value, 0, len(m.reports_given))
		for id := range m.reports_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReportsReceived:
		ids := make([]ent.Value, 0, len(m.reports_received))
		for id := range m.reports_received {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 20)
	if m.removedphotos != nil {
		edges = append(edges, user.EdgePhotos)
	}
	if m.removedhobbies != nil {
		edges = append(edges, user.EdgeHobbies)
	}
	if m.removedfilters != nil {
		edges = append(edges, user.EdgeFilters)
	}
	if m.removeddiscovery_batches != nil {
		edges = append(edges, user.EdgeDiscoveryBatches)
	}
	if m.removeddiscovery_appearances != nil {
		edges = append(edges, user.EdgeDiscoveryAppearances)
	}
	if m.removedsent_interests != nil {
		edges = append(edges, user.EdgeSentInterests)
	}
	if m.removedreceived_interests != nil {
		edges = append(edges, user.EdgeReceivedInterests)
	}
	if m.removedconnections_as_a != nil {
		edges = append(edges, user.EdgeConnectionsAsA)
	}
	if m.removedconnections_as_b != nil {
		edges = append(edges, user.EdgeConnectionsAsB)
	}
	if m.removedbroken_streaks != nil {
		edges = append(edges, user.EdgeBrokenStreaks)
	}
	if m.removedcheck_ins != nil {
		edges = append(edges, user.EdgeCheckIns)
	}
	if m.removedsent_nudges != nil {
		edges = append(edges, user.EdgeSentNudges)
	}
	if m.removedreceived_nudges != nil {
		edges = append(edges, user.EdgeReceivedNudges)
	}
	if m.removedcredit_transactions != nil {
		edges = append(edges, user.EdgeCreditTransactions)
	}
	if m.removedpayment_orders != nil {
		edges = append(edges, user.EdgePaymentOrders)
	}
	if m.removedblocks_given != nil {
		edges = append(edges, user.EdgeBlocksGiven)
	}
	if m.removedblocks_received != nil {
		edges = append(edges, user.EdgeBlocksReceived)
	}
	if m.removedreports_given != nil {
		edges = append(edges, user.EdgeReportsGiven)
	}
	if m.removedreports_received != nil {
		edges = append(edges, user.EdgeReportsReceived)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgePhotos:
		ids := make([]ent.Value, 0, len(m.removedphotos))
		for id := range m.removedphotos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHobbies:
		ids := make([]ent.Value, 0, len(m.removedhobbies))
		for id := range m.removedhobbies {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removedfilters))
		for id := range m.removedfilters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDiscoveryBatches:
		ids := make([]ent.Value, 0, len(m.removeddiscovery_batches))
		for id := range m.removeddiscovery_batches {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDiscoveryAppearances:
		ids := make([]ent.Value, 0, len(m.removeddiscovery_appearances))
		for id := range m.removeddiscovery_appearances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentInterests:
		ids := make([]ent.Value, 0, len(m.removedsent_interests))
		for id := range m.removedsent_interests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedInterests:
		ids := make([]ent.Value, 0, len(m.removedreceived_interests))
		for id := range m.removedreceived_interests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConnectionsAsA:
		ids := make([]ent.Value, 0, len(m.removedconnections_as_a))
		for id := range m.removedconnections_as_a {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConnectionsAsB:
		ids := make([]ent.Value, 0, len(m.removedconnections_as_b))
		for id := range m.removedconnections_as_b {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBrokenStreaks:
		ids := make([]ent.Value, 0, len(m.removedbroken_streaks))
		for id := range m.removedbroken_streaks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCheckIns:
		ids := make([]ent.Value, 0, len(m.removedcheck_ins))
		for id := range m.removedcheck_ins {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentNudges:
		ids := make([]ent.Value, 0, len(m.removedsent_nudges))
		for id := range m.removedsent_nudges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedNudges:
		ids := make([]ent.Value, 0, len(m.removedreceived_nudges))
		for id := range m.removedreceived_nudges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreditTransactions:
		ids := make([]ent.Value, 0, len(m.removedcredit_transactions))
		for id := range m.removedcredit_transactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePaymentOrders:
		ids := make([]ent.Value, 0, len(m.removedpayment_orders))
		for id := range m.removedpayment_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlocksGiven:
		ids := make([]ent.Value, 0, len(m.removedblocks_given))
		for id := range m.removedblocks_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBlocksReceived:
		ids := make([]ent.Value, 0, len(m.removedblocks_received))
		for id := range m.removedblocks_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReportsGiven:
		ids := make([]ent.Value, 0, len(m.removedreports_given))
		for id := range m.removedreports_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReportsReceived:
		ids := make([]ent.Value, 0, len(m.removedreports_received))
		for id := range m.removedreports_received {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 20)
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	if m.clearedphotos {
		edges = append(edges, user.EdgePhotos)
	}
	if m.clearedhobbies {
		edges = append(edges, user.EdgeHobbies)
	}
	if m.clearedfilters {
		edges = append(edges, user.EdgeFilters)
	}
	if m.cleareddiscovery_batches {
		edges = append(edges, user.EdgeDiscoveryBatches)
	}
	if m.cleareddiscovery_appearances {
		edges = append(edges, user.EdgeDiscoveryAppearances)
	}
	if m.clearedsent_interests {
		edges = append(edges, user.EdgeSentInterests)
	}
	if m.clearedreceived_interests {
		edges = append(edges, user.EdgeReceivedInterests)
	}
	if m.clearedconnections_as_a {
		edges = append(edges, user.EdgeConnectionsAsA)
	}
	if m.clearedconnections_as_b {
		edges = append(edges, user.EdgeConnectionsAsB)
	}
	if m.clearedbroken_streaks {
		edges = append(edges, user.EdgeBrokenStreaks)
	}
	if m.clearedcheck_ins {
		edges = append(edges, user.EdgeCheckIns)
	}
	if m.clearedsent_nudges {
		edges = append(edges, user.EdgeSentNudges)
	}
	if m.clearedreceived_nudges {
		edges = append(edges, user.EdgeReceivedNudges)
	}
	if m.clearedcredit_transactions {
		edges = append(edges, user.EdgeCreditTransactions)
	}
	if m.clearedpayment_orders {
		edges = append(edges, user.EdgePaymentOrders)
	}
	if m.clearedblocks_given {
		edges = append(edges, user.EdgeBlocksGiven)
	}
	if m.clearedblocks_received {
		edges = append(edges, user.EdgeBlocksReceived)
	}
	if m.clearedreports_given {
		edges = append(edges, user.EdgeReportsGiven)
	}
	if m.clearedreports_received {
		edges = append(edges, user.EdgeReportsReceived)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProfile:
		return m.clearedprofile
	case user.EdgePhotos:
		return m.clearedphotos
	case user.EdgeHobbies:
		return m.clearedhobbies
	case user.EdgeFilters:
		return m.clearedfilters
	case user.EdgeDiscoveryBatches:
		return m.cleareddiscovery_batches
	case user.EdgeDiscoveryAppearances:
		return m.cleareddiscovery_appearances
	case user.EdgeSentInterests:
		return m.clearedsent_interests
	case user.EdgeReceivedInterests:
		return m.clearedreceived_interests
	case user.EdgeConnectionsAsA:
		return m.clearedconnections_as_a
	case user.EdgeConnectionsAsB:
		return m.clearedconnections_as_b
	case user.EdgeBrokenStreaks:
		return m.clearedbroken_streaks
	case user.EdgeCheckIns:
		return m.clearedcheck_ins
	case user.EdgeSentNudges:
		return m.clearedsent_nudges
	case user.EdgeReceivedNudges:
		return m.clearedreceived_nudges
	case user.EdgeCreditTransactions:
		return m.clearedcredit_transactions
	case user.EdgePaymentOrders:
		return m.clearedpayment_orders
	case user.EdgeBlocksGiven:
		return m.clearedblocks_given
	case user.EdgeBlocksReceived:
		return m.clearedblocks_received
	case user.EdgeReportsGiven:
		return m.clearedreports_given
	case user.EdgeReportsReceived:
		return m.clearedreports_received
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	case user.EdgePhotos:
		m.ResetPhotos()
		return nil
	case user.EdgeHobbies:
		m.ResetHobbies()
		return nil
	case user.EdgeFilters:
		m.ResetFilters()
		return nil
	case user.EdgeDiscoveryBatches:
		m.ResetDiscoveryBatches()
		return nil
	case user.EdgeDiscoveryAppearances:
		m.ResetDiscoveryAppearances()
		return nil
	case user.EdgeSentInterests:
		m.ResetSentInterests()
		return nil
	case user.EdgeReceivedInterests:
		m.ResetReceivedInterests()
		return nil
	case user.EdgeConnectionsAsA:
		m.ResetConnectionsAsA()
		return nil
	case user.EdgeConnectionsAsB:
		m.ResetConnectionsAsB()
		return nil
	case user.EdgeBrokenStreaks:
		m.ResetBrokenStreaks()
		return nil
	case user.EdgeCheckIns:
		m.ResetCheckIns()
		return nil
	case user.EdgeSentNudges:
		m.ResetSentNudges()
		return nil
	case user.EdgeReceivedNudges:
		m.ResetReceivedNudges()
		return nil
	case user.EdgeCreditTransactions:
		m.ResetCreditTransactions()
		return nil
	case user.EdgePaymentOrders:
		m.ResetPaymentOrders()
		return nil
	case user.EdgeBlocksGiven:
		m.ResetBlocksGiven()
		return nil
	case user.EdgeBlocksReceived:
		m.ResetBlocksReceived()
		return nil
	case user.EdgeReportsGiven:
		m.ResetReportsGiven()
		return nil
	case user.EdgeReportsReceived:
		m.ResetReportsReceived()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBlockMutation represents an operation that mutates the UserBlock nodes in the graph.
type UserBlockMutation struct {
	config
	op             Op
	typ            string
	id             *string
	reason         *string
	created_at     *time.Time
	unblocked_at   *time.Time
	clearedFields  map[string]struct{}
	blocker        *string
	clearedblocker bool
	blocked        *string
	clearedblocked bool
	done           bool
	oldValue       func(context.Context) (*UserBlock, error)
	predicates     []predicate.UserBlock
}

var _ ent.Mutation = (*UserBlockMutation)(nil)

// userblockOption allows management of the mutation configuration using functional options.
type userblockOption func(*UserBlockMutation)

// newUserBlockMutation creates new mutation for the UserBlock entity.
func newUserBlockMutation(c config, op Op, opts ...userblockOption) *UserBlockMutation {
	m := &UserBlockMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBlockID sets the ID field of the mutation.
func withUserBlockID(id string) userblockOption {
	return func(m *UserBlockMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBlock
		)
		m.oldValue = func(ctx context.Context) (*UserBlock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBlock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBlock sets the old UserBlock of the mutation.
func withUserBlock(node *UserBlock) userblockOption {
	return func(m *UserBlockMutation) {
		m.oldValue = func(context.Context) (*UserBlock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBlock entities.
func (m *UserBlockMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBlockMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBlockMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBlock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlockerUserID sets the "blocker_user_id" field.
func (m *UserBlockMutation) SetBlockerUserID(s string) {
	m.blocker = &s
}

// BlockerUserID returns the value of the "blocker_user_id" field in the mutation.
func (m *UserBlockMutation) BlockerUserID() (r string, exists bool) {
	v := m.blocker
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockerUserID returns the old "blocker_user_id" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldBlockerUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockerUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockerUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockerUserID: %w", err)
	}
	return oldValue.BlockerUserID, nil
}

// ResetBlockerUserID resets all changes to the "blocker_user_id" field.
func (m *UserBlockMutation) ResetBlockerUserID() {
	m.blocker = nil
}

// SetBlockedUserID sets the "blocked_user_id" field.
func (m *UserBlockMutation) SetBlockedUserID(s string) {
	m.blocked = &s
}

// BlockedUserID returns the value of the "blocked_user_id" field in the mutation.
func (m *UserBlockMutation) BlockedUserID() (r string, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockedUserID returns the old "blocked_user_id" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldBlockedUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockedUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockedUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockedUserID: %w", err)
	}
	return oldValue.BlockedUserID, nil
}

// ResetBlockedUserID resets all changes to the "blocked_user_id" field.
func (m *UserBlockMutation) ResetBlockedUserID() {
	m.blocked = nil
}

// SetReason sets the "reason" field.
func (m *UserBlockMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *UserBlockMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *UserBlockMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[userblock.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *UserBlockMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[userblock.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *UserBlockMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, userblock.FieldReason)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserBlockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserBlockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserBlockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUnblockedAt sets the "unblocked_at" field.
func (m *UserBlockMutation) SetUnblockedAt(t time.Time) {
	m.unblocked_at = &t
}

// UnblockedAt returns the value of the "unblocked_at" field in the mutation.
func (m *UserBlockMutation) UnblockedAt() (r time.Time, exists bool) {
	v := m.unblocked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUnblockedAt returns the old "unblocked_at" field's value of the UserBlock entity.
// If the UserBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBlockMutation) OldUnblockedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnblockedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnblockedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnblockedAt: %w", err)
	}
	return oldValue.UnblockedAt, nil
}

// ClearUnblockedAt clears the value of the "unblocked_at" field.
func (m *UserBlockMutation) ClearUnblockedAt() {
	m.unblocked_at = nil
	m.clearedFields[userblock.FieldUnblockedAt] = struct{}{}
}

// UnblockedAtCleared returns if the "unblocked_at" field was cleared in this mutation.
func (m *UserBlockMutation) UnblockedAtCleared() bool {
	_, ok := m.clearedFields[userblock.FieldUnblockedAt]
	return ok
}

// ResetUnblockedAt resets all changes to the "unblocked_at" field.
func (m *UserBlockMutation) ResetUnblockedAt() {
	m.unblocked_at = nil
	delete(m.clearedFields, userblock.FieldUnblockedAt)
}

// SetBlockerID sets the "blocker" edge to the User entity by id.
func (m *UserBlockMutation) SetBlockerID(id string) {
	m.blocker = &id
}

// ClearBlocker clears the "blocker" edge to the User entity.
func (m *UserBlockMutation) ClearBlocker() {
	m.clearedblocker = true
	m.clearedFields[userblock.FieldBlockerUserID] = struct{}{}
}

// BlockerCleared reports if the "blocker" edge to the User entity was cleared.
func (m *UserBlockMutation) BlockerCleared() bool {
	return m.clearedblocker
}

// BlockerID returns the "blocker" edge ID in the mutation.
func (m *UserBlockMutation) BlockerID() (id string, exists bool) {
	if m.blocker != nil {
		return *m.blocker, true
	}
	return
}

// BlockerIDs returns the "blocker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockerID instead. It exists only for internal usage by the builders.
func (m *UserBlockMutation) BlockerIDs() (ids []string) {
	if id := m.blocker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlocker resets all changes to the "blocker" edge.
func (m *UserBlockMutation) ResetBlocker() {
	m.blocker = nil
	m.clearedblocker = false
}

// SetBlockedID sets the "blocked" edge to the User entity by id.
func (m *UserBlockMutation) SetBlockedID(id string) {
	m.blocked = &id
}

// ClearBlocked clears the "blocked" edge to the User entity.
func (m *UserBlockMutation) ClearBlocked() {
	m.clearedblocked = true
	m.clearedFields[userblock.FieldBlockedUserID] = struct{}{}
}

// BlockedCleared reports if the "blocked" edge to the User entity was cleared.
func (m *UserBlockMutation) BlockedCleared() bool {
	return m.clearedblocked
}

// BlockedID returns the "blocked" edge ID in the mutation.
func (m *UserBlockMutation) BlockedID() (id string, exists bool) {
	if m.blocked != nil {
		return *m.blocked, true
	}
	return
}

// BlockedIDs returns the "blocked" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockedID instead. It exists only for internal usage by the builders.
func (m *UserBlockMutation) BlockedIDs() (ids []string) {
	if id := m.blocked; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlocked resets all changes to the "blocked" edge.
func (m *UserBlockMutation) ResetBlocked() {
	m.blocked = nil
	m.clearedblocked = false
}

// Where appends a list predicates to the UserBlockMutation builder.
func (m *UserBlockMutation) Where(ps ...predicate.UserBlock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBlockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBlockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBlock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBlockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBlockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBlock).
func (m *UserBlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBlockMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.blocker != nil {
		fields = append(fields, userblock.FieldBlockerUserID)
	}
	if m.blocked != nil {
		fields = append(fields, userblock.FieldBlockedUserID)
	}
	if m.reason != nil {
		fields = append(fields, userblock.FieldReason)
	}
	if m.created_at != nil {
		fields = append(fields, userblock.FieldCreatedAt)
	}
	if m.unblocked_at != nil {
		fields = append(fields, userblock.FieldUnblockedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userblock.FieldBlockerUserID:
		return m.BlockerUserID()
	case userblock.FieldBlockedUserID:
		return m.BlockedUserID()
	case userblock.FieldReason:
		return m.Reason()
	case userblock.FieldCreatedAt:
		return m.CreatedAt()
	case userblock.FieldUnblockedAt:
		return m.UnblockedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userblock.FieldBlockerUserID:
		return m.OldBlockerUserID(ctx)
	case userblock.FieldBlockedUserID:
		return m.OldBlockedUserID(ctx)
	case userblock.FieldReason:
		return m.OldReason(ctx)
	case userblock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userblock.FieldUnblockedAt:
		return m.OldUnblockedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserBlock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userblock.FieldBlockerUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockerUserID(v)
		return nil
	case userblock.FieldBlockedUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockedUserID(v)
		return nil
	case userblock.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case userblock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userblock.FieldUnblockedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnblockedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserBlock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBlockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBlockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserBlock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBlockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userblock.FieldReason) {
		fields = append(fields, userblock.FieldReason)
	}
	if m.FieldCleared(userblock.FieldUnblockedAt) {
		fields = append(fields, userblock.FieldUnblockedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBlockMutation) ClearField(name string) error {
	switch name {
	case userblock.FieldReason:
		m.ClearReason()
		return nil
	case userblock.FieldUnblockedAt:
		m.ClearUnblockedAt()
		return nil
	}
	return fmt.Errorf("unknown UserBlock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBlockMutation) ResetField(name string) error {
	switch name {
	case userblock.FieldBlockerUserID:
		m.ResetBlockerUserID()
		return nil
	case userblock.FieldBlockedUserID:
		m.ResetBlockedUserID()
		return nil
	case userblock.FieldReason:
		m.ResetReason()
		return nil
	case userblock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userblock.FieldUnblockedAt:
		m.ResetUnblockedAt()
		return nil
	}
	return fmt.Errorf("unknown UserBlock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.blocker != nil {
		edges = append(edges, userblock.EdgeBlocker)
	}
	if m.blocked != nil {
		edges = append(edges, userblock.EdgeBlocked)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userblock.EdgeBlocker:
		if id := m.blocker; id != nil {
			return []ent.Value{*id}
		}
	case userblock.EdgeBlocked:
		if id := m.blocked; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedblocker {
		edges = append(edges, userblock.EdgeBlocker)
	}
	if m.clearedblocked {
		edges = append(edges, userblock.EdgeBlocked)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBlockMutation) EdgeCleared(name string) bool {
	switch name {
	case userblock.EdgeBlocker:
		return m.clearedblocker
	case userblock.EdgeBlocked:
		return m.clearedblocked
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBlockMutation) ClearEdge(name string) error {
	switch name {
	case userblock.EdgeBlocker:
		m.ClearBlocker()
		return nil
	case userblock.EdgeBlocked:
		m.ClearBlocked()
		return nil
	}
	return fmt.Errorf("unknown UserBlock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBlockMutation) ResetEdge(name string) error {
	switch name {
	case userblock.EdgeBlocker:
		m.ResetBlocker()
		return nil
	case userblock.EdgeBlocked:
		m.ResetBlocked()
		return nil
	}
	return fmt.Errorf("unknown UserBlock edge %s", name)
}

// UserReportMutation represents an operation that mutates the UserReport nodes in the graph.
type UserReportMutation struct {
	config
	op              Op
	typ             string
	id              *string
	report_reason   *userreport.ReportReason
	description     *string
	reference_type  *string
	reference_id    *string
	report_status   *userreport.ReportStatus
	reviewed_by     *string
	admin_notes     *string
	created_at      *time.Time
	reviewed_at     *time.Time
	clearedFields   map[string]struct{}
	reporter        *string
	clearedreporter bool
	reported        *string
	clearedreported bool
	done            bool
	oldValue        func(context.Context) (*UserReport, error)
	predicates      []predicate.UserReport
}

var _ ent.Mutation = (*UserReportMutation)(nil)

// userreportOption allows management of the mutation configuration using functional options.
type userreportOption func(*UserReportMutation)

// newUserReportMutation creates new mutation for the UserReport entity.
func newUserReportMutation(c config, op Op, opts ...userreportOption) *UserReportMutation {
	m := &UserReportMutation{
		config:        c,
		op:            op,
		typ:           TypeUserReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserReportID sets the ID field of the mutation.
func withUserReportID(id string) userreportOption {
	return func(m *UserReportMutation) {
		var (
			err   error
			once  sync.Once
			value *UserReport
		)
		m.oldValue = func(ctx context.Context) (*UserReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserReport sets the old UserReport of the mutation.
func withUserReport(node *UserReport) userreportOption {
	return func(m *UserReportMutation) {
		m.oldValue = func(context.Context) (*UserReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserReport entities.
func (m *UserReportMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserReportMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserReportMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReporterUserID sets the "reporter_user_id" field.
func (m *UserReportMutation) SetReporterUserID(s string) {
	m.reporter = &s
}

// ReporterUserID returns the value of the "reporter_user_id" field in the mutation.
func (m *UserReportMutation) ReporterUserID() (r string, exists bool) {
	v := m.reporter
	if v == nil {
		return
	}
	return *v, true
}

// OldReporterUserID returns the old "reporter_user_id" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReporterUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReporterUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReporterUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReporterUserID: %w", err)
	}
	return oldValue.ReporterUserID, nil
}

// ResetReporterUserID resets all changes to the "reporter_user_id" field.
func (m *UserReportMutation) ResetReporterUserID() {
	m.reporter = nil
}

// SetReportedUserID sets the "reported_user_id" field.
func (m *UserReportMutation) SetReportedUserID(s string) {
	m.reported = &s
}

// ReportedUserID returns the value of the "reported_user_id" field in the mutation.
func (m *UserReportMutation) ReportedUserID() (r string, exists bool) {
	v := m.reported
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedUserID returns the old "reported_user_id" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReportedUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportedUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportedUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedUserID: %w", err)
	}
	return oldValue.ReportedUserID, nil
}

// ResetReportedUserID resets all changes to the "reported_user_id" field.
func (m *UserReportMutation) ResetReportedUserID() {
	m.reported = nil
}

// SetReportReason sets the "report_reason" field.
func (m *UserReportMutation) SetReportReason(ur userreport.ReportReason) {
	m.report_reason = &ur
}

// ReportReason returns the value of the "report_reason" field in the mutation.
func (m *UserReportMutation) ReportReason() (r userreport.ReportReason, exists bool) {
	v := m.report_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReportReason returns the old "report_reason" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReportReason(ctx context.Context) (v userreport.ReportReason, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportReason: %w", err)
	}
	return oldValue.ReportReason, nil
}

// ResetReportReason resets all changes to the "report_reason" field.
func (m *UserReportMutation) ResetReportReason() {
	m.report_reason = nil
}

// SetDescription sets the "description" field.
func (m *UserReportMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserReportMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserReportMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[userreport.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserReportMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[userreport.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserReportMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, userreport.FieldDescription)
}

// SetReferenceType sets the "reference_type" field.
func (m *UserReportMutation) SetReferenceType(s string) {
	m.reference_type = &s
}

// ReferenceType returns the value of the "reference_type" field in the mutation.
func (m *UserReportMutation) ReferenceType() (r string, exists bool) {
	v := m.reference_type
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceType returns the old "reference_type" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReferenceType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceType: %w", err)
	}
	return oldValue.ReferenceType, nil
}

// ClearReferenceType clears the value of the "reference_type" field.
func (m *UserReportMutation) ClearReferenceType() {
	m.reference_type = nil
	m.clearedFields[userreport.FieldReferenceType] = struct{}{}
}

// ReferenceTypeCleared returns if the "reference_type" field was cleared in this mutation.
func (m *UserReportMutation) ReferenceTypeCleared() bool {
	_, ok := m.clearedFields[userreport.FieldReferenceType]
	return ok
}

// ResetReferenceType resets all changes to the "reference_type" field.
func (m *UserReportMutation) ResetReferenceType() {
	m.reference_type = nil
	delete(m.clearedFields, userreport.FieldReferenceType)
}

// SetReferenceID sets the "reference_id" field.
func (m *UserReportMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *UserReportMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReferenceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ClearReferenceID clears the value of the "reference_id" field.
func (m *UserReportMutation) ClearReferenceID() {
	m.reference_id = nil
	m.clearedFields[userreport.FieldReferenceID] = struct{}{}
}

// ReferenceIDCleared returns if the "reference_id" field was cleared in this mutation.
func (m *UserReportMutation) ReferenceIDCleared() bool {
	_, ok := m.clearedFields[userreport.FieldReferenceID]
	return ok
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *UserReportMutation) ResetReferenceID() {
	m.reference_id = nil
	delete(m.clearedFields, userreport.FieldReferenceID)
}

// SetReportStatus sets the "report_status" field.
func (m *UserReportMutation) SetReportStatus(us userreport.ReportStatus) {
	m.report_status = &us
}

// ReportStatus returns the value of the "report_status" field in the mutation.
func (m *UserReportMutation) ReportStatus() (r userreport.ReportStatus, exists bool) {
	v := m.report_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReportStatus returns the old "report_status" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReportStatus(ctx context.Context) (v userreport.ReportStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportStatus: %w", err)
	}
	return oldValue.ReportStatus, nil
}

// ResetReportStatus resets all changes to the "report_status" field.
func (m *UserReportMutation) ResetReportStatus() {
	m.report_status = nil
}

// SetReviewedBy sets the "reviewed_by" field.
func (m *UserReportMutation) SetReviewedBy(s string) {
	m.reviewed_by = &s
}

// ReviewedBy returns the value of the "reviewed_by" field in the mutation.
func (m *UserReportMutation) ReviewedBy() (r string, exists bool) {
	v := m.reviewed_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedBy returns the old "reviewed_by" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReviewedBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedBy: %w", err)
	}
	return oldValue.ReviewedBy, nil
}

// ClearReviewedBy clears the value of the "reviewed_by" field.
func (m *UserReportMutation) ClearReviewedBy() {
	m.reviewed_by = nil
	m.clearedFields[userreport.FieldReviewedBy] = struct{}{}
}

// ReviewedByCleared returns if the "reviewed_by" field was cleared in this mutation.
func (m *UserReportMutation) ReviewedByCleared() bool {
	_, ok := m.clearedFields[userreport.FieldReviewedBy]
	return ok
}

// ResetReviewedBy resets all changes to the "reviewed_by" field.
func (m *UserReportMutation) ResetReviewedBy() {
	m.reviewed_by = nil
	delete(m.clearedFields, userreport.FieldReviewedBy)
}

// SetAdminNotes sets the "admin_notes" field.
func (m *UserReportMutation) SetAdminNotes(s string) {
	m.admin_notes = &s
}

// AdminNotes returns the value of the "admin_notes" field in the mutation.
func (m *UserReportMutation) AdminNotes() (r string, exists bool) {
	v := m.admin_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminNotes returns the old "admin_notes" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldAdminNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminNotes: %w", err)
	}
	return oldValue.AdminNotes, nil
}

// ClearAdminNotes clears the value of the "admin_notes" field.
func (m *UserReportMutation) ClearAdminNotes() {
	m.admin_notes = nil
	m.clearedFields[userreport.FieldAdminNotes] = struct{}{}
}

// AdminNotesCleared returns if the "admin_notes" field was cleared in this mutation.
func (m *UserReportMutation) AdminNotesCleared() bool {
	_, ok := m.clearedFields[userreport.FieldAdminNotes]
	return ok
}

// ResetAdminNotes resets all changes to the "admin_notes" field.
func (m *UserReportMutation) ResetAdminNotes() {
	m.admin_notes = nil
	delete(m.clearedFields, userreport.FieldAdminNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReviewedAt sets the "reviewed_at" field.
func (m *UserReportMutation) SetReviewedAt(t time.Time) {
	m.reviewed_at = &t
}

// ReviewedAt returns the value of the "reviewed_at" field in the mutation.
func (m *UserReportMutation) ReviewedAt() (r time.Time, exists bool) {
	v := m.reviewed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewedAt returns the old "reviewed_at" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReviewedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewedAt: %w", err)
	}
	return oldValue.ReviewedAt, nil
}

// ClearReviewedAt clears the value of the "reviewed_at" field.
func (m *UserReportMutation) ClearReviewedAt() {
	m.reviewed_at = nil
	m.clearedFields[userreport.FieldReviewedAt] = struct{}{}
}

// ReviewedAtCleared returns if the "reviewed_at" field was cleared in this mutation.
func (m *UserReportMutation) ReviewedAtCleared() bool {
	_, ok := m.clearedFields[userreport.FieldReviewedAt]
	return ok
}

// ResetReviewedAt resets all changes to the "reviewed_at" field.
func (m *UserReportMutation) ResetReviewedAt() {
	m.reviewed_at = nil
	delete(m.clearedFields, userreport.FieldReviewedAt)
}

// SetReporterID sets the "reporter" edge to the User entity by id.
func (m *UserReportMutation) SetReporterID(id string) {
	m.reporter = &id
}

// ClearReporter clears the "reporter" edge to the User entity.
func (m *UserReportMutation) ClearReporter() {
	m.clearedreporter = true
	m.clearedFields[userreport.FieldReporterUserID] = struct{}{}
}

// ReporterCleared reports if the "reporter" edge to the User entity was cleared.
func (m *UserReportMutation) ReporterCleared() bool {
	return m.clearedreporter
}

// ReporterID returns the "reporter" edge ID in the mutation.
func (m *UserReportMutation) ReporterID() (id string, exists bool) {
	if m.reporter != nil {
		return *m.reporter, true
	}
	return
}

// ReporterIDs returns the "reporter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReporterID instead. It exists only for internal usage by the builders.
func (m *UserReportMutation) ReporterIDs() (ids []string) {
	if id := m.reporter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReporter resets all changes to the "reporter" edge.
func (m *UserReportMutation) ResetReporter() {
	m.reporter = nil
	m.clearedreporter = false
}

// SetReportedID sets the "reported" edge to the User entity by id.
func (m *UserReportMutation) SetReportedID(id string) {
	m.reported = &id
}

// ClearReported clears the "reported" edge to the User entity.
func (m *UserReportMutation) ClearReported() {
	m.clearedreported = true
	m.clearedFields[userreport.FieldReportedUserID] = struct{}{}
}

// ReportedCleared reports if the "reported" edge to the User entity was cleared.
func (m *UserReportMutation) ReportedCleared() bool {
	return m.clearedreported
}

// ReportedID returns the "reported" edge ID in the mutation.
func (m *UserReportMutation) ReportedID() (id string, exists bool) {
	if m.reported != nil {
		return *m.reported, true
	}
	return
}

// ReportedIDs returns the "reported" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReportedID instead. It exists only for internal usage by the builders.
func (m *UserReportMutation) ReportedIDs() (ids []string) {
	if id := m.reported; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReported resets all changes to the "reported" edge.
func (m *UserReportMutation) ResetReported() {
	m.reported = nil
	m.clearedreported = false
}

// Where appends a list predicates to the UserReportMutation builder.
func (m *UserReportMutation) Where(ps ...predicate.UserReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserReport).
func (m *UserReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserReportMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.reporter != nil {
		fields = append(fields, userreport.FieldReporterUserID)
	}
	if m.reported != nil {
		fields = append(fields, userreport.FieldReportedUserID)
	}
	if m.report_reason != nil {
		fields = append(fields, userreport.FieldReportReason)
	}
	if m.description != nil {
		fields = append(fields, userreport.FieldDescription)
	}
	if m.reference_type != nil {
		fields = append(fields, userreport.FieldReferenceType)
	}
	if m.reference_id != nil {
		fields = append(fields, userreport.FieldReferenceID)
	}
	if m.report_status != nil {
		fields = append(fields, userreport.FieldReportStatus)
	}
	if m.reviewed_by != nil {
		fields = append(fields, userreport.FieldReviewedBy)
	}
	if m.admin_notes != nil {
		fields = append(fields, userreport.FieldAdminNotes)
	}
	if m.created_at != nil {
		fields = append(fields, userreport.FieldCreatedAt)
	}
	if m.reviewed_at != nil {
		fields = append(fields, userreport.FieldReviewedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userreport.FieldReporterUserID:
		return m.ReporterUserID()
	case userreport.FieldReportedUserID:
		return m.ReportedUserID()
	case userreport.FieldReportReason:
		return m.ReportReason()
	case userreport.FieldDescription:
		return m.Description()
	case userreport.FieldReferenceType:
		return m.ReferenceType()
	case userreport.FieldReferenceID:
		return m.ReferenceID()
	case userreport.FieldReportStatus:
		return m.ReportStatus()
	case userreport.FieldReviewedBy:
		return m.ReviewedBy()
	case userreport.FieldAdminNotes:
		return m.AdminNotes()
	case userreport.FieldCreatedAt:
		return m.CreatedAt()
	case userreport.FieldReviewedAt:
		return m.ReviewedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userreport.FieldReporterUserID:
		return m.OldReporterUserID(ctx)
	case userreport.FieldReportedUserID:
		return m.OldReportedUserID(ctx)
	case userreport.FieldReportReason:
		return m.OldReportReason(ctx)
	case userreport.FieldDescription:
		return m.OldDescription(ctx)
	case userreport.FieldReferenceType:
		return m.OldReferenceType(ctx)
	case userreport.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case userreport.FieldReportStatus:
		return m.OldReportStatus(ctx)
	case userreport.FieldReviewedBy:
		return m.OldReviewedBy(ctx)
	case userreport.FieldAdminNotes:
		return m.OldAdminNotes(ctx)
	case userreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userreport.FieldReviewedAt:
		return m.OldReviewedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userreport.FieldReporterUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReporterUserID(v)
		return nil
	case userreport.FieldReportedUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedUserID(v)
		return nil
	case userreport.FieldReportReason:
		v, ok := value.(userreport.ReportReason)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportReason(v)
		return nil
	case userreport.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userreport.FieldReferenceType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceType(v)
		return nil
	case userreport.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case userreport.FieldReportStatus:
		v, ok := value.(userreport.ReportStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportStatus(v)
		return nil
	case userreport.FieldReviewedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedBy(v)
		return nil
	case userreport.FieldAdminNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminNotes(v)
		return nil
	case userreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userreport.FieldReviewedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserReportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserReportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userreport.FieldDescription) {
		fields = append(fields, userreport.FieldDescription)
	}
	if m.FieldCleared(userreport.FieldReferenceType) {
		fields = append(fields, userreport.FieldReferenceType)
	}
	if m.FieldCleared(userreport.FieldReferenceID) {
		fields = append(fields, userreport.FieldReferenceID)
	}
	if m.FieldCleared(userreport.FieldReviewedBy) {
		fields = append(fields, userreport.FieldReviewedBy)
	}
	if m.FieldCleared(userreport.FieldAdminNotes) {
		fields = append(fields, userreport.FieldAdminNotes)
	}
	if m.FieldCleared(userreport.FieldReviewedAt) {
		fields = append(fields, userreport.FieldReviewedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserReportMutation) ClearField(name string) error {
	switch name {
	case userreport.FieldDescription:
		m.ClearDescription()
		return nil
	case userreport.FieldReferenceType:
		m.ClearReferenceType()
		return nil
	case userreport.FieldReferenceID:
		m.ClearReferenceID()
		return nil
	case userreport.FieldReviewedBy:
		m.ClearReviewedBy()
		return nil
	case userreport.FieldAdminNotes:
		m.ClearAdminNotes()
		return nil
	case userreport.FieldReviewedAt:
		m.ClearReviewedAt()
		return nil
	}
	return fmt.Errorf("unknown UserReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserReportMutation) ResetField(name string) error {
	switch name {
	case userreport.FieldReporterUserID:
		m.ResetReporterUserID()
		return nil
	case userreport.FieldReportedUserID:
		m.ResetReportedUserID()
		return nil
	case userreport.FieldReportReason:
		m.ResetReportReason()
		return nil
	case userreport.FieldDescription:
		m.ResetDescription()
		return nil
	case userreport.FieldReferenceType:
		m.ResetReferenceType()
		return nil
	case userreport.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case userreport.FieldReportStatus:
		m.ResetReportStatus()
		return nil
	case userreport.FieldReviewedBy:
		m.ResetReviewedBy()
		return nil
	case userreport.FieldAdminNotes:
		m.ResetAdminNotes()
		return nil
	case userreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userreport.FieldReviewedAt:
		m.ResetReviewedAt()
		return nil
	}
	return fmt.Errorf("unknown UserReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.reporter != nil {
		edges = append(edges, userreport.EdgeReporter)
	}
	if m.reported != nil {
		edges = append(edges, userreport.EdgeReported)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userreport.EdgeReporter:
		if id := m.reporter; id != nil {
			return []ent.Value{*id}
		}
	case userreport.EdgeReported:
		if id := m.reported; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedreporter {
		edges = append(edges, userreport.EdgeReporter)
	}
	if m.clearedreported {
		edges = append(edges, userreport.EdgeReported)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserReportMutation) EdgeCleared(name string) bool {
	switch name {
	case userreport.EdgeReporter:
		return m.clearedreporter
	case userreport.EdgeReported:
		return m.clearedreported
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserReportMutation) ClearEdge(name string) error {
	switch name {
	case userreport.EdgeReporter:
		m.ClearReporter()
		return nil
	case userreport.EdgeReported:
		m.ClearReported()
		return nil
	}
	return fmt.Errorf("unknown UserReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserReportMutation) ResetEdge(name string) error {
	switch name {
	case userreport.EdgeReporter:
		m.ResetReporter()
		return nil
	case userreport.EdgeReported:
		m.ResetReported()
		return nil
	}
	return fmt.Errorf("unknown UserReport edge %s", name)
}
