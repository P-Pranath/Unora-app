// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/UnoraApp/be/ent/generated/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/UnoraApp/be/ent/generated/auditlog"
	"github.com/UnoraApp/be/ent/generated/checkin"
	"github.com/UnoraApp/be/ent/generated/connection"
	"github.com/UnoraApp/be/ent/generated/creditpackage"
	"github.com/UnoraApp/be/ent/generated/credittransaction"
	"github.com/UnoraApp/be/ent/generated/discoverybatch"
	"github.com/UnoraApp/be/ent/generated/discoverycard"
	"github.com/UnoraApp/be/ent/generated/filter"
	"github.com/UnoraApp/be/ent/generated/hobby"
	"github.com/UnoraApp/be/ent/generated/hobbyoption"
	"github.com/UnoraApp/be/ent/generated/interest"
	"github.com/UnoraApp/be/ent/generated/nudge"
	"github.com/UnoraApp/be/ent/generated/paymentorder"
	"github.com/UnoraApp/be/ent/generated/photo"
	"github.com/UnoraApp/be/ent/generated/profile"
	"github.com/UnoraApp/be/ent/generated/reveal"
	"github.com/UnoraApp/be/ent/generated/revealcontent"
	"github.com/UnoraApp/be/ent/generated/revealmilestone"
	"github.com/UnoraApp/be/ent/generated/server"
	"github.com/UnoraApp/be/ent/generated/streak"
	"github.com/UnoraApp/be/ent/generated/user"
	"github.com/UnoraApp/be/ent/generated/userblock"
	"github.com/UnoraApp/be/ent/generated/userreport"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuditLog is the client for interacting with the AuditLog builders.
	AuditLog *AuditLogClient
	// CheckIn is the client for interacting with the CheckIn builders.
	CheckIn *CheckInClient
	// Connection is the client for interacting with the Connection builders.
	Connection *ConnectionClient
	// CreditPackage is the client for interacting with the CreditPackage builders.
	CreditPackage *CreditPackageClient
	// CreditTransaction is the client for interacting with the CreditTransaction builders.
	CreditTransaction *CreditTransactionClient
	// DiscoveryBatch is the client for interacting with the DiscoveryBatch builders.
	DiscoveryBatch *DiscoveryBatchClient
	// DiscoveryCard is the client for interacting with the DiscoveryCard builders.
	DiscoveryCard *DiscoveryCardClient
	// Filter is the client for interacting with the Filter builders.
	Filter *FilterClient
	// Hobby is the client for interacting with the Hobby builders.
	Hobby *HobbyClient
	// HobbyOption is the client for interacting with the HobbyOption builders.
	HobbyOption *HobbyOptionClient
	// Interest is the client for interacting with the Interest builders.
	Interest *InterestClient
	// Nudge is the client for interacting with the Nudge builders.
	Nudge *NudgeClient
	// PaymentOrder is the client for interacting with the PaymentOrder builders.
	PaymentOrder *PaymentOrderClient
	// Photo is the client for interacting with the Photo builders.
	Photo *PhotoClient
	// Profile is the client for interacting with the Profile builders.
	Profile *ProfileClient
	// Reveal is the client for interacting with the Reveal builders.
	Reveal *RevealClient
	// RevealContent is the client for interacting with the RevealContent builders.
	RevealContent *RevealContentClient
	// RevealMilestone is the client for interacting with the RevealMilestone builders.
	RevealMilestone *RevealMilestoneClient
	// Server is the client for interacting with the Server builders.
	Server *ServerClient
	// Streak is the client for interacting with the Streak builders.
	Streak *StreakClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserBlock is the client for interacting with the UserBlock builders.
	UserBlock *UserBlockClient
	// UserReport is the client for interacting with the UserReport builders.
	UserReport *UserReportClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuditLog = NewAuditLogClient(c.config)
	c.CheckIn = NewCheckInClient(c.config)
	c.Connection = NewConnectionClient(c.config)
	c.CreditPackage = NewCreditPackageClient(c.config)
	c.CreditTransaction = NewCreditTransactionClient(c.config)
	c.DiscoveryBatch = NewDiscoveryBatchClient(c.config)
	c.DiscoveryCard = NewDiscoveryCardClient(c.config)
	c.Filter = NewFilterClient(c.config)
	c.Hobby = NewHobbyClient(c.config)
	c.HobbyOption = NewHobbyOptionClient(c.config)
	c.Interest = NewInterestClient(c.config)
	c.Nudge = NewNudgeClient(c.config)
	c.PaymentOrder = NewPaymentOrderClient(c.config)
	c.Photo = NewPhotoClient(c.config)
	c.Profile = NewProfileClient(c.config)
	c.Reveal = NewRevealClient(c.config)
	c.RevealContent = NewRevealContentClient(c.config)
	c.RevealMilestone = NewRevealMilestoneClient(c.config)
	c.Server = NewServerClient(c.config)
	c.Streak = NewStreakClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserBlock = NewUserBlockClient(c.config)
	c.UserReport = NewUserReportClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("generated: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("generated: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AuditLog:          NewAuditLogClient(cfg),
		CheckIn:           NewCheckInClient(cfg),
		Connection:        NewConnectionClient(cfg),
		CreditPackage:     NewCreditPackageClient(cfg),
		CreditTransaction: NewCreditTransactionClient(cfg),
		DiscoveryBatch:    NewDiscoveryBatchClient(cfg),
		DiscoveryCard:     NewDiscoveryCardClient(cfg),
		Filter:            NewFilterClient(cfg),
		Hobby:             NewHobbyClient(cfg),
		HobbyOption:       NewHobbyOptionClient(cfg),
		Interest:          NewInterestClient(cfg),
		Nudge:             NewNudgeClient(cfg),
		PaymentOrder:      NewPaymentOrderClient(cfg),
		Photo:             NewPhotoClient(cfg),
		Profile:           NewProfileClient(cfg),
		Reveal:            NewRevealClient(cfg),
		RevealContent:     NewRevealContentClient(cfg),
		RevealMilestone:   NewRevealMilestoneClient(cfg),
		Server:            NewServerClient(cfg),
		Streak:            NewStreakClient(cfg),
		User:              NewUserClient(cfg),
		UserBlock:         NewUserBlockClient(cfg),
		UserReport:        NewUserReportClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AuditLog:          NewAuditLogClient(cfg),
		CheckIn:           NewCheckInClient(cfg),
		Connection:        NewConnectionClient(cfg),
		CreditPackage:     NewCreditPackageClient(cfg),
		CreditTransaction: NewCreditTransactionClient(cfg),
		DiscoveryBatch:    NewDiscoveryBatchClient(cfg),
		DiscoveryCard:     NewDiscoveryCardClient(cfg),
		Filter:            NewFilterClient(cfg),
		Hobby:             NewHobbyClient(cfg),
		HobbyOption:       NewHobbyOptionClient(cfg),
		Interest:          NewInterestClient(cfg),
		Nudge:             NewNudgeClient(cfg),
		PaymentOrder:      NewPaymentOrderClient(cfg),
		Photo:             NewPhotoClient(cfg),
		Profile:           NewProfileClient(cfg),
		Reveal:            NewRevealClient(cfg),
		RevealContent:     NewRevealContentClient(cfg),
		RevealMilestone:   NewRevealMilestoneClient(cfg),
		Server:            NewServerClient(cfg),
		Streak:            NewStreakClient(cfg),
		User:              NewUserClient(cfg),
		UserBlock:         NewUserBlockClient(cfg),
		UserReport:        NewUserReportClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuditLog.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuditLog, c.CheckIn, c.Connection, c.CreditPackage, c.CreditTransaction,
		c.DiscoveryBatch, c.DiscoveryCard, c.Filter, c.Hobby, c.HobbyOption,
		c.Interest, c.Nudge, c.PaymentOrder, c.Photo, c.Profile, c.Reveal,
		c.RevealContent, c.RevealMilestone, c.Server, c.Streak, c.User, c.UserBlock,
		c.UserReport,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuditLog, c.CheckIn, c.Connection, c.CreditPackage, c.CreditTransaction,
		c.DiscoveryBatch, c.DiscoveryCard, c.Filter, c.Hobby, c.HobbyOption,
		c.Interest, c.Nudge, c.PaymentOrder, c.Photo, c.Profile, c.Reveal,
		c.RevealContent, c.RevealMilestone, c.Server, c.Streak, c.User, c.UserBlock,
		c.UserReport,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuditLogMutation:
		return c.AuditLog.mutate(ctx, m)
	case *CheckInMutation:
		return c.CheckIn.mutate(ctx, m)
	case *ConnectionMutation:
		return c.Connection.mutate(ctx, m)
	case *CreditPackageMutation:
		return c.CreditPackage.mutate(ctx, m)
	case *CreditTransactionMutation:
		return c.CreditTransaction.mutate(ctx, m)
	case *DiscoveryBatchMutation:
		return c.DiscoveryBatch.mutate(ctx, m)
	case *DiscoveryCardMutation:
		return c.DiscoveryCard.mutate(ctx, m)
	case *FilterMutation:
		return c.Filter.mutate(ctx, m)
	case *HobbyMutation:
		return c.Hobby.mutate(ctx, m)
	case *HobbyOptionMutation:
		return c.HobbyOption.mutate(ctx, m)
	case *InterestMutation:
		return c.Interest.mutate(ctx, m)
	case *NudgeMutation:
		return c.Nudge.mutate(ctx, m)
	case *PaymentOrderMutation:
		return c.PaymentOrder.mutate(ctx, m)
	case *PhotoMutation:
		return c.Photo.mutate(ctx, m)
	case *ProfileMutation:
		return c.Profile.mutate(ctx, m)
	case *RevealMutation:
		return c.Reveal.mutate(ctx, m)
	case *RevealContentMutation:
		return c.RevealContent.mutate(ctx, m)
	case *RevealMilestoneMutation:
		return c.RevealMilestone.mutate(ctx, m)
	case *ServerMutation:
		return c.Server.mutate(ctx, m)
	case *StreakMutation:
		return c.Streak.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserBlockMutation:
		return c.UserBlock.mutate(ctx, m)
	case *UserReportMutation:
		return c.UserReport.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("generated: unknown mutation type %T", m)
	}
}

// AuditLogClient is a client for the AuditLog schema.
type AuditLogClient struct {
	config
}

// NewAuditLogClient returns a client for the AuditLog from the given config.
func NewAuditLogClient(c config) *AuditLogClient {
	return &AuditLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `auditlog.Hooks(f(g(h())))`.
func (c *AuditLogClient) Use(hooks ...Hook) {
	c.hooks.AuditLog = append(c.hooks.AuditLog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `auditlog.Intercept(f(g(h())))`.
func (c *AuditLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuditLog = append(c.inters.AuditLog, interceptors...)
}

// Create returns a builder for creating a AuditLog entity.
func (c *AuditLogClient) Create() *AuditLogCreate {
	mutation := newAuditLogMutation(c.config, OpCreate)
	return &AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuditLog entities.
func (c *AuditLogClient) CreateBulk(builders ...*AuditLogCreate) *AuditLogCreateBulk {
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuditLogClient) MapCreateBulk(slice any, setFunc func(*AuditLogCreate, int)) *AuditLogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuditLogCreateBulk{err: fmt.Errorf("calling to AuditLogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuditLogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuditLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuditLog.
func (c *AuditLogClient) Update() *AuditLogUpdate {
	mutation := newAuditLogMutation(c.config, OpUpdate)
	return &AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuditLogClient) UpdateOne(_m *AuditLog) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLog(_m))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuditLogClient) UpdateOneID(id string) *AuditLogUpdateOne {
	mutation := newAuditLogMutation(c.config, OpUpdateOne, withAuditLogID(id))
	return &AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuditLog.
func (c *AuditLogClient) Delete() *AuditLogDelete {
	mutation := newAuditLogMutation(c.config, OpDelete)
	return &AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuditLogClient) DeleteOne(_m *AuditLog) *AuditLogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuditLogClient) DeleteOneID(id string) *AuditLogDeleteOne {
	builder := c.Delete().Where(auditlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuditLogDeleteOne{builder}
}

// Query returns a query builder for AuditLog.
func (c *AuditLogClient) Query() *AuditLogQuery {
	return &AuditLogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuditLog},
		inters: c.Interceptors(),
	}
}

// Get returns a AuditLog entity by its id.
func (c *AuditLogClient) Get(ctx context.Context, id string) (*AuditLog, error) {
	return c.Query().Where(auditlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuditLogClient) GetX(ctx context.Context, id string) *AuditLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuditLogClient) Hooks() []Hook {
	return c.hooks.AuditLog
}

// Interceptors returns the client interceptors.
func (c *AuditLogClient) Interceptors() []Interceptor {
	return c.inters.AuditLog
}

func (c *AuditLogClient) mutate(ctx context.Context, m *AuditLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuditLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuditLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuditLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuditLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown AuditLog mutation op: %q", m.Op())
	}
}

// CheckInClient is a client for the CheckIn schema.
type CheckInClient struct {
	config
}

// NewCheckInClient returns a client for the CheckIn from the given config.
func NewCheckInClient(c config) *CheckInClient {
	return &CheckInClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `checkin.Hooks(f(g(h())))`.
func (c *CheckInClient) Use(hooks ...Hook) {
	c.hooks.CheckIn = append(c.hooks.CheckIn, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `checkin.Intercept(f(g(h())))`.
func (c *CheckInClient) Intercept(interceptors ...Interceptor) {
	c.inters.CheckIn = append(c.inters.CheckIn, interceptors...)
}

// Create returns a builder for creating a CheckIn entity.
func (c *CheckInClient) Create() *CheckInCreate {
	mutation := newCheckInMutation(c.config, OpCreate)
	return &CheckInCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CheckIn entities.
func (c *CheckInClient) CreateBulk(builders ...*CheckInCreate) *CheckInCreateBulk {
	return &CheckInCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CheckInClient) MapCreateBulk(slice any, setFunc func(*CheckInCreate, int)) *CheckInCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CheckInCreateBulk{err: fmt.Errorf("calling to CheckInClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CheckInCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CheckInCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CheckIn.
func (c *CheckInClient) Update() *CheckInUpdate {
	mutation := newCheckInMutation(c.config, OpUpdate)
	return &CheckInUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CheckInClient) UpdateOne(_m *CheckIn) *CheckInUpdateOne {
	mutation := newCheckInMutation(c.config, OpUpdateOne, withCheckIn(_m))
	return &CheckInUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CheckInClient) UpdateOneID(id string) *CheckInUpdateOne {
	mutation := newCheckInMutation(c.config, OpUpdateOne, withCheckInID(id))
	return &CheckInUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CheckIn.
func (c *CheckInClient) Delete() *CheckInDelete {
	mutation := newCheckInMutation(c.config, OpDelete)
	return &CheckInDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CheckInClient) DeleteOne(_m *CheckIn) *CheckInDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CheckInClient) DeleteOneID(id string) *CheckInDeleteOne {
	builder := c.Delete().Where(checkin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CheckInDeleteOne{builder}
}

// Query returns a query builder for CheckIn.
func (c *CheckInClient) Query() *CheckInQuery {
	return &CheckInQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCheckIn},
		inters: c.Interceptors(),
	}
}

// Get returns a CheckIn entity by its id.
func (c *CheckInClient) Get(ctx context.Context, id string) (*CheckIn, error) {
	return c.Query().Where(checkin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CheckInClient) GetX(ctx context.Context, id string) *CheckIn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStreak queries the streak edge of a CheckIn.
func (c *CheckInClient) QueryStreak(_m *CheckIn) *StreakQuery {
	query := (&StreakClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checkin.Table, checkin.FieldID, id),
			sqlgraph.To(streak.Table, streak.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, checkin.StreakTable, checkin.StreakColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a CheckIn.
func (c *CheckInClient) QueryUser(_m *CheckIn) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checkin.Table, checkin.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, checkin.UserTable, checkin.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CheckInClient) Hooks() []Hook {
	return c.hooks.CheckIn
}

// Interceptors returns the client interceptors.
func (c *CheckInClient) Interceptors() []Interceptor {
	return c.inters.CheckIn
}

func (c *CheckInClient) mutate(ctx context.Context, m *CheckInMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CheckInCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CheckInUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CheckInUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CheckInDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CheckIn mutation op: %q", m.Op())
	}
}

// ConnectionClient is a client for the Connection schema.
type ConnectionClient struct {
	config
}

// NewConnectionClient returns a client for the Connection from the given config.
func NewConnectionClient(c config) *ConnectionClient {
	return &ConnectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `connection.Hooks(f(g(h())))`.
func (c *ConnectionClient) Use(hooks ...Hook) {
	c.hooks.Connection = append(c.hooks.Connection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `connection.Intercept(f(g(h())))`.
func (c *ConnectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Connection = append(c.inters.Connection, interceptors...)
}

// Create returns a builder for creating a Connection entity.
func (c *ConnectionClient) Create() *ConnectionCreate {
	mutation := newConnectionMutation(c.config, OpCreate)
	return &ConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Connection entities.
func (c *ConnectionClient) CreateBulk(builders ...*ConnectionCreate) *ConnectionCreateBulk {
	return &ConnectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConnectionClient) MapCreateBulk(slice any, setFunc func(*ConnectionCreate, int)) *ConnectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConnectionCreateBulk{err: fmt.Errorf("calling to ConnectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConnectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConnectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Connection.
func (c *ConnectionClient) Update() *ConnectionUpdate {
	mutation := newConnectionMutation(c.config, OpUpdate)
	return &ConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConnectionClient) UpdateOne(_m *Connection) *ConnectionUpdateOne {
	mutation := newConnectionMutation(c.config, OpUpdateOne, withConnection(_m))
	return &ConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConnectionClient) UpdateOneID(id string) *ConnectionUpdateOne {
	mutation := newConnectionMutation(c.config, OpUpdateOne, withConnectionID(id))
	return &ConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Connection.
func (c *ConnectionClient) Delete() *ConnectionDelete {
	mutation := newConnectionMutation(c.config, OpDelete)
	return &ConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConnectionClient) DeleteOne(_m *Connection) *ConnectionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConnectionClient) DeleteOneID(id string) *ConnectionDeleteOne {
	builder := c.Delete().Where(connection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConnectionDeleteOne{builder}
}

// Query returns a query builder for Connection.
func (c *ConnectionClient) Query() *ConnectionQuery {
	return &ConnectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConnection},
		inters: c.Interceptors(),
	}
}

// Get returns a Connection entity by its id.
func (c *ConnectionClient) Get(ctx context.Context, id string) (*Connection, error) {
	return c.Query().Where(connection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConnectionClient) GetX(ctx context.Context, id string) *Connection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserA queries the user_a edge of a Connection.
func (c *ConnectionClient) QueryUserA(_m *Connection) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connection.Table, connection.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, connection.UserATable, connection.UserAColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserB queries the user_b edge of a Connection.
func (c *ConnectionClient) QueryUserB(_m *Connection) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connection.Table, connection.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, connection.UserBTable, connection.UserBColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStreak queries the streak edge of a Connection.
func (c *ConnectionClient) QueryStreak(_m *Connection) *StreakQuery {
	query := (&StreakClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connection.Table, connection.FieldID, id),
			sqlgraph.To(streak.Table, streak.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, connection.StreakTable, connection.StreakColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReveals queries the reveals edge of a Connection.
func (c *ConnectionClient) QueryReveals(_m *Connection) *RevealQuery {
	query := (&RevealClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(connection.Table, connection.FieldID, id),
			sqlgraph.To(reveal.Table, reveal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, connection.RevealsTable, connection.RevealsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConnectionClient) Hooks() []Hook {
	return c.hooks.Connection
}

// Interceptors returns the client interceptors.
func (c *ConnectionClient) Interceptors() []Interceptor {
	return c.inters.Connection
}

func (c *ConnectionClient) mutate(ctx context.Context, m *ConnectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Connection mutation op: %q", m.Op())
	}
}

// CreditPackageClient is a client for the CreditPackage schema.
type CreditPackageClient struct {
	config
}

// NewCreditPackageClient returns a client for the CreditPackage from the given config.
func NewCreditPackageClient(c config) *CreditPackageClient {
	return &CreditPackageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `creditpackage.Hooks(f(g(h())))`.
func (c *CreditPackageClient) Use(hooks ...Hook) {
	c.hooks.CreditPackage = append(c.hooks.CreditPackage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `creditpackage.Intercept(f(g(h())))`.
func (c *CreditPackageClient) Intercept(interceptors ...Interceptor) {
	c.inters.CreditPackage = append(c.inters.CreditPackage, interceptors...)
}

// Create returns a builder for creating a CreditPackage entity.
func (c *CreditPackageClient) Create() *CreditPackageCreate {
	mutation := newCreditPackageMutation(c.config, OpCreate)
	return &CreditPackageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CreditPackage entities.
func (c *CreditPackageClient) CreateBulk(builders ...*CreditPackageCreate) *CreditPackageCreateBulk {
	return &CreditPackageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CreditPackageClient) MapCreateBulk(slice any, setFunc func(*CreditPackageCreate, int)) *CreditPackageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CreditPackageCreateBulk{err: fmt.Errorf("calling to CreditPackageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CreditPackageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CreditPackageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CreditPackage.
func (c *CreditPackageClient) Update() *CreditPackageUpdate {
	mutation := newCreditPackageMutation(c.config, OpUpdate)
	return &CreditPackageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CreditPackageClient) UpdateOne(_m *CreditPackage) *CreditPackageUpdateOne {
	mutation := newCreditPackageMutation(c.config, OpUpdateOne, withCreditPackage(_m))
	return &CreditPackageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CreditPackageClient) UpdateOneID(id string) *CreditPackageUpdateOne {
	mutation := newCreditPackageMutation(c.config, OpUpdateOne, withCreditPackageID(id))
	return &CreditPackageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CreditPackage.
func (c *CreditPackageClient) Delete() *CreditPackageDelete {
	mutation := newCreditPackageMutation(c.config, OpDelete)
	return &CreditPackageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CreditPackageClient) DeleteOne(_m *CreditPackage) *CreditPackageDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CreditPackageClient) DeleteOneID(id string) *CreditPackageDeleteOne {
	builder := c.Delete().Where(creditpackage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CreditPackageDeleteOne{builder}
}

// Query returns a query builder for CreditPackage.
func (c *CreditPackageClient) Query() *CreditPackageQuery {
	return &CreditPackageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCreditPackage},
		inters: c.Interceptors(),
	}
}

// Get returns a CreditPackage entity by its id.
func (c *CreditPackageClient) Get(ctx context.Context, id string) (*CreditPackage, error) {
	return c.Query().Where(creditpackage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CreditPackageClient) GetX(ctx context.Context, id string) *CreditPackage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CreditPackageClient) Hooks() []Hook {
	return c.hooks.CreditPackage
}

// Interceptors returns the client interceptors.
func (c *CreditPackageClient) Interceptors() []Interceptor {
	return c.inters.CreditPackage
}

func (c *CreditPackageClient) mutate(ctx context.Context, m *CreditPackageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CreditPackageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CreditPackageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CreditPackageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CreditPackageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CreditPackage mutation op: %q", m.Op())
	}
}

// CreditTransactionClient is a client for the CreditTransaction schema.
type CreditTransactionClient struct {
	config
}

// NewCreditTransactionClient returns a client for the CreditTransaction from the given config.
func NewCreditTransactionClient(c config) *CreditTransactionClient {
	return &CreditTransactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `credittransaction.Hooks(f(g(h())))`.
func (c *CreditTransactionClient) Use(hooks ...Hook) {
	c.hooks.CreditTransaction = append(c.hooks.CreditTransaction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `credittransaction.Intercept(f(g(h())))`.
func (c *CreditTransactionClient) Intercept(interceptors ...Interceptor) {
	c.inters.CreditTransaction = append(c.inters.CreditTransaction, interceptors...)
}

// Create returns a builder for creating a CreditTransaction entity.
func (c *CreditTransactionClient) Create() *CreditTransactionCreate {
	mutation := newCreditTransactionMutation(c.config, OpCreate)
	return &CreditTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CreditTransaction entities.
func (c *CreditTransactionClient) CreateBulk(builders ...*CreditTransactionCreate) *CreditTransactionCreateBulk {
	return &CreditTransactionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CreditTransactionClient) MapCreateBulk(slice any, setFunc func(*CreditTransactionCreate, int)) *CreditTransactionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CreditTransactionCreateBulk{err: fmt.Errorf("calling to CreditTransactionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CreditTransactionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CreditTransactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CreditTransaction.
func (c *CreditTransactionClient) Update() *CreditTransactionUpdate {
	mutation := newCreditTransactionMutation(c.config, OpUpdate)
	return &CreditTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CreditTransactionClient) UpdateOne(_m *CreditTransaction) *CreditTransactionUpdateOne {
	mutation := newCreditTransactionMutation(c.config, OpUpdateOne, withCreditTransaction(_m))
	return &CreditTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CreditTransactionClient) UpdateOneID(id string) *CreditTransactionUpdateOne {
	mutation := newCreditTransactionMutation(c.config, OpUpdateOne, withCreditTransactionID(id))
	return &CreditTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CreditTransaction.
func (c *CreditTransactionClient) Delete() *CreditTransactionDelete {
	mutation := newCreditTransactionMutation(c.config, OpDelete)
	return &CreditTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CreditTransactionClient) DeleteOne(_m *CreditTransaction) *CreditTransactionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CreditTransactionClient) DeleteOneID(id string) *CreditTransactionDeleteOne {
	builder := c.Delete().Where(credittransaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CreditTransactionDeleteOne{builder}
}

// Query returns a query builder for CreditTransaction.
func (c *CreditTransactionClient) Query() *CreditTransactionQuery {
	return &CreditTransactionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCreditTransaction},
		inters: c.Interceptors(),
	}
}

// Get returns a CreditTransaction entity by its id.
func (c *CreditTransactionClient) Get(ctx context.Context, id string) (*CreditTransaction, error) {
	return c.Query().Where(credittransaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CreditTransactionClient) GetX(ctx context.Context, id string) *CreditTransaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a CreditTransaction.
func (c *CreditTransactionClient) QueryUser(_m *CreditTransaction) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(credittransaction.Table, credittransaction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, credittransaction.UserTable, credittransaction.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CreditTransactionClient) Hooks() []Hook {
	return c.hooks.CreditTransaction
}

// Interceptors returns the client interceptors.
func (c *CreditTransactionClient) Interceptors() []Interceptor {
	return c.inters.CreditTransaction
}

func (c *CreditTransactionClient) mutate(ctx context.Context, m *CreditTransactionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CreditTransactionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CreditTransactionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CreditTransactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CreditTransactionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown CreditTransaction mutation op: %q", m.Op())
	}
}

// DiscoveryBatchClient is a client for the DiscoveryBatch schema.
type DiscoveryBatchClient struct {
	config
}

// NewDiscoveryBatchClient returns a client for the DiscoveryBatch from the given config.
func NewDiscoveryBatchClient(c config) *DiscoveryBatchClient {
	return &DiscoveryBatchClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `discoverybatch.Hooks(f(g(h())))`.
func (c *DiscoveryBatchClient) Use(hooks ...Hook) {
	c.hooks.DiscoveryBatch = append(c.hooks.DiscoveryBatch, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `discoverybatch.Intercept(f(g(h())))`.
func (c *DiscoveryBatchClient) Intercept(interceptors ...Interceptor) {
	c.inters.DiscoveryBatch = append(c.inters.DiscoveryBatch, interceptors...)
}

// Create returns a builder for creating a DiscoveryBatch entity.
func (c *DiscoveryBatchClient) Create() *DiscoveryBatchCreate {
	mutation := newDiscoveryBatchMutation(c.config, OpCreate)
	return &DiscoveryBatchCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DiscoveryBatch entities.
func (c *DiscoveryBatchClient) CreateBulk(builders ...*DiscoveryBatchCreate) *DiscoveryBatchCreateBulk {
	return &DiscoveryBatchCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiscoveryBatchClient) MapCreateBulk(slice any, setFunc func(*DiscoveryBatchCreate, int)) *DiscoveryBatchCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiscoveryBatchCreateBulk{err: fmt.Errorf("calling to DiscoveryBatchClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiscoveryBatchCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiscoveryBatchCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DiscoveryBatch.
func (c *DiscoveryBatchClient) Update() *DiscoveryBatchUpdate {
	mutation := newDiscoveryBatchMutation(c.config, OpUpdate)
	return &DiscoveryBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiscoveryBatchClient) UpdateOne(_m *DiscoveryBatch) *DiscoveryBatchUpdateOne {
	mutation := newDiscoveryBatchMutation(c.config, OpUpdateOne, withDiscoveryBatch(_m))
	return &DiscoveryBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiscoveryBatchClient) UpdateOneID(id string) *DiscoveryBatchUpdateOne {
	mutation := newDiscoveryBatchMutation(c.config, OpUpdateOne, withDiscoveryBatchID(id))
	return &DiscoveryBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DiscoveryBatch.
func (c *DiscoveryBatchClient) Delete() *DiscoveryBatchDelete {
	mutation := newDiscoveryBatchMutation(c.config, OpDelete)
	return &DiscoveryBatchDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiscoveryBatchClient) DeleteOne(_m *DiscoveryBatch) *DiscoveryBatchDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiscoveryBatchClient) DeleteOneID(id string) *DiscoveryBatchDeleteOne {
	builder := c.Delete().Where(discoverybatch.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiscoveryBatchDeleteOne{builder}
}

// Query returns a query builder for DiscoveryBatch.
func (c *DiscoveryBatchClient) Query() *DiscoveryBatchQuery {
	return &DiscoveryBatchQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDiscoveryBatch},
		inters: c.Interceptors(),
	}
}

// Get returns a DiscoveryBatch entity by its id.
func (c *DiscoveryBatchClient) Get(ctx context.Context, id string) (*DiscoveryBatch, error) {
	return c.Query().Where(discoverybatch.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiscoveryBatchClient) GetX(ctx context.Context, id string) *DiscoveryBatch {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a DiscoveryBatch.
func (c *DiscoveryBatchClient) QueryUser(_m *DiscoveryBatch) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discoverybatch.Table, discoverybatch.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, discoverybatch.UserTable, discoverybatch.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCards queries the cards edge of a DiscoveryBatch.
func (c *DiscoveryBatchClient) QueryCards(_m *DiscoveryBatch) *DiscoveryCardQuery {
	query := (&DiscoveryCardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discoverybatch.Table, discoverybatch.FieldID, id),
			sqlgraph.To(discoverycard.Table, discoverycard.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, discoverybatch.CardsTable, discoverybatch.CardsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiscoveryBatchClient) Hooks() []Hook {
	return c.hooks.DiscoveryBatch
}

// Interceptors returns the client interceptors.
func (c *DiscoveryBatchClient) Interceptors() []Interceptor {
	return c.inters.DiscoveryBatch
}

func (c *DiscoveryBatchClient) mutate(ctx context.Context, m *DiscoveryBatchMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiscoveryBatchCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiscoveryBatchUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiscoveryBatchUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiscoveryBatchDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DiscoveryBatch mutation op: %q", m.Op())
	}
}

// DiscoveryCardClient is a client for the DiscoveryCard schema.
type DiscoveryCardClient struct {
	config
}

// NewDiscoveryCardClient returns a client for the DiscoveryCard from the given config.
func NewDiscoveryCardClient(c config) *DiscoveryCardClient {
	return &DiscoveryCardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `discoverycard.Hooks(f(g(h())))`.
func (c *DiscoveryCardClient) Use(hooks ...Hook) {
	c.hooks.DiscoveryCard = append(c.hooks.DiscoveryCard, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `discoverycard.Intercept(f(g(h())))`.
func (c *DiscoveryCardClient) Intercept(interceptors ...Interceptor) {
	c.inters.DiscoveryCard = append(c.inters.DiscoveryCard, interceptors...)
}

// Create returns a builder for creating a DiscoveryCard entity.
func (c *DiscoveryCardClient) Create() *DiscoveryCardCreate {
	mutation := newDiscoveryCardMutation(c.config, OpCreate)
	return &DiscoveryCardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DiscoveryCard entities.
func (c *DiscoveryCardClient) CreateBulk(builders ...*DiscoveryCardCreate) *DiscoveryCardCreateBulk {
	return &DiscoveryCardCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiscoveryCardClient) MapCreateBulk(slice any, setFunc func(*DiscoveryCardCreate, int)) *DiscoveryCardCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiscoveryCardCreateBulk{err: fmt.Errorf("calling to DiscoveryCardClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiscoveryCardCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiscoveryCardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DiscoveryCard.
func (c *DiscoveryCardClient) Update() *DiscoveryCardUpdate {
	mutation := newDiscoveryCardMutation(c.config, OpUpdate)
	return &DiscoveryCardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiscoveryCardClient) UpdateOne(_m *DiscoveryCard) *DiscoveryCardUpdateOne {
	mutation := newDiscoveryCardMutation(c.config, OpUpdateOne, withDiscoveryCard(_m))
	return &DiscoveryCardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiscoveryCardClient) UpdateOneID(id string) *DiscoveryCardUpdateOne {
	mutation := newDiscoveryCardMutation(c.config, OpUpdateOne, withDiscoveryCardID(id))
	return &DiscoveryCardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DiscoveryCard.
func (c *DiscoveryCardClient) Delete() *DiscoveryCardDelete {
	mutation := newDiscoveryCardMutation(c.config, OpDelete)
	return &DiscoveryCardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiscoveryCardClient) DeleteOne(_m *DiscoveryCard) *DiscoveryCardDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiscoveryCardClient) DeleteOneID(id string) *DiscoveryCardDeleteOne {
	builder := c.Delete().Where(discoverycard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiscoveryCardDeleteOne{builder}
}

// Query returns a query builder for DiscoveryCard.
func (c *DiscoveryCardClient) Query() *DiscoveryCardQuery {
	return &DiscoveryCardQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDiscoveryCard},
		inters: c.Interceptors(),
	}
}

// Get returns a DiscoveryCard entity by its id.
func (c *DiscoveryCardClient) Get(ctx context.Context, id string) (*DiscoveryCard, error) {
	return c.Query().Where(discoverycard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiscoveryCardClient) GetX(ctx context.Context, id string) *DiscoveryCard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBatch queries the batch edge of a DiscoveryCard.
func (c *DiscoveryCardClient) QueryBatch(_m *DiscoveryCard) *DiscoveryBatchQuery {
	query := (&DiscoveryBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discoverycard.Table, discoverycard.FieldID, id),
			sqlgraph.To(discoverybatch.Table, discoverybatch.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, discoverycard.BatchTable, discoverycard.BatchColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCandidate queries the candidate edge of a DiscoveryCard.
func (c *DiscoveryCardClient) QueryCandidate(_m *DiscoveryCard) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discoverycard.Table, discoverycard.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, discoverycard.CandidateTable, discoverycard.CandidateColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInterests queries the interests edge of a DiscoveryCard.
func (c *DiscoveryCardClient) QueryInterests(_m *DiscoveryCard) *InterestQuery {
	query := (&InterestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discoverycard.Table, discoverycard.FieldID, id),
			sqlgraph.To(interest.Table, interest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, discoverycard.InterestsTable, discoverycard.InterestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiscoveryCardClient) Hooks() []Hook {
	return c.hooks.DiscoveryCard
}

// Interceptors returns the client interceptors.
func (c *DiscoveryCardClient) Interceptors() []Interceptor {
	return c.inters.DiscoveryCard
}

func (c *DiscoveryCardClient) mutate(ctx context.Context, m *DiscoveryCardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiscoveryCardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiscoveryCardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiscoveryCardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiscoveryCardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown DiscoveryCard mutation op: %q", m.Op())
	}
}

// FilterClient is a client for the Filter schema.
type FilterClient struct {
	config
}

// NewFilterClient returns a client for the Filter from the given config.
func NewFilterClient(c config) *FilterClient {
	return &FilterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `filter.Hooks(f(g(h())))`.
func (c *FilterClient) Use(hooks ...Hook) {
	c.hooks.Filter = append(c.hooks.Filter, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `filter.Intercept(f(g(h())))`.
func (c *FilterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Filter = append(c.inters.Filter, interceptors...)
}

// Create returns a builder for creating a Filter entity.
func (c *FilterClient) Create() *FilterCreate {
	mutation := newFilterMutation(c.config, OpCreate)
	return &FilterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Filter entities.
func (c *FilterClient) CreateBulk(builders ...*FilterCreate) *FilterCreateBulk {
	return &FilterCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FilterClient) MapCreateBulk(slice any, setFunc func(*FilterCreate, int)) *FilterCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FilterCreateBulk{err: fmt.Errorf("calling to FilterClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FilterCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FilterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Filter.
func (c *FilterClient) Update() *FilterUpdate {
	mutation := newFilterMutation(c.config, OpUpdate)
	return &FilterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FilterClient) UpdateOne(_m *Filter) *FilterUpdateOne {
	mutation := newFilterMutation(c.config, OpUpdateOne, withFilter(_m))
	return &FilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FilterClient) UpdateOneID(id string) *FilterUpdateOne {
	mutation := newFilterMutation(c.config, OpUpdateOne, withFilterID(id))
	return &FilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Filter.
func (c *FilterClient) Delete() *FilterDelete {
	mutation := newFilterMutation(c.config, OpDelete)
	return &FilterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FilterClient) DeleteOne(_m *Filter) *FilterDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FilterClient) DeleteOneID(id string) *FilterDeleteOne {
	builder := c.Delete().Where(filter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FilterDeleteOne{builder}
}

// Query returns a query builder for Filter.
func (c *FilterClient) Query() *FilterQuery {
	return &FilterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFilter},
		inters: c.Interceptors(),
	}
}

// Get returns a Filter entity by its id.
func (c *FilterClient) Get(ctx context.Context, id string) (*Filter, error) {
	return c.Query().Where(filter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FilterClient) GetX(ctx context.Context, id string) *Filter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Filter.
func (c *FilterClient) QueryUser(_m *Filter) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(filter.Table, filter.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, filter.UserTable, filter.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FilterClient) Hooks() []Hook {
	return c.hooks.Filter
}

// Interceptors returns the client interceptors.
func (c *FilterClient) Interceptors() []Interceptor {
	return c.inters.Filter
}

func (c *FilterClient) mutate(ctx context.Context, m *FilterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FilterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FilterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FilterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FilterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Filter mutation op: %q", m.Op())
	}
}

// HobbyClient is a client for the Hobby schema.
type HobbyClient struct {
	config
}

// NewHobbyClient returns a client for the Hobby from the given config.
func NewHobbyClient(c config) *HobbyClient {
	return &HobbyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hobby.Hooks(f(g(h())))`.
func (c *HobbyClient) Use(hooks ...Hook) {
	c.hooks.Hobby = append(c.hooks.Hobby, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hobby.Intercept(f(g(h())))`.
func (c *HobbyClient) Intercept(interceptors ...Interceptor) {
	c.inters.Hobby = append(c.inters.Hobby, interceptors...)
}

// Create returns a builder for creating a Hobby entity.
func (c *HobbyClient) Create() *HobbyCreate {
	mutation := newHobbyMutation(c.config, OpCreate)
	return &HobbyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hobby entities.
func (c *HobbyClient) CreateBulk(builders ...*HobbyCreate) *HobbyCreateBulk {
	return &HobbyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HobbyClient) MapCreateBulk(slice any, setFunc func(*HobbyCreate, int)) *HobbyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HobbyCreateBulk{err: fmt.Errorf("calling to HobbyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HobbyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HobbyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hobby.
func (c *HobbyClient) Update() *HobbyUpdate {
	mutation := newHobbyMutation(c.config, OpUpdate)
	return &HobbyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HobbyClient) UpdateOne(_m *Hobby) *HobbyUpdateOne {
	mutation := newHobbyMutation(c.config, OpUpdateOne, withHobby(_m))
	return &HobbyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HobbyClient) UpdateOneID(id string) *HobbyUpdateOne {
	mutation := newHobbyMutation(c.config, OpUpdateOne, withHobbyID(id))
	return &HobbyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hobby.
func (c *HobbyClient) Delete() *HobbyDelete {
	mutation := newHobbyMutation(c.config, OpDelete)
	return &HobbyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HobbyClient) DeleteOne(_m *Hobby) *HobbyDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HobbyClient) DeleteOneID(id string) *HobbyDeleteOne {
	builder := c.Delete().Where(hobby.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HobbyDeleteOne{builder}
}

// Query returns a query builder for Hobby.
func (c *HobbyClient) Query() *HobbyQuery {
	return &HobbyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHobby},
		inters: c.Interceptors(),
	}
}

// Get returns a Hobby entity by its id.
func (c *HobbyClient) Get(ctx context.Context, id string) (*Hobby, error) {
	return c.Query().Where(hobby.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HobbyClient) GetX(ctx context.Context, id string) *Hobby {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Hobby.
func (c *HobbyClient) QueryUser(_m *Hobby) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hobby.Table, hobby.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hobby.UserTable, hobby.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHobbyOption queries the hobby_option edge of a Hobby.
func (c *HobbyClient) QueryHobbyOption(_m *Hobby) *HobbyOptionQuery {
	query := (&HobbyOptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hobby.Table, hobby.FieldID, id),
			sqlgraph.To(hobbyoption.Table, hobbyoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hobby.HobbyOptionTable, hobby.HobbyOptionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HobbyClient) Hooks() []Hook {
	return c.hooks.Hobby
}

// Interceptors returns the client interceptors.
func (c *HobbyClient) Interceptors() []Interceptor {
	return c.inters.Hobby
}

func (c *HobbyClient) mutate(ctx context.Context, m *HobbyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HobbyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HobbyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HobbyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HobbyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Hobby mutation op: %q", m.Op())
	}
}

// HobbyOptionClient is a client for the HobbyOption schema.
type HobbyOptionClient struct {
	config
}

// NewHobbyOptionClient returns a client for the HobbyOption from the given config.
func NewHobbyOptionClient(c config) *HobbyOptionClient {
	return &HobbyOptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hobbyoption.Hooks(f(g(h())))`.
func (c *HobbyOptionClient) Use(hooks ...Hook) {
	c.hooks.HobbyOption = append(c.hooks.HobbyOption, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hobbyoption.Intercept(f(g(h())))`.
func (c *HobbyOptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.HobbyOption = append(c.inters.HobbyOption, interceptors...)
}

// Create returns a builder for creating a HobbyOption entity.
func (c *HobbyOptionClient) Create() *HobbyOptionCreate {
	mutation := newHobbyOptionMutation(c.config, OpCreate)
	return &HobbyOptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of HobbyOption entities.
func (c *HobbyOptionClient) CreateBulk(builders ...*HobbyOptionCreate) *HobbyOptionCreateBulk {
	return &HobbyOptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *HobbyOptionClient) MapCreateBulk(slice any, setFunc func(*HobbyOptionCreate, int)) *HobbyOptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &HobbyOptionCreateBulk{err: fmt.Errorf("calling to HobbyOptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*HobbyOptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &HobbyOptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for HobbyOption.
func (c *HobbyOptionClient) Update() *HobbyOptionUpdate {
	mutation := newHobbyOptionMutation(c.config, OpUpdate)
	return &HobbyOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HobbyOptionClient) UpdateOne(_m *HobbyOption) *HobbyOptionUpdateOne {
	mutation := newHobbyOptionMutation(c.config, OpUpdateOne, withHobbyOption(_m))
	return &HobbyOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HobbyOptionClient) UpdateOneID(id string) *HobbyOptionUpdateOne {
	mutation := newHobbyOptionMutation(c.config, OpUpdateOne, withHobbyOptionID(id))
	return &HobbyOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for HobbyOption.
func (c *HobbyOptionClient) Delete() *HobbyOptionDelete {
	mutation := newHobbyOptionMutation(c.config, OpDelete)
	return &HobbyOptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HobbyOptionClient) DeleteOne(_m *HobbyOption) *HobbyOptionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HobbyOptionClient) DeleteOneID(id string) *HobbyOptionDeleteOne {
	builder := c.Delete().Where(hobbyoption.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HobbyOptionDeleteOne{builder}
}

// Query returns a query builder for HobbyOption.
func (c *HobbyOptionClient) Query() *HobbyOptionQuery {
	return &HobbyOptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeHobbyOption},
		inters: c.Interceptors(),
	}
}

// Get returns a HobbyOption entity by its id.
func (c *HobbyOptionClient) Get(ctx context.Context, id string) (*HobbyOption, error) {
	return c.Query().Where(hobbyoption.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HobbyOptionClient) GetX(ctx context.Context, id string) *HobbyOption {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHobbies queries the hobbies edge of a HobbyOption.
func (c *HobbyOptionClient) QueryHobbies(_m *HobbyOption) *HobbyQuery {
	query := (&HobbyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hobbyoption.Table, hobbyoption.FieldID, id),
			sqlgraph.To(hobby.Table, hobby.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, hobbyoption.HobbiesTable, hobbyoption.HobbiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HobbyOptionClient) Hooks() []Hook {
	return c.hooks.HobbyOption
}

// Interceptors returns the client interceptors.
func (c *HobbyOptionClient) Interceptors() []Interceptor {
	return c.inters.HobbyOption
}

func (c *HobbyOptionClient) mutate(ctx context.Context, m *HobbyOptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HobbyOptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HobbyOptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HobbyOptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HobbyOptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown HobbyOption mutation op: %q", m.Op())
	}
}

// InterestClient is a client for the Interest schema.
type InterestClient struct {
	config
}

// NewInterestClient returns a client for the Interest from the given config.
func NewInterestClient(c config) *InterestClient {
	return &InterestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `interest.Hooks(f(g(h())))`.
func (c *InterestClient) Use(hooks ...Hook) {
	c.hooks.Interest = append(c.hooks.Interest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `interest.Intercept(f(g(h())))`.
func (c *InterestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Interest = append(c.inters.Interest, interceptors...)
}

// Create returns a builder for creating a Interest entity.
func (c *InterestClient) Create() *InterestCreate {
	mutation := newInterestMutation(c.config, OpCreate)
	return &InterestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Interest entities.
func (c *InterestClient) CreateBulk(builders ...*InterestCreate) *InterestCreateBulk {
	return &InterestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InterestClient) MapCreateBulk(slice any, setFunc func(*InterestCreate, int)) *InterestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InterestCreateBulk{err: fmt.Errorf("calling to InterestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InterestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InterestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Interest.
func (c *InterestClient) Update() *InterestUpdate {
	mutation := newInterestMutation(c.config, OpUpdate)
	return &InterestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InterestClient) UpdateOne(_m *Interest) *InterestUpdateOne {
	mutation := newInterestMutation(c.config, OpUpdateOne, withInterest(_m))
	return &InterestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InterestClient) UpdateOneID(id string) *InterestUpdateOne {
	mutation := newInterestMutation(c.config, OpUpdateOne, withInterestID(id))
	return &InterestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Interest.
func (c *InterestClient) Delete() *InterestDelete {
	mutation := newInterestMutation(c.config, OpDelete)
	return &InterestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InterestClient) DeleteOne(_m *Interest) *InterestDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InterestClient) DeleteOneID(id string) *InterestDeleteOne {
	builder := c.Delete().Where(interest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InterestDeleteOne{builder}
}

// Query returns a query builder for Interest.
func (c *InterestClient) Query() *InterestQuery {
	return &InterestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInterest},
		inters: c.Interceptors(),
	}
}

// Get returns a Interest entity by its id.
func (c *InterestClient) Get(ctx context.Context, id string) (*Interest, error) {
	return c.Query().Where(interest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InterestClient) GetX(ctx context.Context, id string) *Interest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySender queries the sender edge of a Interest.
func (c *InterestClient) QuerySender(_m *Interest) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interest.Table, interest.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, interest.SenderTable, interest.SenderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceiver queries the receiver edge of a Interest.
func (c *InterestClient) QueryReceiver(_m *Interest) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interest.Table, interest.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, interest.ReceiverTable, interest.ReceiverColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveryCard queries the discovery_card edge of a Interest.
func (c *InterestClient) QueryDiscoveryCard(_m *Interest) *DiscoveryCardQuery {
	query := (&DiscoveryCardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(interest.Table, interest.FieldID, id),
			sqlgraph.To(discoverycard.Table, discoverycard.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, interest.DiscoveryCardTable, interest.DiscoveryCardColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InterestClient) Hooks() []Hook {
	return c.hooks.Interest
}

// Interceptors returns the client interceptors.
func (c *InterestClient) Interceptors() []Interceptor {
	return c.inters.Interest
}

func (c *InterestClient) mutate(ctx context.Context, m *InterestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InterestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InterestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InterestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InterestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Interest mutation op: %q", m.Op())
	}
}

// NudgeClient is a client for the Nudge schema.
type NudgeClient struct {
	config
}

// NewNudgeClient returns a client for the Nudge from the given config.
func NewNudgeClient(c config) *NudgeClient {
	return &NudgeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nudge.Hooks(f(g(h())))`.
func (c *NudgeClient) Use(hooks ...Hook) {
	c.hooks.Nudge = append(c.hooks.Nudge, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nudge.Intercept(f(g(h())))`.
func (c *NudgeClient) Intercept(interceptors ...Interceptor) {
	c.inters.Nudge = append(c.inters.Nudge, interceptors...)
}

// Create returns a builder for creating a Nudge entity.
func (c *NudgeClient) Create() *NudgeCreate {
	mutation := newNudgeMutation(c.config, OpCreate)
	return &NudgeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Nudge entities.
func (c *NudgeClient) CreateBulk(builders ...*NudgeCreate) *NudgeCreateBulk {
	return &NudgeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NudgeClient) MapCreateBulk(slice any, setFunc func(*NudgeCreate, int)) *NudgeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NudgeCreateBulk{err: fmt.Errorf("calling to NudgeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NudgeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NudgeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Nudge.
func (c *NudgeClient) Update() *NudgeUpdate {
	mutation := newNudgeMutation(c.config, OpUpdate)
	return &NudgeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NudgeClient) UpdateOne(_m *Nudge) *NudgeUpdateOne {
	mutation := newNudgeMutation(c.config, OpUpdateOne, withNudge(_m))
	return &NudgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NudgeClient) UpdateOneID(id string) *NudgeUpdateOne {
	mutation := newNudgeMutation(c.config, OpUpdateOne, withNudgeID(id))
	return &NudgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Nudge.
func (c *NudgeClient) Delete() *NudgeDelete {
	mutation := newNudgeMutation(c.config, OpDelete)
	return &NudgeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NudgeClient) DeleteOne(_m *Nudge) *NudgeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NudgeClient) DeleteOneID(id string) *NudgeDeleteOne {
	builder := c.Delete().Where(nudge.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NudgeDeleteOne{builder}
}

// Query returns a query builder for Nudge.
func (c *NudgeClient) Query() *NudgeQuery {
	return &NudgeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNudge},
		inters: c.Interceptors(),
	}
}

// Get returns a Nudge entity by its id.
func (c *NudgeClient) Get(ctx context.Context, id string) (*Nudge, error) {
	return c.Query().Where(nudge.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NudgeClient) GetX(ctx context.Context, id string) *Nudge {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStreak queries the streak edge of a Nudge.
func (c *NudgeClient) QueryStreak(_m *Nudge) *StreakQuery {
	query := (&StreakClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nudge.Table, nudge.FieldID, id),
			sqlgraph.To(streak.Table, streak.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nudge.StreakTable, nudge.StreakColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySender queries the sender edge of a Nudge.
func (c *NudgeClient) QuerySender(_m *Nudge) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nudge.Table, nudge.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nudge.SenderTable, nudge.SenderColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceiver queries the receiver edge of a Nudge.
func (c *NudgeClient) QueryReceiver(_m *Nudge) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nudge.Table, nudge.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nudge.ReceiverTable, nudge.ReceiverColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NudgeClient) Hooks() []Hook {
	return c.hooks.Nudge
}

// Interceptors returns the client interceptors.
func (c *NudgeClient) Interceptors() []Interceptor {
	return c.inters.Nudge
}

func (c *NudgeClient) mutate(ctx context.Context, m *NudgeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NudgeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NudgeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NudgeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NudgeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Nudge mutation op: %q", m.Op())
	}
}

// PaymentOrderClient is a client for the PaymentOrder schema.
type PaymentOrderClient struct {
	config
}

// NewPaymentOrderClient returns a client for the PaymentOrder from the given config.
func NewPaymentOrderClient(c config) *PaymentOrderClient {
	return &PaymentOrderClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `paymentorder.Hooks(f(g(h())))`.
func (c *PaymentOrderClient) Use(hooks ...Hook) {
	c.hooks.PaymentOrder = append(c.hooks.PaymentOrder, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `paymentorder.Intercept(f(g(h())))`.
func (c *PaymentOrderClient) Intercept(interceptors ...Interceptor) {
	c.inters.PaymentOrder = append(c.inters.PaymentOrder, interceptors...)
}

// Create returns a builder for creating a PaymentOrder entity.
func (c *PaymentOrderClient) Create() *PaymentOrderCreate {
	mutation := newPaymentOrderMutation(c.config, OpCreate)
	return &PaymentOrderCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PaymentOrder entities.
func (c *PaymentOrderClient) CreateBulk(builders ...*PaymentOrderCreate) *PaymentOrderCreateBulk {
	return &PaymentOrderCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PaymentOrderClient) MapCreateBulk(slice any, setFunc func(*PaymentOrderCreate, int)) *PaymentOrderCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PaymentOrderCreateBulk{err: fmt.Errorf("calling to PaymentOrderClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PaymentOrderCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PaymentOrderCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PaymentOrder.
func (c *PaymentOrderClient) Update() *PaymentOrderUpdate {
	mutation := newPaymentOrderMutation(c.config, OpUpdate)
	return &PaymentOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PaymentOrderClient) UpdateOne(_m *PaymentOrder) *PaymentOrderUpdateOne {
	mutation := newPaymentOrderMutation(c.config, OpUpdateOne, withPaymentOrder(_m))
	return &PaymentOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PaymentOrderClient) UpdateOneID(id string) *PaymentOrderUpdateOne {
	mutation := newPaymentOrderMutation(c.config, OpUpdateOne, withPaymentOrderID(id))
	return &PaymentOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PaymentOrder.
func (c *PaymentOrderClient) Delete() *PaymentOrderDelete {
	mutation := newPaymentOrderMutation(c.config, OpDelete)
	return &PaymentOrderDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PaymentOrderClient) DeleteOne(_m *PaymentOrder) *PaymentOrderDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PaymentOrderClient) DeleteOneID(id string) *PaymentOrderDeleteOne {
	builder := c.Delete().Where(paymentorder.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PaymentOrderDeleteOne{builder}
}

// Query returns a query builder for PaymentOrder.
func (c *PaymentOrderClient) Query() *PaymentOrderQuery {
	return &PaymentOrderQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePaymentOrder},
		inters: c.Interceptors(),
	}
}

// Get returns a PaymentOrder entity by its id.
func (c *PaymentOrderClient) Get(ctx context.Context, id string) (*PaymentOrder, error) {
	return c.Query().Where(paymentorder.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PaymentOrderClient) GetX(ctx context.Context, id string) *PaymentOrder {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a PaymentOrder.
func (c *PaymentOrderClient) QueryUser(_m *PaymentOrder) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(paymentorder.Table, paymentorder.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, paymentorder.UserTable, paymentorder.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PaymentOrderClient) Hooks() []Hook {
	return c.hooks.PaymentOrder
}

// Interceptors returns the client interceptors.
func (c *PaymentOrderClient) Interceptors() []Interceptor {
	return c.inters.PaymentOrder
}

func (c *PaymentOrderClient) mutate(ctx context.Context, m *PaymentOrderMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PaymentOrderCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PaymentOrderUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PaymentOrderUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PaymentOrderDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown PaymentOrder mutation op: %q", m.Op())
	}
}

// PhotoClient is a client for the Photo schema.
type PhotoClient struct {
	config
}

// NewPhotoClient returns a client for the Photo from the given config.
func NewPhotoClient(c config) *PhotoClient {
	return &PhotoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `photo.Hooks(f(g(h())))`.
func (c *PhotoClient) Use(hooks ...Hook) {
	c.hooks.Photo = append(c.hooks.Photo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `photo.Intercept(f(g(h())))`.
func (c *PhotoClient) Intercept(interceptors ...Interceptor) {
	c.inters.Photo = append(c.inters.Photo, interceptors...)
}

// Create returns a builder for creating a Photo entity.
func (c *PhotoClient) Create() *PhotoCreate {
	mutation := newPhotoMutation(c.config, OpCreate)
	return &PhotoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Photo entities.
func (c *PhotoClient) CreateBulk(builders ...*PhotoCreate) *PhotoCreateBulk {
	return &PhotoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PhotoClient) MapCreateBulk(slice any, setFunc func(*PhotoCreate, int)) *PhotoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PhotoCreateBulk{err: fmt.Errorf("calling to PhotoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PhotoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PhotoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Photo.
func (c *PhotoClient) Update() *PhotoUpdate {
	mutation := newPhotoMutation(c.config, OpUpdate)
	return &PhotoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PhotoClient) UpdateOne(_m *Photo) *PhotoUpdateOne {
	mutation := newPhotoMutation(c.config, OpUpdateOne, withPhoto(_m))
	return &PhotoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PhotoClient) UpdateOneID(id string) *PhotoUpdateOne {
	mutation := newPhotoMutation(c.config, OpUpdateOne, withPhotoID(id))
	return &PhotoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Photo.
func (c *PhotoClient) Delete() *PhotoDelete {
	mutation := newPhotoMutation(c.config, OpDelete)
	return &PhotoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PhotoClient) DeleteOne(_m *Photo) *PhotoDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PhotoClient) DeleteOneID(id string) *PhotoDeleteOne {
	builder := c.Delete().Where(photo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PhotoDeleteOne{builder}
}

// Query returns a query builder for Photo.
func (c *PhotoClient) Query() *PhotoQuery {
	return &PhotoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePhoto},
		inters: c.Interceptors(),
	}
}

// Get returns a Photo entity by its id.
func (c *PhotoClient) Get(ctx context.Context, id string) (*Photo, error) {
	return c.Query().Where(photo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PhotoClient) GetX(ctx context.Context, id string) *Photo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Photo.
func (c *PhotoClient) QueryUser(_m *Photo) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(photo.Table, photo.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, photo.UserTable, photo.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PhotoClient) Hooks() []Hook {
	return c.hooks.Photo
}

// Interceptors returns the client interceptors.
func (c *PhotoClient) Interceptors() []Interceptor {
	return c.inters.Photo
}

func (c *PhotoClient) mutate(ctx context.Context, m *PhotoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PhotoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PhotoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PhotoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PhotoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Photo mutation op: %q", m.Op())
	}
}

// ProfileClient is a client for the Profile schema.
type ProfileClient struct {
	config
}

// NewProfileClient returns a client for the Profile from the given config.
func NewProfileClient(c config) *ProfileClient {
	return &ProfileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `profile.Hooks(f(g(h())))`.
func (c *ProfileClient) Use(hooks ...Hook) {
	c.hooks.Profile = append(c.hooks.Profile, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `profile.Intercept(f(g(h())))`.
func (c *ProfileClient) Intercept(interceptors ...Interceptor) {
	c.inters.Profile = append(c.inters.Profile, interceptors...)
}

// Create returns a builder for creating a Profile entity.
func (c *ProfileClient) Create() *ProfileCreate {
	mutation := newProfileMutation(c.config, OpCreate)
	return &ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Profile entities.
func (c *ProfileClient) CreateBulk(builders ...*ProfileCreate) *ProfileCreateBulk {
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProfileClient) MapCreateBulk(slice any, setFunc func(*ProfileCreate, int)) *ProfileCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProfileCreateBulk{err: fmt.Errorf("calling to ProfileClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProfileCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProfileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Profile.
func (c *ProfileClient) Update() *ProfileUpdate {
	mutation := newProfileMutation(c.config, OpUpdate)
	return &ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProfileClient) UpdateOne(_m *Profile) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfile(_m))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProfileClient) UpdateOneID(id string) *ProfileUpdateOne {
	mutation := newProfileMutation(c.config, OpUpdateOne, withProfileID(id))
	return &ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Profile.
func (c *ProfileClient) Delete() *ProfileDelete {
	mutation := newProfileMutation(c.config, OpDelete)
	return &ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProfileClient) DeleteOne(_m *Profile) *ProfileDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProfileClient) DeleteOneID(id string) *ProfileDeleteOne {
	builder := c.Delete().Where(profile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProfileDeleteOne{builder}
}

// Query returns a query builder for Profile.
func (c *ProfileClient) Query() *ProfileQuery {
	return &ProfileQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProfile},
		inters: c.Interceptors(),
	}
}

// Get returns a Profile entity by its id.
func (c *ProfileClient) Get(ctx context.Context, id string) (*Profile, error) {
	return c.Query().Where(profile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProfileClient) GetX(ctx context.Context, id string) *Profile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Profile.
func (c *ProfileClient) QueryUser(_m *Profile) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(profile.Table, profile.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, profile.UserTable, profile.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProfileClient) Hooks() []Hook {
	return c.hooks.Profile
}

// Interceptors returns the client interceptors.
func (c *ProfileClient) Interceptors() []Interceptor {
	return c.inters.Profile
}

func (c *ProfileClient) mutate(ctx context.Context, m *ProfileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProfileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProfileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProfileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProfileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Profile mutation op: %q", m.Op())
	}
}

// RevealClient is a client for the Reveal schema.
type RevealClient struct {
	config
}

// NewRevealClient returns a client for the Reveal from the given config.
func NewRevealClient(c config) *RevealClient {
	return &RevealClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reveal.Hooks(f(g(h())))`.
func (c *RevealClient) Use(hooks ...Hook) {
	c.hooks.Reveal = append(c.hooks.Reveal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reveal.Intercept(f(g(h())))`.
func (c *RevealClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reveal = append(c.inters.Reveal, interceptors...)
}

// Create returns a builder for creating a Reveal entity.
func (c *RevealClient) Create() *RevealCreate {
	mutation := newRevealMutation(c.config, OpCreate)
	return &RevealCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reveal entities.
func (c *RevealClient) CreateBulk(builders ...*RevealCreate) *RevealCreateBulk {
	return &RevealCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RevealClient) MapCreateBulk(slice any, setFunc func(*RevealCreate, int)) *RevealCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RevealCreateBulk{err: fmt.Errorf("calling to RevealClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RevealCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RevealCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reveal.
func (c *RevealClient) Update() *RevealUpdate {
	mutation := newRevealMutation(c.config, OpUpdate)
	return &RevealUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RevealClient) UpdateOne(_m *Reveal) *RevealUpdateOne {
	mutation := newRevealMutation(c.config, OpUpdateOne, withReveal(_m))
	return &RevealUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RevealClient) UpdateOneID(id string) *RevealUpdateOne {
	mutation := newRevealMutation(c.config, OpUpdateOne, withRevealID(id))
	return &RevealUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reveal.
func (c *RevealClient) Delete() *RevealDelete {
	mutation := newRevealMutation(c.config, OpDelete)
	return &RevealDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RevealClient) DeleteOne(_m *Reveal) *RevealDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RevealClient) DeleteOneID(id string) *RevealDeleteOne {
	builder := c.Delete().Where(reveal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RevealDeleteOne{builder}
}

// Query returns a query builder for Reveal.
func (c *RevealClient) Query() *RevealQuery {
	return &RevealQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeReveal},
		inters: c.Interceptors(),
	}
}

// Get returns a Reveal entity by its id.
func (c *RevealClient) Get(ctx context.Context, id string) (*Reveal, error) {
	return c.Query().Where(reveal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RevealClient) GetX(ctx context.Context, id string) *Reveal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConnection queries the connection edge of a Reveal.
func (c *RevealClient) QueryConnection(_m *Reveal) *ConnectionQuery {
	query := (&ConnectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reveal.Table, reveal.FieldID, id),
			sqlgraph.To(connection.Table, connection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reveal.ConnectionTable, reveal.ConnectionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMilestone queries the milestone edge of a Reveal.
func (c *RevealClient) QueryMilestone(_m *Reveal) *RevealMilestoneQuery {
	query := (&RevealMilestoneClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reveal.Table, reveal.FieldID, id),
			sqlgraph.To(revealmilestone.Table, revealmilestone.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reveal.MilestoneTable, reveal.MilestoneColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContent queries the content edge of a Reveal.
func (c *RevealClient) QueryContent(_m *Reveal) *RevealContentQuery {
	query := (&RevealContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reveal.Table, reveal.FieldID, id),
			sqlgraph.To(revealcontent.Table, revealcontent.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, reveal.ContentTable, reveal.ContentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RevealClient) Hooks() []Hook {
	return c.hooks.Reveal
}

// Interceptors returns the client interceptors.
func (c *RevealClient) Interceptors() []Interceptor {
	return c.inters.Reveal
}

func (c *RevealClient) mutate(ctx context.Context, m *RevealMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RevealCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RevealUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RevealUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RevealDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Reveal mutation op: %q", m.Op())
	}
}

// RevealContentClient is a client for the RevealContent schema.
type RevealContentClient struct {
	config
}

// NewRevealContentClient returns a client for the RevealContent from the given config.
func NewRevealContentClient(c config) *RevealContentClient {
	return &RevealContentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `revealcontent.Hooks(f(g(h())))`.
func (c *RevealContentClient) Use(hooks ...Hook) {
	c.hooks.RevealContent = append(c.hooks.RevealContent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `revealcontent.Intercept(f(g(h())))`.
func (c *RevealContentClient) Intercept(interceptors ...Interceptor) {
	c.inters.RevealContent = append(c.inters.RevealContent, interceptors...)
}

// Create returns a builder for creating a RevealContent entity.
func (c *RevealContentClient) Create() *RevealContentCreate {
	mutation := newRevealContentMutation(c.config, OpCreate)
	return &RevealContentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RevealContent entities.
func (c *RevealContentClient) CreateBulk(builders ...*RevealContentCreate) *RevealContentCreateBulk {
	return &RevealContentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RevealContentClient) MapCreateBulk(slice any, setFunc func(*RevealContentCreate, int)) *RevealContentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RevealContentCreateBulk{err: fmt.Errorf("calling to RevealContentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RevealContentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RevealContentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RevealContent.
func (c *RevealContentClient) Update() *RevealContentUpdate {
	mutation := newRevealContentMutation(c.config, OpUpdate)
	return &RevealContentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RevealContentClient) UpdateOne(_m *RevealContent) *RevealContentUpdateOne {
	mutation := newRevealContentMutation(c.config, OpUpdateOne, withRevealContent(_m))
	return &RevealContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RevealContentClient) UpdateOneID(id string) *RevealContentUpdateOne {
	mutation := newRevealContentMutation(c.config, OpUpdateOne, withRevealContentID(id))
	return &RevealContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RevealContent.
func (c *RevealContentClient) Delete() *RevealContentDelete {
	mutation := newRevealContentMutation(c.config, OpDelete)
	return &RevealContentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RevealContentClient) DeleteOne(_m *RevealContent) *RevealContentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RevealContentClient) DeleteOneID(id string) *RevealContentDeleteOne {
	builder := c.Delete().Where(revealcontent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RevealContentDeleteOne{builder}
}

// Query returns a query builder for RevealContent.
func (c *RevealContentClient) Query() *RevealContentQuery {
	return &RevealContentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRevealContent},
		inters: c.Interceptors(),
	}
}

// Get returns a RevealContent entity by its id.
func (c *RevealContentClient) Get(ctx context.Context, id string) (*RevealContent, error) {
	return c.Query().Where(revealcontent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RevealContentClient) GetX(ctx context.Context, id string) *RevealContent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReveal queries the reveal edge of a RevealContent.
func (c *RevealContentClient) QueryReveal(_m *RevealContent) *RevealQuery {
	query := (&RevealClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(revealcontent.Table, revealcontent.FieldID, id),
			sqlgraph.To(reveal.Table, reveal.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, revealcontent.RevealTable, revealcontent.RevealColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RevealContentClient) Hooks() []Hook {
	return c.hooks.RevealContent
}

// Interceptors returns the client interceptors.
func (c *RevealContentClient) Interceptors() []Interceptor {
	return c.inters.RevealContent
}

func (c *RevealContentClient) mutate(ctx context.Context, m *RevealContentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RevealContentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RevealContentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RevealContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RevealContentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RevealContent mutation op: %q", m.Op())
	}
}

// RevealMilestoneClient is a client for the RevealMilestone schema.
type RevealMilestoneClient struct {
	config
}

// NewRevealMilestoneClient returns a client for the RevealMilestone from the given config.
func NewRevealMilestoneClient(c config) *RevealMilestoneClient {
	return &RevealMilestoneClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `revealmilestone.Hooks(f(g(h())))`.
func (c *RevealMilestoneClient) Use(hooks ...Hook) {
	c.hooks.RevealMilestone = append(c.hooks.RevealMilestone, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `revealmilestone.Intercept(f(g(h())))`.
func (c *RevealMilestoneClient) Intercept(interceptors ...Interceptor) {
	c.inters.RevealMilestone = append(c.inters.RevealMilestone, interceptors...)
}

// Create returns a builder for creating a RevealMilestone entity.
func (c *RevealMilestoneClient) Create() *RevealMilestoneCreate {
	mutation := newRevealMilestoneMutation(c.config, OpCreate)
	return &RevealMilestoneCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RevealMilestone entities.
func (c *RevealMilestoneClient) CreateBulk(builders ...*RevealMilestoneCreate) *RevealMilestoneCreateBulk {
	return &RevealMilestoneCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RevealMilestoneClient) MapCreateBulk(slice any, setFunc func(*RevealMilestoneCreate, int)) *RevealMilestoneCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RevealMilestoneCreateBulk{err: fmt.Errorf("calling to RevealMilestoneClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RevealMilestoneCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RevealMilestoneCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RevealMilestone.
func (c *RevealMilestoneClient) Update() *RevealMilestoneUpdate {
	mutation := newRevealMilestoneMutation(c.config, OpUpdate)
	return &RevealMilestoneUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RevealMilestoneClient) UpdateOne(_m *RevealMilestone) *RevealMilestoneUpdateOne {
	mutation := newRevealMilestoneMutation(c.config, OpUpdateOne, withRevealMilestone(_m))
	return &RevealMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RevealMilestoneClient) UpdateOneID(id string) *RevealMilestoneUpdateOne {
	mutation := newRevealMilestoneMutation(c.config, OpUpdateOne, withRevealMilestoneID(id))
	return &RevealMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RevealMilestone.
func (c *RevealMilestoneClient) Delete() *RevealMilestoneDelete {
	mutation := newRevealMilestoneMutation(c.config, OpDelete)
	return &RevealMilestoneDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RevealMilestoneClient) DeleteOne(_m *RevealMilestone) *RevealMilestoneDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RevealMilestoneClient) DeleteOneID(id string) *RevealMilestoneDeleteOne {
	builder := c.Delete().Where(revealmilestone.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RevealMilestoneDeleteOne{builder}
}

// Query returns a query builder for RevealMilestone.
func (c *RevealMilestoneClient) Query() *RevealMilestoneQuery {
	return &RevealMilestoneQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRevealMilestone},
		inters: c.Interceptors(),
	}
}

// Get returns a RevealMilestone entity by its id.
func (c *RevealMilestoneClient) Get(ctx context.Context, id string) (*RevealMilestone, error) {
	return c.Query().Where(revealmilestone.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RevealMilestoneClient) GetX(ctx context.Context, id string) *RevealMilestone {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReveals queries the reveals edge of a RevealMilestone.
func (c *RevealMilestoneClient) QueryReveals(_m *RevealMilestone) *RevealQuery {
	query := (&RevealClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(revealmilestone.Table, revealmilestone.FieldID, id),
			sqlgraph.To(reveal.Table, reveal.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, revealmilestone.RevealsTable, revealmilestone.RevealsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RevealMilestoneClient) Hooks() []Hook {
	return c.hooks.RevealMilestone
}

// Interceptors returns the client interceptors.
func (c *RevealMilestoneClient) Interceptors() []Interceptor {
	return c.inters.RevealMilestone
}

func (c *RevealMilestoneClient) mutate(ctx context.Context, m *RevealMilestoneMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RevealMilestoneCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RevealMilestoneUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RevealMilestoneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RevealMilestoneDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown RevealMilestone mutation op: %q", m.Op())
	}
}

// ServerClient is a client for the Server schema.
type ServerClient struct {
	config
}

// NewServerClient returns a client for the Server from the given config.
func NewServerClient(c config) *ServerClient {
	return &ServerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `server.Hooks(f(g(h())))`.
func (c *ServerClient) Use(hooks ...Hook) {
	c.hooks.Server = append(c.hooks.Server, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `server.Intercept(f(g(h())))`.
func (c *ServerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Server = append(c.inters.Server, interceptors...)
}

// Create returns a builder for creating a Server entity.
func (c *ServerClient) Create() *ServerCreate {
	mutation := newServerMutation(c.config, OpCreate)
	return &ServerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Server entities.
func (c *ServerClient) CreateBulk(builders ...*ServerCreate) *ServerCreateBulk {
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ServerClient) MapCreateBulk(slice any, setFunc func(*ServerCreate, int)) *ServerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ServerCreateBulk{err: fmt.Errorf("calling to ServerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ServerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Server.
func (c *ServerClient) Update() *ServerUpdate {
	mutation := newServerMutation(c.config, OpUpdate)
	return &ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerClient) UpdateOne(_m *Server) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServer(_m))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerClient) UpdateOneID(id string) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServerID(id))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Server.
func (c *ServerClient) Delete() *ServerDelete {
	mutation := newServerMutation(c.config, OpDelete)
	return &ServerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServerClient) DeleteOne(_m *Server) *ServerDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServerClient) DeleteOneID(id string) *ServerDeleteOne {
	builder := c.Delete().Where(server.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerDeleteOne{builder}
}

// Query returns a query builder for Server.
func (c *ServerClient) Query() *ServerQuery {
	return &ServerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServer},
		inters: c.Interceptors(),
	}
}

// Get returns a Server entity by its id.
func (c *ServerClient) Get(ctx context.Context, id string) (*Server, error) {
	return c.Query().Where(server.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerClient) GetX(ctx context.Context, id string) *Server {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ServerClient) Hooks() []Hook {
	return c.hooks.Server
}

// Interceptors returns the client interceptors.
func (c *ServerClient) Interceptors() []Interceptor {
	return c.inters.Server
}

func (c *ServerClient) mutate(ctx context.Context, m *ServerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Server mutation op: %q", m.Op())
	}
}

// StreakClient is a client for the Streak schema.
type StreakClient struct {
	config
}

// NewStreakClient returns a client for the Streak from the given config.
func NewStreakClient(c config) *StreakClient {
	return &StreakClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `streak.Hooks(f(g(h())))`.
func (c *StreakClient) Use(hooks ...Hook) {
	c.hooks.Streak = append(c.hooks.Streak, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `streak.Intercept(f(g(h())))`.
func (c *StreakClient) Intercept(interceptors ...Interceptor) {
	c.inters.Streak = append(c.inters.Streak, interceptors...)
}

// Create returns a builder for creating a Streak entity.
func (c *StreakClient) Create() *StreakCreate {
	mutation := newStreakMutation(c.config, OpCreate)
	return &StreakCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Streak entities.
func (c *StreakClient) CreateBulk(builders ...*StreakCreate) *StreakCreateBulk {
	return &StreakCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StreakClient) MapCreateBulk(slice any, setFunc func(*StreakCreate, int)) *StreakCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StreakCreateBulk{err: fmt.Errorf("calling to StreakClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StreakCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StreakCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Streak.
func (c *StreakClient) Update() *StreakUpdate {
	mutation := newStreakMutation(c.config, OpUpdate)
	return &StreakUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StreakClient) UpdateOne(_m *Streak) *StreakUpdateOne {
	mutation := newStreakMutation(c.config, OpUpdateOne, withStreak(_m))
	return &StreakUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StreakClient) UpdateOneID(id string) *StreakUpdateOne {
	mutation := newStreakMutation(c.config, OpUpdateOne, withStreakID(id))
	return &StreakUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Streak.
func (c *StreakClient) Delete() *StreakDelete {
	mutation := newStreakMutation(c.config, OpDelete)
	return &StreakDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StreakClient) DeleteOne(_m *Streak) *StreakDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StreakClient) DeleteOneID(id string) *StreakDeleteOne {
	builder := c.Delete().Where(streak.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StreakDeleteOne{builder}
}

// Query returns a query builder for Streak.
func (c *StreakClient) Query() *StreakQuery {
	return &StreakQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStreak},
		inters: c.Interceptors(),
	}
}

// Get returns a Streak entity by its id.
func (c *StreakClient) Get(ctx context.Context, id string) (*Streak, error) {
	return c.Query().Where(streak.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StreakClient) GetX(ctx context.Context, id string) *Streak {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryConnection queries the connection edge of a Streak.
func (c *StreakClient) QueryConnection(_m *Streak) *ConnectionQuery {
	query := (&ConnectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(streak.Table, streak.FieldID, id),
			sqlgraph.To(connection.Table, connection.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, streak.ConnectionTable, streak.ConnectionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBreaker queries the breaker edge of a Streak.
func (c *StreakClient) QueryBreaker(_m *Streak) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(streak.Table, streak.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, streak.BreakerTable, streak.BreakerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCheckIns queries the check_ins edge of a Streak.
func (c *StreakClient) QueryCheckIns(_m *Streak) *CheckInQuery {
	query := (&CheckInClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(streak.Table, streak.FieldID, id),
			sqlgraph.To(checkin.Table, checkin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, streak.CheckInsTable, streak.CheckInsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNudges queries the nudges edge of a Streak.
func (c *StreakClient) QueryNudges(_m *Streak) *NudgeQuery {
	query := (&NudgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(streak.Table, streak.FieldID, id),
			sqlgraph.To(nudge.Table, nudge.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, streak.NudgesTable, streak.NudgesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StreakClient) Hooks() []Hook {
	return c.hooks.Streak
}

// Interceptors returns the client interceptors.
func (c *StreakClient) Interceptors() []Interceptor {
	return c.inters.Streak
}

func (c *StreakClient) mutate(ctx context.Context, m *StreakMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StreakCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StreakUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StreakUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StreakDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown Streak mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProfile queries the profile edge of a User.
func (c *UserClient) QueryProfile(_m *User) *ProfileQuery {
	query := (&ProfileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(profile.Table, profile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.ProfileTable, user.ProfileColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPhotos queries the photos edge of a User.
func (c *UserClient) QueryPhotos(_m *User) *PhotoQuery {
	query := (&PhotoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(photo.Table, photo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PhotosTable, user.PhotosColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHobbies queries the hobbies edge of a User.
func (c *UserClient) QueryHobbies(_m *User) *HobbyQuery {
	query := (&HobbyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(hobby.Table, hobby.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.HobbiesTable, user.HobbiesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFilters queries the filters edge of a User.
func (c *UserClient) QueryFilters(_m *User) *FilterQuery {
	query := (&FilterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(filter.Table, filter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FiltersTable, user.FiltersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveryBatches queries the discovery_batches edge of a User.
func (c *UserClient) QueryDiscoveryBatches(_m *User) *DiscoveryBatchQuery {
	query := (&DiscoveryBatchClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(discoverybatch.Table, discoverybatch.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DiscoveryBatchesTable, user.DiscoveryBatchesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscoveryAppearances queries the discovery_appearances edge of a User.
func (c *UserClient) QueryDiscoveryAppearances(_m *User) *DiscoveryCardQuery {
	query := (&DiscoveryCardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(discoverycard.Table, discoverycard.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DiscoveryAppearancesTable, user.DiscoveryAppearancesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySentInterests queries the sent_interests edge of a User.
func (c *UserClient) QuerySentInterests(_m *User) *InterestQuery {
	query := (&InterestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(interest.Table, interest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SentInterestsTable, user.SentInterestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceivedInterests queries the received_interests edge of a User.
func (c *UserClient) QueryReceivedInterests(_m *User) *InterestQuery {
	query := (&InterestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(interest.Table, interest.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReceivedInterestsTable, user.ReceivedInterestsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectionsAsA queries the connections_as_a edge of a User.
func (c *UserClient) QueryConnectionsAsA(_m *User) *ConnectionQuery {
	query := (&ConnectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(connection.Table, connection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConnectionsAsATable, user.ConnectionsAsAColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnectionsAsB queries the connections_as_b edge of a User.
func (c *UserClient) QueryConnectionsAsB(_m *User) *ConnectionQuery {
	query := (&ConnectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(connection.Table, connection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConnectionsAsBTable, user.ConnectionsAsBColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBrokenStreaks queries the broken_streaks edge of a User.
func (c *UserClient) QueryBrokenStreaks(_m *User) *StreakQuery {
	query := (&StreakClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(streak.Table, streak.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BrokenStreaksTable, user.BrokenStreaksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCheckIns queries the check_ins edge of a User.
func (c *UserClient) QueryCheckIns(_m *User) *CheckInQuery {
	query := (&CheckInClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(checkin.Table, checkin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CheckInsTable, user.CheckInsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySentNudges queries the sent_nudges edge of a User.
func (c *UserClient) QuerySentNudges(_m *User) *NudgeQuery {
	query := (&NudgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(nudge.Table, nudge.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SentNudgesTable, user.SentNudgesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceivedNudges queries the received_nudges edge of a User.
func (c *UserClient) QueryReceivedNudges(_m *User) *NudgeQuery {
	query := (&NudgeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(nudge.Table, nudge.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReceivedNudgesTable, user.ReceivedNudgesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreditTransactions queries the credit_transactions edge of a User.
func (c *UserClient) QueryCreditTransactions(_m *User) *CreditTransactionQuery {
	query := (&CreditTransactionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(credittransaction.Table, credittransaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreditTransactionsTable, user.CreditTransactionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPaymentOrders queries the payment_orders edge of a User.
func (c *UserClient) QueryPaymentOrders(_m *User) *PaymentOrderQuery {
	query := (&PaymentOrderClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(paymentorder.Table, paymentorder.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PaymentOrdersTable, user.PaymentOrdersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlocksGiven queries the blocks_given edge of a User.
func (c *UserClient) QueryBlocksGiven(_m *User) *UserBlockQuery {
	query := (&UserBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userblock.Table, userblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BlocksGivenTable, user.BlocksGivenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlocksReceived queries the blocks_received edge of a User.
func (c *UserClient) QueryBlocksReceived(_m *User) *UserBlockQuery {
	query := (&UserBlockClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userblock.Table, userblock.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.BlocksReceivedTable, user.BlocksReceivedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReportsGiven queries the reports_given edge of a User.
func (c *UserClient) QueryReportsGiven(_m *User) *UserReportQuery {
	query := (&UserReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userreport.Table, userreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReportsGivenTable, user.ReportsGivenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReportsReceived queries the reports_received edge of a User.
func (c *UserClient) QueryReportsReceived(_m *User) *UserReportQuery {
	query := (&UserReportClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userreport.Table, userreport.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReportsReceivedTable, user.ReportsReceivedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown User mutation op: %q", m.Op())
	}
}

// UserBlockClient is a client for the UserBlock schema.
type UserBlockClient struct {
	config
}

// NewUserBlockClient returns a client for the UserBlock from the given config.
func NewUserBlockClient(c config) *UserBlockClient {
	return &UserBlockClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userblock.Hooks(f(g(h())))`.
func (c *UserBlockClient) Use(hooks ...Hook) {
	c.hooks.UserBlock = append(c.hooks.UserBlock, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userblock.Intercept(f(g(h())))`.
func (c *UserBlockClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserBlock = append(c.inters.UserBlock, interceptors...)
}

// Create returns a builder for creating a UserBlock entity.
func (c *UserBlockClient) Create() *UserBlockCreate {
	mutation := newUserBlockMutation(c.config, OpCreate)
	return &UserBlockCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserBlock entities.
func (c *UserBlockClient) CreateBulk(builders ...*UserBlockCreate) *UserBlockCreateBulk {
	return &UserBlockCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserBlockClient) MapCreateBulk(slice any, setFunc func(*UserBlockCreate, int)) *UserBlockCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserBlockCreateBulk{err: fmt.Errorf("calling to UserBlockClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserBlockCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserBlockCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserBlock.
func (c *UserBlockClient) Update() *UserBlockUpdate {
	mutation := newUserBlockMutation(c.config, OpUpdate)
	return &UserBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserBlockClient) UpdateOne(_m *UserBlock) *UserBlockUpdateOne {
	mutation := newUserBlockMutation(c.config, OpUpdateOne, withUserBlock(_m))
	return &UserBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserBlockClient) UpdateOneID(id string) *UserBlockUpdateOne {
	mutation := newUserBlockMutation(c.config, OpUpdateOne, withUserBlockID(id))
	return &UserBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserBlock.
func (c *UserBlockClient) Delete() *UserBlockDelete {
	mutation := newUserBlockMutation(c.config, OpDelete)
	return &UserBlockDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserBlockClient) DeleteOne(_m *UserBlock) *UserBlockDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserBlockClient) DeleteOneID(id string) *UserBlockDeleteOne {
	builder := c.Delete().Where(userblock.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserBlockDeleteOne{builder}
}

// Query returns a query builder for UserBlock.
func (c *UserBlockClient) Query() *UserBlockQuery {
	return &UserBlockQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserBlock},
		inters: c.Interceptors(),
	}
}

// Get returns a UserBlock entity by its id.
func (c *UserBlockClient) Get(ctx context.Context, id string) (*UserBlock, error) {
	return c.Query().Where(userblock.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserBlockClient) GetX(ctx context.Context, id string) *UserBlock {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlocker queries the blocker edge of a UserBlock.
func (c *UserBlockClient) QueryBlocker(_m *UserBlock) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userblock.Table, userblock.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userblock.BlockerTable, userblock.BlockerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBlocked queries the blocked edge of a UserBlock.
func (c *UserBlockClient) QueryBlocked(_m *UserBlock) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userblock.Table, userblock.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userblock.BlockedTable, userblock.BlockedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserBlockClient) Hooks() []Hook {
	return c.hooks.UserBlock
}

// Interceptors returns the client interceptors.
func (c *UserBlockClient) Interceptors() []Interceptor {
	return c.inters.UserBlock
}

func (c *UserBlockClient) mutate(ctx context.Context, m *UserBlockMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserBlockCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserBlockUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserBlockUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserBlockDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserBlock mutation op: %q", m.Op())
	}
}

// UserReportClient is a client for the UserReport schema.
type UserReportClient struct {
	config
}

// NewUserReportClient returns a client for the UserReport from the given config.
func NewUserReportClient(c config) *UserReportClient {
	return &UserReportClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userreport.Hooks(f(g(h())))`.
func (c *UserReportClient) Use(hooks ...Hook) {
	c.hooks.UserReport = append(c.hooks.UserReport, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userreport.Intercept(f(g(h())))`.
func (c *UserReportClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserReport = append(c.inters.UserReport, interceptors...)
}

// Create returns a builder for creating a UserReport entity.
func (c *UserReportClient) Create() *UserReportCreate {
	mutation := newUserReportMutation(c.config, OpCreate)
	return &UserReportCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserReport entities.
func (c *UserReportClient) CreateBulk(builders ...*UserReportCreate) *UserReportCreateBulk {
	return &UserReportCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserReportClient) MapCreateBulk(slice any, setFunc func(*UserReportCreate, int)) *UserReportCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserReportCreateBulk{err: fmt.Errorf("calling to UserReportClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserReportCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserReportCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserReport.
func (c *UserReportClient) Update() *UserReportUpdate {
	mutation := newUserReportMutation(c.config, OpUpdate)
	return &UserReportUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserReportClient) UpdateOne(_m *UserReport) *UserReportUpdateOne {
	mutation := newUserReportMutation(c.config, OpUpdateOne, withUserReport(_m))
	return &UserReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserReportClient) UpdateOneID(id string) *UserReportUpdateOne {
	mutation := newUserReportMutation(c.config, OpUpdateOne, withUserReportID(id))
	return &UserReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserReport.
func (c *UserReportClient) Delete() *UserReportDelete {
	mutation := newUserReportMutation(c.config, OpDelete)
	return &UserReportDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserReportClient) DeleteOne(_m *UserReport) *UserReportDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserReportClient) DeleteOneID(id string) *UserReportDeleteOne {
	builder := c.Delete().Where(userreport.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserReportDeleteOne{builder}
}

// Query returns a query builder for UserReport.
func (c *UserReportClient) Query() *UserReportQuery {
	return &UserReportQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserReport},
		inters: c.Interceptors(),
	}
}

// Get returns a UserReport entity by its id.
func (c *UserReportClient) Get(ctx context.Context, id string) (*UserReport, error) {
	return c.Query().Where(userreport.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserReportClient) GetX(ctx context.Context, id string) *UserReport {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReporter queries the reporter edge of a UserReport.
func (c *UserReportClient) QueryReporter(_m *UserReport) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userreport.Table, userreport.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userreport.ReporterTable, userreport.ReporterColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReported queries the reported edge of a UserReport.
func (c *UserReportClient) QueryReported(_m *UserReport) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userreport.Table, userreport.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userreport.ReportedTable, userreport.ReportedColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserReportClient) Hooks() []Hook {
	return c.hooks.UserReport
}

// Interceptors returns the client interceptors.
func (c *UserReportClient) Interceptors() []Interceptor {
	return c.inters.UserReport
}

func (c *UserReportClient) mutate(ctx context.Context, m *UserReportMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserReportCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserReportUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserReportUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserReportDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("generated: unknown UserReport mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuditLog, CheckIn, Connection, CreditPackage, CreditTransaction, DiscoveryBatch,
		DiscoveryCard, Filter, Hobby, HobbyOption, Interest, Nudge, PaymentOrder,
		Photo, Profile, Reveal, RevealContent, RevealMilestone, Server, Streak, User,
		UserBlock, UserReport []ent.Hook
	}
	inters struct {
		AuditLog, CheckIn, Connection, CreditPackage, CreditTransaction, DiscoveryBatch,
		DiscoveryCard, Filter, Hobby, HobbyOption, Interest, Nudge, PaymentOrder,
		Photo, Profile, Reveal, RevealContent, RevealMilestone, Server, Streak, User,
		UserBlock, UserReport []ent.Interceptor
	}
)
